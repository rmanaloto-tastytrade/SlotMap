// <!--
//
// Copyright (c) 2024-2025 Kris Jusiak <kris@jusiak.net>
//
// | license          | namespace      | guard            | description                        |
// | ---------------- | -------------- | ---------------- | ---------------------------------- |
// | MIT [1]          | `perf::*`      | -                | https://opensource.org/license/mit |
// | Apache2+LLVM [2] | `perf::mca::*` | `PERF_LLVM == 1` | https://llvm.org/LICENSE.txt       |
//
// [1] The MIT License (MIT)
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// See https://opensource.org/license/mit for license information.
//
// [2] Apache License v2.0 with LLVM exceptions
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
/**
 * `perf`: C++2x Performance library
 * - https://github.com/qlibs/perf
 */
#ifndef PERF_GNU
#ifdef __GNUC__
  #define PERF_GNU 1
#else
  #define PERF_GNU 0
#endif
#endif

#if (not defined(PERF_LINUX)) or (defined(PERF_LINUX) and PERF_LINUX == 1)
#if __has_include(<cpuid.h>) and \
    __has_include(<unistd.h>) and \
    __has_include(<pthread.h>) and \
    __has_include(<sched.h>) and \
    __has_include(<sys/time.h>) and\
    __has_include(<sys/syscall.h>) and \
    __has_include(<sys/resource.h>) and \
    __has_include(<sys/ioctl.h>) and \
    __has_include(<sys/prctl.h>) and \
    __has_include(<sys/mman.h>) and \
    __has_include(<linux/perf_event.h>)
#include <cpuid.h>
#include <unistd.h>
#include <pthread.h>
#include <sched.h>
#include <sys/time.h>
#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <linux/perf_event.h>
#ifndef PERF_LINUX
  #define PERF_LINUX 1
#endif
#elif PERF_LINUX == 1
  #error "<linux*.h>"
#else
  #define PERF_LINUX 0
#endif
#endif

#if not defined(PERF_UEFI)
  #define PERF_UEFI 0
#endif

#if (not defined(PERF_LLVM)) or (defined(PERF_LLVM) and PERF_LLVM == 1)
#if __has_include(<llvm/TargetParser/Host.h>) and \
    __has_include(<llvm/TargetParser/Triple.h>) and \
    __has_include(<llvm/Support/TargetSelect.h>) and \
    __has_include(<llvm/Object/SymbolSize.h>) and \
    __has_include(<llvm/MC/MCDisassembler/MCDisassembler.h>) and \
    __has_include(<llvm/MC/MCInstPrinter.h>) and \
    __has_include(<llvm/MC/MCTargetOptions.h>) and \
    __has_include(<llvm/MC/TargetRegistry.h>) and \
    __has_include(<llvm/MC/MCContext.h>) and \
    __has_include(<llvm/MC/MCAsmInfo.h>) and \
    __has_include(<llvm/MC/MCInstrInfo.h>) and \
    __has_include(<llvm/MC/MCRegisterInfo.h>) and \
    __has_include(<llvm/MC/MCSubtargetInfo.h>) and \
    __has_include(<llvm/MCA/View.h>) and \
    __has_include(<llvm/MCA/Pipeline.h>) and \
    __has_include(<llvm/MCA/CodeEmitter.h>) and \
    __has_include(<llvm/MCA/Context.h>) and \
    __has_include(<llvm/MCA/InstrBuilder.h>) and \
    __has_include(<llvm/MCA/Stages/EntryStage.h>) and \
    __has_include(<llvm/MCA/Stages/InstructionTables.h>) and \
    __has_include(<llvm/DebugInfo/Symbolize/Symbolize.h>)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#include <llvm/TargetParser/Host.h>
#include <llvm/TargetParser/Triple.h>
#include <llvm/Support/TargetSelect.h>
#include <llvm/MC/TargetRegistry.h>
#include <llvm/Object/SymbolSize.h>
#include <llvm/MC/MCDisassembler/MCDisassembler.h>
#include <llvm/MC/MCInstPrinter.h>
#include <llvm/MC/MCTargetOptions.h>
#include <llvm/MC/MCContext.h>
#include <llvm/MC/MCAsmInfo.h>
#include <llvm/MC/MCInstrInfo.h>
#include <llvm/MC/MCRegisterInfo.h>
#include <llvm/MC/MCSubtargetInfo.h>
#include <llvm/MCA/View.h>
#include <llvm/MCA/Pipeline.h>
#include <llvm/MCA/CodeEmitter.h>
#include <llvm/MCA/Context.h>
#include <llvm/MCA/InstrBuilder.h>
#include <llvm/MCA/Stages/EntryStage.h>
#include <llvm/MCA/Stages/InstructionTables.h>
#include <llvm/DebugInfo/Symbolize/Symbolize.h>
#pragma GCC diagnostic pop
#ifndef PERF_LLVM
  #define PERF_LLVM 1
#endif
#elif PERF_LLVM == 1
  #error "<llvm*.h>"
#else
  #define PERF_LLVM 0
#endif
#endif

#if (not defined(PERF_INTEL)) or (defined(PERF_INTEL) and PERF_INTEL == 1)
#if __has_include(<intel-pt.h>)
#include <intel-pt.h>
#ifndef PERF_INTEL
  #define PERF_INTEL 1
#endif
#elif PERF_INTEL == 1
  #error "<intel*.h>"
#else
  #define PERF_INTEL 0
#endif
#endif
#include <cstdint>
#include <climits>
#include <cstring>

#include <bit>
#include <atomic>
#include <barrier>
#include <thread>
#include <chrono>
#include <random>
#include <utility>
#include <memory>
#include <type_traits>
#include <concepts>

#include <string>
#include <string_view>
#include <fstream>
#include <initializer_list>
#include <format>
#include <stdexcept>
#include <source_location>
#include <filesystem>

#include <array>
#include <vector>
#include <list>
#include <deque>
#include <map>
#include <set>
#include <span>
#include <unordered_map>
#include <tuple>
#include <optional>
#include <any>

#include <numeric>
#include <algorithm>

namespace perf::inline v_0_0_0 {
inline namespace utility {
  /**
   * verifies whether condition is satisfied / aborts if not
   * @code
   *  try {
   *    // ...
   *  } catch (const std::exception& e) {
   *    std::println("{}{}", e.what(), std::stacktrace::current());
   *  }
   * @endcode
   */
  inline constexpr auto verify =
    [](const std::same_as<bool> auto cond, const std::convertible_to<std::string_view> auto&... msgs) {
      if (not cond) [[unlikely]] {
        [&] [[gnu::cold]] { throw std::runtime_error{(msgs + ... + std::string())}; }();
      }
    };

  template<auto V>
    requires std::is_class_v<decltype(V)> and requires { decltype(V)(V); }
  struct constant : decltype(V) {
    constexpr constant() : decltype(V)(V) { }
  };

  template<class T>
    requires requires { T{}; }
  struct strong_alias {
    constexpr strong_alias() = default;
    constexpr explicit(false) strong_alias(const T& value)
      : value{value}
    { }
    [[nodiscard]] constexpr operator auto() const {
      return value;
    }
    T value{};
  };

  #if __cpp_lib_fixed_string /// `std::basic_fixed_string` - https://wg21.link/p3094
  template<std::size_t N>
  using fixed_string = std::basic_fixed_string<char, N>;
  #else
  template<class T, std::size_t N>
  struct basic_fixed_string {
    constexpr basic_fixed_string() = default;
    constexpr explicit(false) basic_fixed_string(const T (&str)[N]) { std::copy_n(str, N, this->str); }
    [[nodiscard]] constexpr auto data() const { return str; }
    [[nodiscard]] static constexpr auto size() { return N - 1u; }
    template<class TView> [[nodiscard]] constexpr operator TView() const
      requires requires { TView{data(), size()}; } {
      return TView{data(), size()};
    }
    T str[N]{}; /// null terminated
  };
  template<std::size_t N>
  using fixed_string = basic_fixed_string<char, N>;
  #endif // __cpp_lib_fixed_string

  inline constexpr auto concat = []<class... Ts>(const Ts&... ts)
    requires (requires { ts.data(); Ts::size(); } and ...) {
    fixed_string<(Ts::size() + ... + 1u)> v{};
    std::size_t n{};
    ([&] {
      for (auto i = 0u; i < ts.size(); ++i) { v.str[n + i] = ts.str[i]; }
      n += ts.size();
    }(), ...);
    return v;
  };

  /**
   * named type with compile-time name
   */
  template<fixed_string Name, class T>
    requires (std::is_class_v<T> and not std::is_final_v<T>)
  struct fixed_named : T {
    using underlying_type = T;

    constexpr fixed_named() = default;
    constexpr explicit fixed_named(auto&&... ts)
      requires requires { T(std::forward<decltype(ts)>(ts)...); }
      : T(std::forward<decltype(ts)>(ts)...)
    { }

    [[nodiscard]] static constexpr decltype(auto) name() {
      static constexpr auto name = Name;
      return (name);
    }
  };

  template<fixed_string Name, class T>
  [[nodiscard]] inline constexpr auto make_fixed_named(T&& t)
    -> fixed_named<Name, std::remove_cvref_t<T>> {
    return fixed_named<Name, std::remove_cvref_t<T>>{std::forward<T>(t)};
  }

  /**
   * named type with run-time name
   */
  template<class TName, class T>
    requires (std::is_class_v<T> and not std::is_final_v<T>)
  struct named : T {
    using underlying_type = T;

    constexpr named() = default;
    constexpr named(TName name, T t)
      : T{std::move(t)}, name_{std::move(name)}
    { }

    [[nodiscard]] constexpr decltype(auto) name() const {
      return name_;
    }

   private:
    TName name_{};
  };

  template<std::size_t N, class T>
  named(const char (&name)[N], T&&) -> named<std::string_view, T>;

  /**
   * scoped { .on_entry = ctor, .on_exit = dtor }
   */
  template<class TOnEntry = decltype([]{}), class TOnExit = decltype([]{})>
  struct scoped final {
    TOnEntry on_entry{};
    TOnExit on_exit{};

    struct _on_entry {
      constexpr explicit _on_entry(const auto& on_entry) {
        on_entry();
      }
    } _on_entry{on_entry};

    constexpr ~scoped() noexcept {
      on_exit();
    }
  };

  template<class T, auto... Vs> requires requires { T{Vs...}; }
  struct initialized : T {
    constexpr initialized() : T{Vs...} { }
  };

  template<class T, auto... Vs> requires requires { T{Vs...}; }
  struct converted {
    [[nodiscard]] constexpr operator T() const {
      return T{Vs...};
    }
  };

  template<class... Ts> struct overload : Ts... { using Ts::operator()...; };
  template<class... Ts> overload(Ts...) -> overload<Ts...>;
} // namespace utility

/**
 * meta-programming
 * - https://wg21.link/p2996
 */
namespace mp {
  template<class...>
  struct type_list { };

  template<class...>
  extern constexpr auto type_id = +[]{};

  #if __has_feature(reflection) /// `reflection for C++26` # https://wg21.link/p2996
  template<class T>
  extern constexpr auto meta = ^^T;
  using info = decltype(^^::);
  template<info meta>
  using type_of = typename [: meta :];
  #else
  namespace detail {
    template<auto...> struct info { constexpr auto friend get(info); };
    template<class T, auto... Tags> struct meta {
      [[nodiscard]] constexpr auto friend get(info<Tags...>) {
        return std::type_identity<T>{};
      }
    };
  } // namespace detail

  template<class T>
  extern constexpr auto meta = (detail::meta<T, type_id<T>>(), type_id<T>);
  using info = std::remove_cvref_t<decltype(meta<void>)>;
  template<auto meta>
  using type_of = typename decltype(get(detail::info<meta>{}))::type;

  template<auto Tag, class T = class none, auto N = 0ul, class... Ts, auto = []{}>
  [[nodiscard]] constexpr auto version() {
    if constexpr (std::same_as<T, none>) {
      if constexpr (requires { get(detail::info<Tag, N>{}); }) {
        return version<Tag, T, N + 1ul, Ts..., decltype(get(detail::info<Tag, N>{}))>();
      } else {
        return type_list<typename Ts::type...>{};
      }
    } else if constexpr (requires { get(detail::info<Tag, N>{}); }) {
      return version<Tag, T, N + 1ul>();
    } else {
      detail::meta<T, Tag, N>();
      return N;
    }
  }
  #endif // reflection

  template<class...>
  extern constexpr auto size = 0u;
  template<template<class...> class T, class... Ts>
  extern constexpr auto size<T<Ts...>> = sizeof...(Ts);

  template<template<class...> class T, std::ranges::range auto R>
  [[nodiscard]] inline constexpr auto apply() {
    return []<std::size_t... Ns>(std::index_sequence<Ns...>) {
      return T<type_of<R[Ns]>...>{};
    }(std::make_index_sequence<R.size()>{});
  }

  template<template<class...> class T, std::ranges::range auto R>
  using apply_t = decltype(apply<T, R>());

  template<auto Fn, template<class...> class T>
  inline constexpr auto filter = []<template<class...> class TList, class... Ts>(TList<Ts...>) {
    constexpr auto filtered = [] {
      #if __cpp_lib_inplace_vector /// `std::inplace_vector` # https://wg21.link/p0843
      using meta_vector = std::inplace_vector<meta, sizeof...(Ts)>;
      #else
      struct meta_vector {
        constexpr auto push_back(const info info) {
          data_[size_++] = info;
        }
        [[nodiscard]] constexpr auto operator[](const std::size_t i) const {
          return data_[i];
        }
        [[nodiscard]] constexpr auto begin() const { return data_.begin(); }
        [[nodiscard]] constexpr auto end() const { return begin() + size_; }
        [[nodiscard]] constexpr auto size() const { return size_; }
       private:
        std::array<info, sizeof...(Ts)> data_{};
        std::size_t size_{};
      };
      #endif // __cpp_lib_inplace_vector
      meta_vector v{};
      ([&] {
        if (Fn.template operator()<Ts>() and
          std::find(v.begin(), v.end(), meta<Ts>) == v.end()) {
          v.push_back(meta<Ts>);
        }
      }(), ...);
      return v;
    }();
    return [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
      if constexpr (requires { T{type_of<filtered[Ns]>{}...}; }) {
        return T{type_of<filtered[Ns]>{}...};
      } else if constexpr (requires { T<type_of<filtered[Ns]>...>{}; }) {
        return T<type_of<filtered[Ns]>...>{};
      }
    }(std::make_index_sequence<filtered.size()>{});
  };

  template<std::size_t N>
  inline constexpr auto unroll = [](auto&& fn) {
    const auto invoke = [&]<std::size_t I> {
      if constexpr (requires { fn.template operator()<std::size_t{}>(); }) {
        fn.template operator()<I>();
      } else {
        fn();
      }
    };
    [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
      (invoke.template operator()<Ns>(), ...);
    }(std::make_index_sequence<N>{});
  };

  template<std::ranges::range auto R>
  inline constexpr auto for_each = [](auto&& fn) {
    [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
      (fn.template operator()<R[Ns]>(), ...);
    }(std::make_index_sequence<R.size()>{});
  };

  template<class...> struct function_traits;
  template<class T> requires requires { &T::operator(); }
  struct function_traits<T>
    : function_traits<decltype(&T::operator())>
  { };
  template<class T> requires requires { &T::template operator()<>; }
  struct function_traits<T>
    : function_traits<decltype(&T::template operator()<>)>
  { };
  template<class R, class... Ts>
  struct function_traits<R (Ts...)> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class... Ts>
  struct function_traits<R (Ts...) noexcept> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class... Ts>
  struct function_traits<R (*)(Ts...)> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class... Ts>
  struct function_traits<R (*)(Ts...) noexcept> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class T, class... Ts>
  struct function_traits<R (T::*)(Ts...) const> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class T, class... Ts>
  struct function_traits<R (T::*)(Ts...) const noexcept> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class T, class... Ts>
  struct function_traits<R (T::*)(Ts...)> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
  template<class R, class T, class... Ts>
  struct function_traits<R (T::*)(Ts...) noexcept> {
    using result_type = R;
    using args_type = type_list<Ts...>;
  };
} // namespace mp

namespace data {
  inline namespace random {
    /**
     * probabilitiy choice, ex. `choice<int>{.values = {1,2}, .probabilities{.75, .25}} -> {1,2,1,1,1,2,1,1,2,2,1,1,...}`
     */
    template<
      class T,
      class TEngine = std::mt19937,
      class TSeed = typename TEngine::result_type
    > struct choice {
      using value_type = T;

      std::vector<T> values{};
      std::vector<double> probabilities{};
      TSeed seed{};

      [[nodiscard]] constexpr auto operator()(const std::size_t n, ...) const {
        verify(not values.empty(), "empty values");
        verify(not probabilities.empty(), "empty probabilities");
        verify(values.size() == probabilities.size(),
          std::format("size({} != {})", values.size(), probabilities.size())
        );
        verify(std::fabs(std::accumulate(probabilities.begin(), probabilities.end(), .0) - 1.) < 1e-9,
          std::format("probablity({} != 1)",
            std::accumulate(probabilities.begin(), probabilities.end(), .0)
          )
        );

        std::vector<std::size_t> pi(100u);
        std::uniform_int_distribution<std::size_t> dist{0u, 100u - 1u};
        TEngine engine{seed};
        auto id = 0u;
        auto iv = probabilities[id] * 100.;
        for (auto i = 0u; i < pi.size(); ++i) {
          if (i > iv) {
            ++id;
            iv += probabilities[id] * 100.;
          }
          pi[i] = id;
        }

        std::vector<T> r(n);
        for (auto& v : r) {
          v = values[pi[dist(engine)]];
        }

        return r;
      }
    };

    /**
     * uniform distrubution ex. `uniform<int>{.min = 1, .max = 3} -> {1,1,2,1,3,2,1,3,...}`
     */
    template<
      class TMin,
      class TMax = TMin,
      class TEngine = std::mt19937,
      class TDistribution = std::conditional_t<
        std::is_floating_point_v<TMin>,
        std::uniform_real_distribution<TMin>,
        std::uniform_int_distribution<TMin>
      >,
      class TSeed = typename TEngine::result_type
    > requires std::same_as<TMin, TMax>
    struct uniform {
      using value_type = TMin;

      TMin min = std::numeric_limits<TMin>::min();
      TMax max = std::numeric_limits<TMax>::max();
      TSeed seed{};

      [[nodiscard]] constexpr auto operator()(const std::size_t n, const std::size_t sub_seed = {}) const {
        std::vector<typename TDistribution::result_type> r(n);
        verify(max >= min, std::format("{} >= {}", max, min));
        TDistribution dist{min, max};
        TEngine engine{seed + sub_seed};
        for (auto& v : r) {
          v = dist(engine);
        }
        return r;
      }
    };

    // TODO
    // std::bernoulli_distribution dist;
    //template <typename U> auto bernoulli_()
    //{
      //std::bernoulli_distribution dist;
      //return data;
    //}

    /**
     * normal distrubution ex. `normal<float>{.mean = .1, .stddev = 1.} -> {.11, .22, .12, ...}
     */
    template<
      class T,
      class TEngine = std::mt19937,
      class TDistribution = std::normal_distribution<T>,
      class TSeed = typename TEngine::result_type
    > requires std::is_floating_point_v<T>
    struct normal {
      using value_type = T;

      T mean{};
      T stddev{1};
      TSeed seed{};

      [[nodiscard]] constexpr auto operator()(const std::size_t n, const std::size_t sub_seed = {}) const {
        std::vector<typename TDistribution::result_type> r(n);
        TDistribution dist{value_type(mean), value_type(stddev)};
        TEngine engine{seed + sub_seed};
        for (auto& v : r) {
          v = dist(engine);
        }
        return r;
      }
    };

    namespace detail {
      template<class T>
        requires (std::integral<T> or std::floating_point<T>)
      struct unpredictable : uniform<T> { };
    } // namespace detail

    template<class T>
      requires (std::integral<T> or std::floating_point<T>)
    inline constexpr auto unpredictable = detail::unpredictable<T>{};
  } // namespace random

  inline namespace fixed {
    /**
     * sequence, ex. `sequence<int>{{1,2,3}} -> {1,2,3,1,2,3,1,2,3,...}`
     */
    template<class T>
    struct sequence {
      using value_type = T;

      std::vector<T> values{};

      [[nodiscard]] constexpr auto operator()(const std::size_t n, ...) const {
        std::vector<value_type> r(n);
        if (not n) {
          return r;
        }
        auto i = 0u;
        while (true) { /// repeats the sequence until size(n) is reached
          for (const auto& v : values) {
            verify(i < n);
            r[i++] = v;
            if (i >= n) return r;
          }
        }
        return r;
      }
    };

    /**
     * range of values, ex. `range<int>{.start = 0, .stop = 5, step = 2} -> {0,2,4,0,2,4,0,2,4,...}`
     */
    template<class T>
    struct range {
      using value_type = T;

      T start{};
      T stop{};
      T step{1};

      [[nodiscard]] constexpr auto operator()(const std::size_t n, ...) const {
        std::vector<value_type> r(n);
        for (auto i = 0u; i < n; ++i) {
          r[i] = (value_type(i) * step + start) % stop;
        }
        return r;
      }
    };

    inline constexpr auto linspace =
      []<class T> requires std::is_arithmetic_v<T>(const T start, const T end, const std::size_t size = {}) {
        const auto n = size ? size : static_cast<std::size_t>(end - start + 1u);
        verify(n > 1u);
        std::vector<T> r(n);
        const auto step = (end - start) / static_cast<T>(n - 1u);
        for (auto i = 0u; i < n; ++i) {
          r[i] = start + i * step;
        }
        return r;
      };

    inline constexpr auto bin =
      []<std::ranges::range T>(
        const T& v,
        const typename T::value_type start,
        const typename T::value_type end,
        const std::size_t size
      ) {
        verify(size > 1u);
        std::vector<std::size_t> r(size);
        const auto step = (end - start) / static_cast<typename T::value_type>(size - 1u);
        for (const auto& val : v) {
          ++r[static_cast<std::size_t>((val - start) / step)];
        }
        return r;
      };
  } // namespace fixed

  template<class T, class TGenerator>
    requires requires (TGenerator generator, std::size_t n) { T(generator(n)); }
  struct sampler {
    TGenerator generator{};
    std::size_t size{};

    [[nodiscard]] constexpr auto operator()(const std::size_t n) const {
      std::vector<T> v(n);
      std::generate(v.begin(), v.end(), [&] { return generator(size); });
      return v;
    }
  };

  template<class T, class TGenerator>
    requires requires (TGenerator generator, std::size_t n) { T(generator(n)); }
  [[nodiscard]] inline constexpr auto sample(TGenerator&& generator, std::size_t size) {
    return sampler<T, TGenerator>{std::forward<decltype(generator)>(generator), size};
  }
} // namespace data

namespace metric::inline dsl {
  namespace detail {
    template<class T>
    [[nodiscard]] constexpr decltype(auto) to_underlying(const T& t) {
      if constexpr (requires { typename T::underlying_type; }) {
        return static_cast<const typename T::underlying_type&>(t);
      } else {
        return (t);
      }
    }
  } // namespace detail

  template<fixed_string Name, class TLhs, class TRhs, auto Fn>
  struct op {
    using element_type = mp::type_list<TLhs, TRhs>;

    [[nodiscard]] static constexpr decltype(auto) name() {
      static constexpr auto name = Name;
      return (name);
    }

    [[nodiscard]] constexpr auto operator()(auto&& data) const {
      return fixed_named<Name, typename std::remove_cvref_t<decltype(std::get<0u>(data[lhs]))>::underlying_type>{
        Fn(detail::to_underlying(std::get<0u>(data[lhs])), detail::to_underlying(std::get<0u>(data[rhs])))
      };
    }

    TLhs lhs;
    TRhs rhs;
  };

  [[nodiscard]] constexpr auto operator+(const std::ranges::range auto& lhs, const std::ranges::range auto& rhs) {
    verify(lhs.size() == rhs.size());
    std::vector<typename std::remove_cvref_t<decltype(lhs)>::value_type> res(lhs.size());
    for (auto i = 0u; i < lhs.size(); ++i) {
      res[i] = lhs[i] + rhs[i];
    }
    return res;
  }

  [[nodiscard]] constexpr auto operator-(const std::ranges::range auto& lhs, const std::ranges::range auto& rhs) {
    verify(lhs.size() == rhs.size());
    std::vector<typename std::remove_cvref_t<decltype(lhs)>::value_type> res(lhs.size());
    for (auto i = 0u; i < lhs.size(); ++i) {
      res[i] = lhs[i] - rhs[i];
    }
    return res;
  }

  [[nodiscard]] constexpr auto operator*(const std::ranges::range auto& lhs, const std::ranges::range auto& rhs) {
    // TODO if size one
    verify(lhs.size() == rhs.size());
    std::vector<typename std::remove_cvref_t<decltype(lhs)>::value_type> res(lhs.size());
    for (auto i = 0u; i < lhs.size(); ++i) {
      res[i] = lhs[i] * rhs[i];
    }
    return res;
  }

  [[nodiscard]] constexpr auto operator/(const std::ranges::range auto& lhs, const std::ranges::range auto& rhs) {
    std::vector<typename std::remove_cvref_t<decltype(lhs)>::value_type> res(lhs.size());
    if (lhs.size() == rhs.size()) {
      for (auto i = 0u; i < lhs.size(); ++i) {
        res[i] = lhs[i] / rhs[i];
      }
    } else if (rhs.size() == 1u and lhs.size() >= rhs.size()) {
      for (auto i = 0u; i < lhs.size(); ++i) {
        res[i] = lhs[i] / rhs[0u];
      }
    } else if (lhs.size() == 1u and rhs.size() >= lhs.size()) {
      for (auto i = 0u; i < rhs.size(); ++i) {
        res[i] = lhs[0u] / rhs[i];
      }
    }
    return res;
  }

  template<class TLhs, class TRhs>
    requires requires { TLhs::name(); TRhs::name(); }
  [[nodiscard]] constexpr auto operator+(const TLhs& lhs, const TRhs& rhs) {
    return op<
      concat(fixed_string{"("}, TLhs::name(), fixed_string{"+"}, TRhs::name(), fixed_string{")"}),
      TLhs, TRhs,
      [](const auto& lhs, const auto& rhs) { return lhs + rhs; }
    >{lhs, rhs};
  }

  template<class TLhs, class TRhs>
    requires requires { TLhs::name(); TRhs::name(); }
  [[nodiscard]] constexpr auto operator-(const TLhs& lhs, const TRhs& rhs) {
    return op<
      concat(fixed_string{"("}, TLhs::name(), fixed_string{"-"}, TRhs::name(), fixed_string{")"}),
      TLhs, TRhs,
      [](const auto& lhs, const auto& rhs) { return lhs - rhs; }
    >{lhs, rhs};
  }

  template<class TLhs, class TRhs>
    requires requires { TLhs::name(); TRhs::name(); }
  [[nodiscard]] constexpr auto operator*(const TLhs& lhs, const TRhs& rhs) {
    return op<
      concat(fixed_string{"("}, TLhs::name(), fixed_string{"*"}, TRhs::name(), fixed_string{")"}),
      TLhs, TRhs,
      [](const auto& lhs, const auto& rhs) { return lhs * rhs; }
    >{lhs, rhs};
  }

  template<class TLhs, class TRhs>
    requires requires { TLhs::name(); TRhs::name(); }
  [[nodiscard]] constexpr auto operator/(const TLhs& lhs, const TRhs& rhs) {
    return op<
      concat(fixed_string{"("}, TLhs::name(), fixed_string{"/"}, TRhs::name(), fixed_string{")"}),
      TLhs, TRhs,
      [](const auto& lhs, const auto& rhs) { return lhs / rhs; }
    >{lhs, rhs};
  }

  //todo remove
  template<class T>
  [[nodiscard]] constexpr decltype(auto) operator*(const std::tuple<T>& t) {
    return std::get<T>(t);
  }

  inline namespace stat {
    inline constexpr auto min = make_fixed_named<"min">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        verify(not v.empty());
        return *std::min_element(v.begin(), v.end());
      });

    inline constexpr auto max = make_fixed_named<"max">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        verify(not v.empty());
        return *std::max_element(v.begin(), v.end());
      });

    inline constexpr auto median = make_fixed_named<"median">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        using value_type = typename T::value_type;
        verify(not v.empty());
        std::vector<value_type> res{v.begin(), v.end()};
        std::sort(res.begin(), res.end());
        if (const auto n = res.size(); n % 2u) {
          return res[n / 2u];
        } else {
          return (res[n / 2u - 1u] + res[n / 2u]) / 2.;
        }
      });

    inline constexpr auto mean = make_fixed_named<"mean">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        verify(not v.empty());
        return std::accumulate(v.begin(), v.end(), typename T::value_type{}) / v.size();
      });

    inline constexpr auto geomean = make_fixed_named<"geomean">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        verify(not v.empty());
        const auto product = std::accumulate(
          v.begin(), v.end(), 1., std::multiplies{}
        );
        return std::pow(product, 1. / v.size());
      });

    inline const auto percentile = [](const std::size_t p) {
      return named{("p" + std::to_string(p)),
        [p]<std::ranges::range T>(const T& v) -> typename T::value_type {
          using value_type = typename T::value_type;
          verify(not v.empty());
          std::vector<value_type> res{v.begin(), v.end()};
          std::sort(res.begin(), res.end());
          return res[p / 100. * (res.size() - 1)];
        }};
    };

    inline const auto p10 = percentile(10u);
    inline const auto p25 = percentile(25u);
    inline const auto p50 = percentile(50u);
    inline const auto p75 = percentile(75u);
    inline const auto p90 = percentile(90u);
    inline const auto p95 = percentile(95u);
    inline const auto p99 = percentile(99u);

    inline constexpr auto variance = make_fixed_named<"variance">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        verify(not v.empty());
        return std::accumulate(
          v.begin(), v.end(), typename T::value_type{},
          [&](const auto acc, const auto value) {
            return acc + std::pow(value - mean(v), 2);
          }
        ) / v.size();
      });

    inline constexpr auto stddev = make_fixed_named<"stddev">(
      []<std::ranges::range T>(const T& v, const std::size_t degrees_of_freedom = 1u) -> typename T::value_type {
        verify(not v.empty());
        verify(degrees_of_freedom > 0u);
        return std::sqrt(variance(v) / degrees_of_freedom);
      });

    inline constexpr auto sem = make_fixed_named<"sem">(
      []<class R = double>(const std::ranges::range auto& v) -> R {
        verify(not v.empty());
        return stddev(v) / std::sqrt(v.size());
      });

    inline constexpr auto mad = make_fixed_named<"mad">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        using value_type = typename T::value_type;
        std::vector<value_type> deviations(v.size());
        const auto median = stat::median(v);
        std::size_t i{};
        for (const auto& value : v) {
          deviations[i++] = std::fabs(value - median);
        }
        return stat::median(deviations);
      });

    inline constexpr auto mae = make_fixed_named<"mae">(
      []<class R = double>(const std::ranges::range auto& v) -> R {
        std::vector<R> errors{};
        errors.reserve(v.size());
        const auto predicted = median(v);
        for (auto it = v.begin(); it != v.end(); ++it) {
          if (*it) {
            errors.push_back(std::fabs((*it - predicted) / *it));
          }
        }
        return median(errors);
      });

    inline constexpr auto cv = make_fixed_named<"cv">(
      []<std::ranges::range T>(const T& v) -> typename T::value_type {
        verify(not v.empty());
        return stddev(v) / mean(v);
      });

    inline constexpr auto z_score = make_fixed_named<"z_score">(overload{
      [](const std::floating_point auto confidence) {
        const auto p = 1 - (1 - confidence) / 2;

        /// wilson-hilferty transformation
        const auto t = std::sqrt(-2 * std::log(1 - p));

        /// approximation using beasley-springer-moro's method
        const auto c0 = 2.515517, c1 = 0.802853, c2 = 0.010328;
        const auto d1 = 1.432788, d2 = 0.189269, d3 = 0.001308;
        const auto n = c0 + (c1 * t) + (c2 * t * t);
        const auto d = 1 + (d1 * t) + (d2 * t * t) + (d3 * t * t * t);

        return t - (n / d);
      },
      []<std::ranges::range T>(const T& v) {
        const auto mean = stat::mean(v);
        const auto stddev = stat::stddev(v);
        std::vector<typename T::value_type> z(v.size());
        std::size_t i{};
        for (const auto& value : v) {
          z[i++] = (value - mean) / stddev;
        }
        return z;
      },
    });

    inline constexpr auto t_score = make_fixed_named<"t_score">(overload{
      [](const std::floating_point auto confidence, const std::size_t degrees_of_freedom) {
        const auto d = degrees_of_freedom;
        const auto z = z_score(confidence);
        const auto q = std::sqrt(1 - (1. / (4. * d)));

        /// approximation using hill's method
        return (z + (z * z * z + 3 * z) / (4 * d) +
               (z * z * z * z * z + 16 * z * z * z + 15 * z) /
               (96 * d * d)) / q;
      },
      []<std::ranges::range T>(const T& v) {
        const auto mean = stat::mean(v);
        const auto stddev = stat::stddev(v);
        std::vector<typename T::value_type> t(v.size());
        std::size_t i{};
        for (const auto& value : v) {
          t[i++] = (value - mean) / (stddev / std::sqrt(v.size()));
        }
        return t;
      },
    });
  } // namesapce stat

  template<fixed_string Name, auto... Vs>
  inline constexpr auto value = make_fixed_named<Name>(
    [](auto&&){ return std::vector{Vs...}; }
  );
} // namespace metric::dsl

/**
 * hw/sw info
 */
namespace info {
  /**
   * https://semver.org
   */
  struct sem_ver {
    std::size_t major{};
    std::size_t minor{};
    std::size_t patch{};
  };

  inline constexpr auto debug = [] {
//    return NDEBUG; and llvm has symbols
    return false;
  };

  class spec final {
    struct formatted : std::string {
      constexpr formatted() = default;
      template<class T>
      constexpr explicit(false) formatted(T&& t)
        requires (not std::derived_from<std::remove_cvref_t<T>, formatted>)
        : std::string{std::format("{}", std::forward<T>(t))}
      {  }
    };

   public:
    constexpr spec() = default;
    constexpr explicit(false) spec(std::initializer_list<std::pair<const std::string, formatted>> data)
      : data_{data}
    { }

    [[nodiscard]] constexpr decltype(auto) operator[](const auto& key) {
      auto found = std::find_if(data_.begin(), data_.end(), [&key](const auto& kv) {
        return kv.first == key;
      });
      return found == data_.end() ?
        data_.emplace_back(key, formatted{}).second :
        (found->second)
      ;
    }

    [[nodiscard]] constexpr decltype(auto) operator[](const auto& key) const {
      const auto found = std::find_if(data_.begin(), data_.end(), [&key](const auto& kv) {
        return kv.first == key;
      });
      verify(found != data_.end(), std::format("'{}' not found!", key));
      return (found->second);
    }

    [[nodiscard]] constexpr auto begin() const { return data_.begin(); }
    [[nodiscard]] constexpr auto end() const { return data_.end(); }

   private:
    std::vector<std::pair<const std::string, formatted>> data_{};
  };

  namespace compiler {
    inline constexpr auto name = [] -> std::string_view {
      #if defined(__clang__)
      return "clang";
      #elif defined(__GNUC__)
      return "gcc";
      #elif defined(_MSC_VER)
      return "msvc";
      #else
      return "unknown";
      #endif
    };

    inline constexpr auto version = [] {
      #if defined(__clang__)
      return sem_ver{__clang_major__, __clang_minor__, __clang_patchlevel__};
      #elif defined(__GNUC__)
      return sem_ver{__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__};
      #elif defined(_MSC_VER)
      return sem_ver{_MSC_VER / 100, _MSC_VER % 100};
      #else
      return sem_ver{};
      #endif
    };
  } // namespace compiler

  /**
   * https://en.wikichip.org/wiki/intel/cpuid
   */
  namespace cpu {
    #if PERF_LINUX == 1
    inline constexpr auto name = [] -> std::string {
      std::array<char, 48u + 1u> name{};
      std::array<unsigned int, 4u> info{};
      std::size_t n{};
      for (auto i = 0u; i < name.size() - 1u; i += 16u) {
        __get_cpuid(0x80000002 + n++, &info[0], &info[1], &info[2], &info[3]);
        std::memcpy(name.data() + i, info.data(), sizeof(info));
      }
      /// ex. '12th Gen Intel(R) Core(TM) i7-12650H'
      const std::size_t size = std::distance(name.begin(), std::find(name.begin(), name.end(), 0)) - 1u;
      verify(size < name.size());
      return {name.data(), size};
    };
    #endif // PERF_LINUX

    #if PERF_LLVM == 1
    inline constexpr auto code_name = [] {
      return ::llvm::sys::getHostCPUName().str(); // ex. 'skylake', 'alderlake', ...
    };
    #endif // PERF_LLVM

    #if PERF_LINUX == 1
    struct cpu_ver {
      std::uint16_t family{};
      std::uint8_t model{};
      std::uint8_t stepping{};
    };

    inline constexpr auto version = [] {
      unsigned int eax{}, ebx{}, ecx{}, edx{};
      __get_cpuid(1u, &eax, &ebx, &ecx, &edx);

      const auto family = (eax >> 8u) & 0xF;
      const auto extended_family = (eax >> 20) & 0xFF;
      const auto model = (eax >> 4u) & 0xF;
      const auto extended_model = (eax >> 16u) & 0xF;

      return cpu_ver{
        .family = std::uint16_t(family == 0xF ? family + extended_family : family),
        .model = std::uint8_t(family == 0x6 or family == 0xF ? model + (extended_model << 4u) : model),
        .stepping = std::uint8_t(eax & 0xF),
      };
    };
    #endif // PERF_LINUX

    #if PERF_LLVM == 1
    /**
     * the number of micro-operations a core can send to its execution units per clock cycle
     * determines the degree of parallel instruction execution
     */
    inline constexpr auto dispatch_width = [](auto& llvm) {
      return llvm.subtarget_info->getSchedModel().IssueWidth;
    };

    inline constexpr auto features = [] {
      auto&& features = []<class TFeatures = ::llvm::StringMap<bool>>(auto&&... ts) {
        if constexpr (requires (TFeatures features) { ::llvm::sys::getHostCPUFeatures(features); }) {
          TFeatures features{};
          ::llvm::sys::getHostCPUFeatures(features);
          return features;
        } else if constexpr (requires { ::llvm::sys::getHostCPUFeatures(ts...); }) {
          return ::llvm::sys::getHostCPUFeatures(ts...);
        }
      }();
      std::vector<std::string> supported{};
      supported.reserve(features.size());
      for (const auto& [name, support] : features) {
        if (support) {
          supported.push_back(std::string(name));
        }
      }
      return supported; // ex. '{ avx, avx2, bmi2, ... }'
    };
    #endif // PERF_LLVM
  } // namespace cpu

  namespace memory {
    enum class level { L0, L1, L2, L3, L4 };

    struct info {
      std::size_t size{};
      std::size_t line_size{};
      std::size_t assoc{};
    };

    #if PERF_LINUX == 1
    inline constexpr auto icache = [] {
      return std::map<level, info>{
        {
          level::L1, {
            std::size_t(sysconf(_SC_LEVEL1_ICACHE_SIZE)),
            std::size_t(sysconf(_SC_LEVEL1_ICACHE_LINESIZE)),
          }
        },
      };
    };

    inline constexpr auto dcache = [] {
      return std::map<level, info>{
        {
          level::L1, {
            std::size_t(sysconf(_SC_LEVEL1_DCACHE_SIZE)),
            std::size_t(sysconf(_SC_LEVEL1_DCACHE_LINESIZE)),
            std::size_t(sysconf(_SC_LEVEL1_DCACHE_ASSOC)),
          }
        },
        {
          level::L2, {
            std::size_t(sysconf(_SC_LEVEL2_CACHE_SIZE)),
            std::size_t(sysconf(_SC_LEVEL2_CACHE_LINESIZE)),
            std::size_t(sysconf(_SC_LEVEL2_CACHE_ASSOC)),
          }
        },
        {
          level::L3, {
            std::size_t(sysconf(_SC_LEVEL3_CACHE_SIZE)),
            std::size_t(sysconf(_SC_LEVEL3_CACHE_LINESIZE)),
            std::size_t(sysconf(_SC_LEVEL3_CACHE_ASSOC)),
          }
        },
      };
    };

    inline constexpr auto peak_rss = [] {
      rusage usage{};
      getrusage(RUSAGE_SELF, &usage);
      struct kb : strong_alias<std::size_t> { };
      return kb{usage.ru_maxrss};
    };
    #endif // PERF_LINUX
  } // namespace memory

  namespace sys {
    inline constexpr auto name = [] -> std::string_view {
      #if defined(__linux__)
        return "linux";
      #elif defined(__unix__)
        return "unix";
      #elif defined(__FreeBSD__)
        return "freebsd";
      #elif defined(__APPLE__) or defined(__MACH__)
        return "macos";
      #elif defined(_WIN32) or defined(_WIN64)
        return "windows";
      #else
        return "unknown";
      #endif
    };

    #if PERF_LLVM == 1
    inline constexpr auto triple = [] {
      return ::llvm::Triple::normalize(::llvm::sys::getDefaultTargetTriple()); // ex. 'x86_64-pc-linux-gnu'
    };
    #endif // PERF_LLVM

    #if PERF_LINUX == 1
    inline constexpr auto page_size = [] {
      return sysconf(_SC_PAGESIZE); // ex. '4096' [kb]
    };

    /**
     * loads hw info form the given path and parse it accordingly to the format
     */
    template<fixed_string Fmt, class T = std::size_t>
    inline constexpr auto hw = [](const std::convertible_to<std::string_view> auto& path) {
      static constexpr auto size = [] {
        const auto str = std::string_view(Fmt);
        return 1u + std::count(str.begin(), str.end(), ',');
      }();

      std::ifstream file{path};
      if (not file.good()) {
        return std::optional<std::array<T, size>>();
      }
      std::string line{};
      std::getline(file, line);
      std::array<T, size> fields{};
      [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
        verify(std::sscanf(line.c_str(), std::string(Fmt).c_str(), &fields[Ns]...) == size);
      }(std::make_index_sequence<size>{});

      return std::optional{fields};
    };
    #endif // PERF_LINUX
  } // namespace sys

  namespace proc::inline self {
    #if PERF_LINUX == 1
    inline constexpr auto name = [] -> decltype(auto) {
      static const auto value = [] {
        return std::filesystem::canonical("/proc/self/exe"); // ex. `/tmp/a.out` # full path
      }();
      return value;
    };

    inline constexpr auto base_address = [] {
      static const auto value = [] {
        std::ifstream maps{"/proc/self/maps"};
        verify(maps.good());
        std::string line{};
        std::getline(maps, line);
        return std::stoull(line.substr(0, line.find('-')), nullptr, 16); // ex. `instruction_pointer - base_address()`
      }();
      return value;
    };
    #endif // PERF_LINUX
  } // namespace proc::self

  namespace bin {
    #if PERF_LLVM == 1
    /**
     * returns `filename:line` from executable/address
     */
    ///TODO that should be filename::line
    ///TODO addr_to_source
    inline constexpr auto addr_to_line = []<class TSymbolizer = ::llvm::symbolize::LLVMSymbolizer>(
      const std::string& executable, const std::uint64_t address, TSymbolizer&& symbolizer = {})
      -> std::optional<std::string> requires requires { symbolizer.symbolizeCode(executable, {address}); } {
      std::string line{};
      if (auto&& info = symbolizer.symbolizeCode(executable, {address}); info and info->Line) {
        std::ifstream file{info->FileName};
        verify(file.good());
        auto n = info->Line;
        while (n-- and std::getline(file, line));
        return line;
      }
      return {};
    };

    /**
     * returns `variable name` from excutable/address
     */
    inline constexpr auto addr_to_name = []<class TSymbolizer = ::llvm::symbolize::LLVMSymbolizer>(
      const std::string& executable, const std::uint64_t address, TSymbolizer&& symbolizer = {})
      -> std::optional<std::string> requires requires { symbolizer.symbolizeData(executable, {address}); } {
      if (auto&& info = symbolizer.symbolizeData(executable, {address}); info and not info->Name.empty()) {
        return info->Name;
      }
      return {};
    };

    /**
     * returns `function name` from executable/address
     */
    inline constexpr auto addr_to_fn_name = []<class TSymbolizer = ::llvm::symbolize::LLVMSymbolizer>(
      const std::string& executable, const std::uint64_t address, TSymbolizer&& symbolizer = {})
      -> std::optional<std::string> requires requires { symbolizer.symbolizeCode(executable, {address}); } {
      if (auto&& info = symbolizer.symbolizeCode(executable, {address}); info and not info->FunctionName.empty()) {
        return info->FunctionName;
      }
      return {};
    };

    inline constexpr auto fn_addrs = [] {
      using namespace ::llvm;
      using namespace ::llvm::object;
      auto binary_name = perf::info::proc::self::name();
      auto base_address = perf::info::proc::self::base_address();
      auto BufferOrErr = MemoryBuffer::getFile({binary_name});
      auto ObjOrErr = std::move(*ObjectFile::createObjectFile(BufferOrErr.get()->getMemBufferRef()));

      const auto SizesOrErr = computeSymbolSizes(*ObjOrErr);

      struct fn {
        std::uint64_t start{};
        std::uint64_t end{};
        std::string name{};
      };

      std::vector<fn> r{};
      for (const auto &Entry : SizesOrErr) {
          const auto& [Sym, Size] = Entry;

          auto TypeOrErr = Sym.getType();
          if (!TypeOrErr or *TypeOrErr != SymbolRef::ST_Function) {
              continue;
          }

          auto AddrOrErr = Sym.getAddress();
          auto NameOrErr = Sym.getName();

          if (!AddrOrErr or !NameOrErr or !Size) {
            continue;
          }

          auto Start = *AddrOrErr;
          auto End = Start + Size;
          r.push_back({Start, End, (*NameOrErr).str()});
      }

      return r;
    };
    #endif // PERF_LLVM
  } // namespace bin
} // namespace info

inline namespace core {
  namespace code {
    #if PERF_GNU == 1
    /**
     * gnu version of `[[clang::code_align(alignment)]]`
     */
    template<std::align_val_t Alignment>
      requires (std::has_single_bit(std::size_t(Alignment)))
    inline constexpr auto align = [] {
      asm volatile(".align %c0" : : "i"(Alignment));
    };

    /**
     * global compile-time code label # ld: `__start_labels`, `__stop_labels`
     * - local:  `LABEL: -> &&LABEL` # gnu extension
     * - global: `perf::code::label<"LABEL">() -> perf::code::labels["LABEL"]`
     */
    template<auto Label>
    inline constexpr auto label = [] {
      asm volatile goto(
        ".pushsection labels, \"aw\" \n"
        ".quad %c0, %l[L]\n" /// note: `.quad %c0, 0b` can be reordered
        ".popsection \n"
        : : "i"(Label) : "memory" : L
      ); L:;
    };

    /**
     * global compile-time code labels # see `perf::code::label`
     */
    extern "C" std::pair<std::uint64_t, std::uint64_t> __start_labels [[gnu::section("labels")]] [[gnu::weak]];
    extern "C" std::pair<std::uint64_t, std::uint64_t> __stop_labels [[gnu::section("labels")]] [[gnu::weak]];
    inline const struct labels : std::unordered_map<std::uint64_t, std::uint64_t> {
      using std::unordered_map<std::uint64_t, std::uint64_t>::unordered_map;
      [[nodiscard]] constexpr decltype(auto) operator[](const auto key) const
        requires requires { std::uint64_t(key); } {
        return at(std::uint64_t(key));
      }
    } labels{&__start_labels, &__stop_labels};
    #endif // PERF_GNU
  } // namespace code

  namespace compiler {
    /**
     * prevents memory instructions reorder
     */
    inline constexpr auto prevent_reorder = [](std::memory_order order) {
      std::atomic_signal_fence(order);
    };

    #if PERF_GNU == 1
    /**
     * prevents elision of given value
     */
    inline constexpr auto prevent_elision = [](auto&& t) -> decltype(auto) {
      if constexpr (std::is_pointer_v<std::remove_cvref_t<decltype(t)>>) {
        asm volatile("" :: "g"(t) : "memory");
      } else {
        #if defined(__clang__)
        asm volatile("" :: "r,m"(t) : "memory");
        #else
        asm volatile("" :: "m,r"(t) : "memory");
        #endif
      }
      return (t);
    };

    /**
     * returns true if function is elided by the compiler, false otherwise
     */
    template<auto Begin = +[]{}, auto End = +[]{}>
    [[nodiscard]] inline constexpr auto is_elided(auto&& fn) -> bool {
      const auto invoke = [&] {
        code::label<Begin>();
        fn();
        code::label<End>();
      };
      const auto ptr = &decltype(invoke)::operator();
      prevent_elision(&ptr);
      return code::labels[Begin] == code::labels[End];
    }
    #endif // PERF_GNU
  } // namespace compiler

  namespace cpu {
    #if PERF_GNU == 1 and defined(__x86_64__)
    namespace pipeline {
      inline constexpr auto flush = [] {
        asm volatile("cpuid" : : "a"(0), "c"(0) : "ebx", "edx", "memory");
      };
    } // namespace pipeline

    inline constexpr auto msr = overload{
      [](const std::uint64_t value) {
        std::uint64_t edx{}, eax{};
        asm volatile(
          "rdmsr" : "=d"(edx), "=a"(eax) : "c"(value)
        );
        return ((static_cast<std::uint64_t>(edx)) << 32u) | static_cast<std::uint64_t>(eax);
      },
      [](const std::uint32_t msr, const std::uint64_t value) {
        const std::uint32_t low = value & 0xFFFFFFFF;
        const std::uint32_t high = value >> 32u;
        asm volatile(
          "wrmsr" :: "c" (msr), "a" (low), "d" (high)
        );
      }
    };

    inline constexpr auto rdpmc = [](const std::uint64_t id) {
      std::uint64_t eax{}, edx{};
        asm volatile(
          "rdpmc" : "=a"(eax), "=d"(edx) : "c"(id)
        );
        return ((static_cast<std::uint64_t>(edx)) << 32u) | static_cast<std::uint64_t>(eax);
    };
    #endif // PERF_GNU and __x86_64__
  } // namespace cpu

  namespace memory {
    enum class direction {
      up,   /// rounds the address up to the nearest multiple of the alignment
      down, /// rounds the address down to the nearest multiple of the alignment
    };

    /**
     * aligns given pointer to specific alignment and offset
     */
    template<enum direction Direction>
    inline constexpr auto align =
      []<class T>(T* addr, const std::align_val_t alignment) {
        verify(std::has_single_bit(std::size_t(alignment)));
        if constexpr (Direction == direction::up) {
          #if __has_builtin(__builtin_align_up)
          return __builtin_align_up(addr, std::size_t(alignment));
          #else
          const auto original = reinterpret_cast<std::uintptr_t>(addr);
          const auto aligned = (original + std::size_t(alignment) - 1u) & ~(std::size_t(alignment) - 1u);
          return reinterpret_cast<T*>(aligned);
          #endif // __builtin_align_up
        } else if constexpr (Direction == direction::down) {
          #if __has_builtin(__builtin_align_down)
          return __builtin_align_down(addr, std::size_t(alignment));
          #else
          const auto original = reinterpret_cast<std::uintptr_t>(addr);
          const auto aligned = original & ~(std::size_t(alignment) - 1u);
          return reinterpret_cast<T*>(aligned);
          #endif // __builtin_align_down
        }
      };

    /**
     * returns true if pointer is aligned to specified alignment
     */
    inline constexpr auto is_aligned =
      [](const auto* addr, const std::align_val_t alignment = std::align_val_t(alignof(std::max_align_t))) -> bool {
        verify(std::has_single_bit(std::size_t(alignment)));
        #if __has_builtin(__builtin_is_aligned)
        return __builtin_is_aligned(addr, std::size_t(alignment));
        #else
        return not (reinterpret_cast<std::uintptr_t>(addr) & (std::size_t(alignment) - 1u));
        #endif // __builtin_is_aligned
      };

    /**
     * hardware memory barrier (x86: fence or lock)
     */
    inline constexpr auto synchronize(const std::memory_order memory_order) {
      std::atomic_thread_fence(memory_order);
    }

    /**
     * forces hardware memory barrier instruction (x86: mfence, sfence, lfence)
     */
    #if PERF_GNU == 1 and defined(__x86_64__)
    template<std::memory_order MemoryOrder>
    inline constexpr auto synchronize() {
      if constexpr (MemoryOrder == std::memory_order_acquire) {
        asm volatile("lfence" ::: "memory");
      } else if constexpr (MemoryOrder == std::memory_order_release) {
        asm volatile("sfence" ::: "memory");
      } else if constexpr (MemoryOrder == std::memory_order_acq_rel or
          MemoryOrder == std::memory_order_seq_cst) {
        asm volatile("mfence" ::: "memory");
      }
    }
    #endif // PERF_GNU and __x86_64__

    /**
     * https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html
     */
    #if __has_builtin(__builtin_prefetch)
    enum class operation {
      read,   /// prepare the prefetch for a read
      write,  /// prepare the prefetch for a write to the memory
    };

    enum class locality {
      none,     /// streaming access
      low,      /// L3 cache, leave the data in the L3 cache level after the access
      moderate, /// L2 cache, leave the data in L2 and L3 cache levels after the access
      high,     /// L1 cache, leave the data in the L1, L2, and L3 cache levels after the access
    };

    /**
     * prefetches memory from address
     */
    template<enum operation Operation, enum locality Locality>
    inline constexpr auto prefetch = [](const auto* addr) {
      __builtin_prefetch(
        addr,
        static_cast<std::underlying_type_t<enum operation>>(Operation),
        static_cast<std::underlying_type_t<enum locality>>(Locality)
      );
    };
    #endif

    #if PERF_LINUX == 1
    enum class protection {
      read  = PROT_READ,
      write = PROT_WRITE,
      exec  = PROT_EXEC,
    };

    inline constexpr protection operator|(const protection lhs, const protection rhs) {
      return static_cast<protection>(
        static_cast<std::underlying_type_t<protection>>(lhs) |
        static_cast<std::underlying_type_t<protection>>(rhs)
      );
    }

    /**
     * sets protection on a region of memory
     */
    inline constexpr auto protect = [](std::span<const std::byte> data, const enum protection protection) {
      const auto page_size = info::sys::page_size();
      const auto offset = std::uint64_t(data.data()) % page_size;
      const auto addr = std::uint64_t(data.data()) - offset;
      return not mprotect(
        reinterpret_cast<void*>(addr),
        (((data.size() + offset) - 1u) / page_size + 1u) * page_size,
        static_cast<std::underlying_type_t<enum protection>>(protection)
      );
    };

    /**
     * scoped lock for all currently mapped pages
     */
    using lock = scoped<
      decltype([] {
        /**
         * MLC_CURRENT Lock all pages which are currently mapped into the address space of the process
         * MCL_FUTURE Lock all pages which will become mapped into the address space of the process in the future
         */
        verify(not mlockall(MCL_CURRENT | MCL_FUTURE));
      }),
      decltype([] {
        verify(not munlockall());
      })
    >;

    inline constexpr auto pre_fault =
      [](std::span<std::byte> data, const std::size_t page_size = info::sys::page_size()) {
        for (auto i = 0u; i < data.size(); i += page_size) {
          data[i] = {};
        }
      };
    #endif // PERF_LINUX

    /**
     * pollutes memory by making allocations
     */
    template<class T = std::size_t, class TAllocator = std::allocator<T>>
    inline constexpr auto pollute(const std::size_t size)
      requires (requires { T{}; } or requires { T(size); }) {
      verify(size > 0u);
      std::list<T, TAllocator> data{};
      auto n = size;
      while (n--) {
        if constexpr (requires { T(n); }) {
          data.push_back(T(n));
        } else {
          data.push_back(T{});
        }
      }
    }

    namespace cache {
      inline constexpr auto flush = [](std::span<const std::byte> data) {
        const auto size = data.size();
        const auto cache_line_size = info::memory::dcache()[info::memory::level::L1].line_size;
        const auto ptr = std::bit_cast<std::uintptr_t>(data.begin());
        const auto aligned_start = ptr & ~(cache_line_size - 1u);
        const auto aligned_end = (ptr + size + cache_line_size - 1u) & ~(cache_line_size - 1u);
        const auto aligned_size = aligned_end - aligned_start;

        #if PERF_GNU == 1 and defined(__x86_64__)
        for (auto i = 0u; i < aligned_size; i += cache_line_size) {
          asm volatile("clflush (%0)" :: "r"(reinterpret_cast<const void*>(aligned_start + i)));
        }
        #elif __has_builtin(__builtin___clear_cache)
        __builtin___clear_cache(
          reinterpret_cast<const std::byte*>(aligned_start),
          reinterpret_cast<const std::byte*>(aligned_start + aligned_size)
        );
        #endif
        memory::synchronize<std::memory_order_seq_cst>();
      };

      #if PERF_UEFI == 1 and PERF_GNU == 1
      inline constexpr auto enable = [] {
        std::uint64_t cr0{};
        asm volatile (
          "mov %%cr0, %0"
          "and $~0x60000000, %0"
          "mov %0, %%cr0"
          : "=r"(cr0) : : "memory"
        );
      };

      inline constexpr auto disable = [] {
        std::uint64_t cr0{};
        asm volatile(
          "mov %%cr0, %0"
          "or $0x60000000, %0"
          "mov %0, %%cr0"
          : "=r"(cr0) : : "memory"
        );
      };

      inline constexpr auto invalidate = [] {
        asm volatile("wbinvd" ::: "memory");
      };
      #endif // PERF_UEFI and PERF_GNU
    } // namespace cache
  } // namespace memory

  inline namespace sys {
    namespace thread {
      #if PERF_LINUX == 1
      namespace affinity {
        /**
         * set thread affinity
         */
        inline constexpr auto set =
          [](const std::thread::native_handle_type thread, const std::ranges::range auto& affinities) {
            cpu_set_t cpuset{};
            CPU_ZERO(&cpuset);
            for (const auto affinity : affinities) {
              CPU_SET(affinity, &cpuset);
            }
            return not pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset);
          };

        /**
         * eeturns thread affinity
         */
        inline constexpr auto get = [](const std::thread::native_handle_type thread) {
          std::vector<std::size_t> affinities{};
          cpu_set_t cpuset{};
          CPU_ZERO(&cpuset);
          if (pthread_getaffinity_np(thread, sizeof(cpuset), &cpuset)) {
            return affinities;
          }
          for (auto i = 0u; i < CPU_SETSIZE; ++i) {
            if (CPU_ISSET(i, &cpuset)) {
              affinities.push_back(i);
            }
          }
          return affinities;
        };
      } // namespace affinity

      namespace priority {
        inline constexpr auto set = [] {};
        inline constexpr auto get = [] {};
      } // namespace priority

      inline const std::thread::native_handle_type self = pthread_self();
      #endif // PERF_LINUX
    } // namespace thread

    #if PERF_UEFI == 1
    struct uefi {
      struct {
        std::uint64_t signature{};
        std::uint32_t revision{};
        std::uint32_t size{};
        std::uint32_t crc32{};
        std::uint32_t reserved{};
      } header{};
      std::int16_t* vendor{};
      std::uint32_t revision{};

      struct {
        void* handle{};
        std::uint64_t id{};
      } stdin{};

      struct {
        void* handle{};
        struct out {
          std::uint64_t reset{};
          std::uint64_t (*data)(out*, std::int16_t*){};
          std::uint64_t test{};
          std::uint64_t query_mode{};
          std::uint64_t set_mode{};
          std::uint64_t attribute{};
          std::uint64_t clear{};
          std::uint64_t position{};
          std::uint64_t cursor{};
          std::uint64_t mode{};
        };
        out* out{};
      } stdout{};

      struct {
        void* handle{};
        std::uint64_t id{};
      } stderr{};

      struct {
        std::uint64_t runtime{};
        std::uint64_t boot{};
        std::uint64_t size{};
        std::uint64_t config{};
      } info{};
    };
    #endif // PERF_UEFI
  } // namespace sys
} // namespace core

/**
 * low level
 * - https://github.com/llvm/llvm-project
 */
inline namespace backend {
  template<class T>
  concept mc_like = requires (const typename T::value_type& data) {
    data.ip; /// instruction pointer
  };

  #if PERF_LLVM == 1
  /**
   * llc -march=x86 -mcpu=help
   */
  struct arch {
    /// x86_64-pc-linux-gnu, arm-none-eabi, aarch64-unknown-linux-gnu, ...
    std::string triple = ::llvm::Triple::normalize(::llvm::sys::getDefaultTargetTriple());

    /// alderlake, westmere, btver2, ...
    std::string cpu = ::llvm::sys::getHostCPUName().str();

    /// +bmi2, -avx2, +avx512, ... # default: available features of the current cpu
    std::string features{};

    /// att: 'movl %eax, %ebx', intel: 'mov ebx, eax' # default: intel
    enum class syntax { att, intel } syntax = syntax::intel;

    /// overrides processor dispatch width
    std::size_t dispatch_width{};

    /// overrdies number of entries in the micro-op queue
    std::size_t micro_op_queue{};

    /// overrdies maximum throughput from the decoders (instructions per cycle)
    std::size_t decoder_throughput{};

    /// overrides maximum number of physical registers which can be used for register mappings
    std::size_t register_file_size{};

    /// overrides size of the load queue
    std::size_t load_queue_size{};

    /// overrides size of the store queue
    std::size_t store_queue_size{};

    /// loads and stores do/do not alias # default: no alias
    bool assume_no_alias = true;
  };

  struct region {
    std::uint64_t begin{};
    std::uint64_t end{};
  };

  template<class... Ts>
    requires (mc_like<Ts> and ...)
  class analyzer {
    struct instruction {
      std::uint64_t opcode{}; /// instruction opcode
      std::uint64_t ip{};     /// instruction pointer
      std::uint64_t size{};   /// size [bytes]
    };

   public:
    template<class TArch = arch>
      requires requires (TArch arch) {
        arch.triple;
        arch.cpu;
        arch.features;
        arch.syntax;
      }
    constexpr explicit analyzer(const TArch& arch, const Ts&... ts)
      : llvm_{arch}, ts_{ts...}
    { }

    constexpr explicit analyzer(const Ts&... ts)
      : analyzer{{}, ts...}
    { }

    constexpr decltype(auto) operator<<(const auto& region) {
      auto&& instructions = disassemble(region);
      instructions_.insert(instructions_.end(), instructions.begin(), instructions.end());
      return *this;
    }

    constexpr decltype(auto) operator<<(const std::ranges::range auto& instructions)
      requires requires (std::size_t i) { instructions[i].ip; instructions[i].size; } {
      instructions_.reserve(instructions_.size() + instructions.size());
      for (const auto& instruction : instructions) {
        instructions_.push_back({
          .opcode = disassemble(region{instruction.ip, instruction.ip + instruction.size})[0u].opcode,
          .ip = instruction.ip,
          .size = instruction.size
        });
      }
      return *this;
    }

    template<class... TUs>
    [[nodiscard]] constexpr auto operator[](const TUs&... tus) const {
      const auto make = [&]<class T>(const T& t) {
        if constexpr (requires { t(instructions_[0u], llvm_); }) {
          std::vector<decltype(t(instructions_[0u], llvm_))> v(instructions_.size());
          for (auto i = 0u; i < v.size(); ++i) {
            v[i] = std::move(t(instructions_[i], llvm_));
          }
          return v;
        } else if constexpr (requires { t(instructions_, llvm_); }) {
          return t(instructions_, llvm_);
        }
      };

      return std::tuple{make_fixed_named<TUs::name()>(make(tus))...};
    }

    [[nodiscard]] constexpr auto operator[]() const {
      return this->operator[](Ts{}...);
    }

   private:
    [[nodiscard]] inline constexpr auto disassemble(const auto& region) {
      verify(region.end >= region.begin);

      ::llvm::ArrayRef<std::uint8_t> bytes{
        reinterpret_cast<const std::uint8_t*>(region.begin),
        std::size_t(region.end - region.begin)
      };
      std::vector<instruction> instructions{};
      instructions.reserve(region.end - region.begin);

      auto ip = region.begin;
      while (ip < region.end) {
        ::llvm::MCInst inst{};
        std::size_t size{};
        verify(llvm_.disassembler->getInstruction(
          inst,
          size,
          bytes.slice(ip - region.begin),
          ip,
          ::llvm::nulls()
        ) == ::llvm::MCDisassembler::DecodeStatus::Success);

        instructions.push_back({
          .opcode = inst.getOpcode(),
          .ip = ip,
          .size = size,
        });
        ip += size;
      }
      return instructions;
    }

    template<class TArch>
    struct llvm {
      constexpr explicit llvm(const TArch& arch = {})
        : arch{arch} {
        if (::llvm::TargetRegistry::targets().empty()) {
          ::llvm::InitializeAllTargetInfos();
          ::llvm::InitializeAllTargetMCs();
          ::llvm::InitializeAllAsmParsers();
          ::llvm::InitializeAllDisassemblers();
          ::llvm::InitializeAllTargetMCAs();
        }

        auto&& [target, options] = [&] {
          ::llvm::MCTargetOptions options{};
          std::string error{};
          const auto target = ::llvm::TargetRegistry::lookupTarget(
            ::llvm::Triple(arch.triple).getTriple(),
            error
          );
          verify(bool(target), error);
          return std::pair{target, options};
        }();

        register_info = std::unique_ptr<::llvm::MCRegisterInfo>(target->createMCRegInfo(::llvm::Triple(arch.triple).getTriple()));
        assembler_info = std::unique_ptr<::llvm::MCAsmInfo>(target->createMCAsmInfo(*register_info, ::llvm::Triple(arch.triple).getTriple(), options));
        instruction_info = std::unique_ptr<::llvm::MCInstrInfo>(target->createMCInstrInfo());
        subtarget_info = std::unique_ptr<::llvm::MCSubtargetInfo>(target->createMCSubtargetInfo(::llvm::Triple(arch.triple).getTriple(), arch.cpu, arch.features));
        instrument_manager = std::make_unique<::llvm::mca::InstrumentManager>(*subtarget_info, *instruction_info);
        instruction_analysis = std::unique_ptr<::llvm::MCInstrAnalysis>(target->createMCInstrAnalysis(instruction_info.get()));
        instruction_builder = [&]<class T = ::llvm::mca::InstrBuilder> {
          if constexpr (requires { T(*subtarget_info, *instruction_info, *register_info, instruction_analysis.get(), *instrument_manager, 0u); }) {
            return std::make_unique<T>(*subtarget_info, *instruction_info, *register_info, instruction_analysis.get(), *instrument_manager, 0u);
          } else {
            return std::make_unique<T>(*subtarget_info, *instruction_info, *register_info, instruction_analysis.get(), *instrument_manager);
          }
        }();
        instruction_printer = std::unique_ptr<::llvm::MCInstPrinter>(
          target->createMCInstPrinter(::llvm::Triple(arch.triple), std::size_t(arch.syntax), *assembler_info, *instruction_info, *register_info)
        );
        instruction_printer->setPrintImmHex(true);
        context = std::make_unique<::llvm::MCContext>(
          ::llvm::Triple(arch.triple), assembler_info.get(), register_info.get(), subtarget_info.get(), nullptr, &options
        );
        disassembler = std::unique_ptr<::llvm::MCDisassembler>(target->createMCDisassembler(*subtarget_info, *context));
      }

      TArch arch{};
      std::unique_ptr<::llvm::MCRegisterInfo> register_info{};
      std::unique_ptr<::llvm::MCAsmInfo> assembler_info{};
      std::unique_ptr<::llvm::MCInstrInfo> instruction_info{};
      std::unique_ptr<::llvm::MCSubtargetInfo> subtarget_info{};
      std::unique_ptr<::llvm::mca::InstrumentManager> instrument_manager{};
      std::unique_ptr<::llvm::MCInstrAnalysis> instruction_analysis{};
      std::unique_ptr<::llvm::mca::InstrBuilder> instruction_builder{};
      std::unique_ptr<::llvm::MCInstPrinter> instruction_printer{};
      std::unique_ptr<::llvm::MCContext> context{};
      std::unique_ptr<::llvm::MCDisassembler> disassembler{};
    };

    llvm<arch> llvm_{};
    std::vector<instruction> instructions_{};
    std::tuple<Ts...> ts_{};
  };

  template<>
  class analyzer<> {
   public:
    constexpr explicit analyzer(auto&&...) { }
    constexpr decltype(auto) operator<<(auto&&) {
      return *this;
    }
    [[nodiscard]] constexpr auto operator[](auto...) const {
      return std::tuple{};
    }
  };

  /**
   * machine code analyzer
   * - https://llvm.org/docs/CommandGuide/llvm-mca.html
   */
  namespace mca {
    namespace stat {
      struct cycles {
        using value_type = strong_alias<double>;

        std::size_t iterations = 1u; /// number of iterations to simulate

        [[nodiscard]] constexpr auto operator()(const std::ranges::range auto& instructions, auto& llvm) const {
          std::vector<std::unique_ptr<::llvm::mca::Instruction>> lowered_sequence{};
          const ::llvm::SmallVector<::llvm::mca::Instrument*> instruments{};
          for (const auto& instruction : instructions) {
            ::llvm::MCInst inst{};
            std::size_t size{};
            verify(llvm.disassembler->getInstruction(
              inst,
              size,
              ::llvm::ArrayRef<std::uint8_t>{
                reinterpret_cast<const std::uint8_t*>(instruction.ip),
                reinterpret_cast<const std::uint8_t*>(instruction.ip) + instruction.size
              },
              instruction.ip,
              ::llvm::nulls()
            ) == ::llvm::MCDisassembler::DecodeStatus::Success);
            lowered_sequence.emplace_back(
              std::move(llvm.instruction_builder->createInstruction(inst, instruments).get())
            );
          }

          if (lowered_sequence.empty()) {
            return value_type{};
          }

          ::llvm::mca::CircularSourceMgr mgr(lowered_sequence, iterations);
          ::llvm::mca::CustomBehaviour custom_behavior{*llvm.subtarget_info, mgr, *llvm.instruction_info};
          ::llvm::mca::PipelineOptions options(
            llvm.arch.micro_op_queue,
            llvm.arch.decoder_throughput,
            llvm.arch.dispatch_width,
            llvm.arch.register_file_size,
            llvm.arch.load_queue_size,
            llvm.arch.store_queue_size,
            llvm.arch.assume_no_alias
          );
          ::llvm::mca::Context mca{*llvm.register_info, *llvm.subtarget_info};
          auto pipeline = mca.createDefaultPipeline(options, mgr, custom_behavior);

          value_type cycles{};
          handler handler{cycles.value};

          pipeline->addEventListener(std::addressof(handler));
          verify(bool(pipeline->run()));

          return cycles;
        }

       private:
        template<class T>
        struct handler : ::llvm::mca::View {
          constexpr explicit handler(T& cycles)
            : cycles_{cycles}
          { }

          //todo
          //constexpr void onEvent(const ::llvm::mca::HWInstructionEvent& event) override {
            //if (event.Type != ::llvm::mca::HWInstructionEvent::Retired or
                //event.IR.getSourceIndex() >= Source.size()) {
              //return;
            //}
            //uops += *event.IR.getInstruction().getDesc().NumMicroOps;
          //}

          constexpr void onCycleEnd() override { ++cycles_; }

          ::llvm::StringRef getNameAsString() const override { return {}; }
          void printView(::llvm::raw_ostream&) const override { }

         private:
          T& cycles_;
        };
      };

      //todo
      inline constexpr auto cycles = fixed_named<"mca.cycles", struct cycles>{};
      inline constexpr auto instructions = fixed_named<"mca.instructions", struct cycles>{};
      inline constexpr auto uops = fixed_named<"mca.uops", struct cycles>{};
    } // namespace stat

    struct assembly {
      using value_type = struct info {
        std::uint64_t ip{};
        std::string text{};
        enum arch::syntax syntax{};
      };

      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.opcode; instruction.ip; instruction.size; } {
        ::llvm::MCInst inst{};
        std::size_t size{};
        verify(llvm.disassembler->getInstruction(
          inst,
          size,
          ::llvm::ArrayRef<std::uint8_t>{
            reinterpret_cast<const std::uint8_t*>(instruction.ip),
            reinterpret_cast<const std::uint8_t*>(instruction.ip) + instruction.size
          },
          instruction.ip,
          ::llvm::nulls()
        ) == ::llvm::MCDisassembler::DecodeStatus::Success);

        std::string text{};
        ::llvm::raw_string_ostream stream{text};
        llvm.instruction_printer->printInst(
          &inst, instruction.ip, {}, *llvm.subtarget_info, stream
        );

        const auto& mc = llvm.instruction_info->get(instruction.opcode);

        if (mc.isCall()) {
          for (auto i = 0u; i < inst.getNumOperands(); ++i) {
            const auto &Op = inst.getOperand(i);
            if (Op.isImm()) {
              const auto TargetAddr = Op.getImm();
              const auto& name = perf::info::bin::addr_to_fn_name(
                perf::info::proc::self::name(),
                instruction.ip - perf::info::proc::self::base_address() + TargetAddr + instruction.size
              );
              text += std::format(" <{}>", *name);
            }
          }
        }

        return {instruction.ip, text, llvm.arch.syntax};
      }
    };

    struct address {
      using value_type = struct info {
        std::uint64_t ip{};
        std::uint64_t size{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto&&...) const -> value_type
        requires requires { instruction.ip; instruction.size; } {
        return {instruction.ip, instruction.size};
      }
    };

    struct encoding {
      using value_type = struct info {
        std::uint64_t ip{};
        std::uint64_t size{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto&&...) const -> value_type
        requires requires { instruction.ip; instruction.size; } {
        return {instruction.ip, instruction.size};
      }
    };

    struct size {
      using value_type = struct info {
        std::uint64_t ip{};
        std::uint64_t size{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto&&...) const -> value_type
        requires requires { instruction.ip; instruction.size; } {
        return {instruction.ip, instruction.size};
      }
    };

    struct uops {
      using value_type = struct info {
        std::uint64_t ip{};
        std::uint64_t value{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.ip; instruction.opcode; } {
        const auto& mc = llvm.instruction_info->get(instruction.opcode);
        const auto& sc = mc.getSchedClass();
        const auto& desc = *llvm.subtarget_info->getSchedModel().getSchedClassDesc(sc);
        return {instruction.ip, desc.NumMicroOps};
      }
    };

    struct latency {
      using value_type = struct info {
        std::uint64_t ip{};
        std::uint64_t value{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.ip; instruction.opcode; } {
        const auto& mc = llvm.instruction_info->get(instruction.opcode);
        const auto& sc = mc.getSchedClass();
        const auto& desc = *llvm.subtarget_info->getSchedModel().getSchedClassDesc(sc);
        return {
          instruction.ip,
          ::llvm::MCSchedModel::computeInstrLatency(*llvm.subtarget_info, desc) +
          ::llvm::MCSchedModel::getForwardingDelayCycles(llvm.subtarget_info->getReadAdvanceEntries(desc))
        };
      }
    };

    struct rthroughput {
      using value_type = struct info {
        std::uint64_t ip{};
        double value{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.ip; instruction.opcode; } {
        const auto& mc = llvm.instruction_info->get(instruction.opcode);
        const auto& sc = mc.getSchedClass();
        const auto& desc = *llvm.subtarget_info->getSchedModel().getSchedClassDesc(sc);
        return {instruction.ip, ::llvm::MCSchedModel::getReciprocalThroughput(*llvm.subtarget_info, desc)};
      }
    };

    struct may_load {
      using value_type = struct info {
        std::uint64_t ip{};
        bool value{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.ip; instruction.opcode; } {
        return {instruction.ip, llvm.instruction_info->get(instruction.opcode).mayLoad()};
      }
    };

    struct may_store {
      using value_type = struct info {
        std::uint64_t ip{};
        bool value{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.ip; instruction.opcode; } {
        return {instruction.ip, llvm.instruction_info->get(instruction.opcode).mayStore()};
      }
    };

    struct has_side_effects {
      using value_type = struct info {
        std::uint64_t ip{};
        bool value{};
      };
      [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
        requires requires { instruction.ip; instruction.opcode; } {
        return {instruction.ip, llvm.instruction_info->get(instruction.opcode).hasUnmodeledSideEffects()};
      }
    };

    inline constexpr auto assembly = fixed_named<"mca.assembly", struct assembly>{};
    inline constexpr auto address = fixed_named<"mca.address", struct address>{};
    inline constexpr auto encoding = fixed_named<"mca.encoding", struct encoding>{};
    inline constexpr auto size = fixed_named<"mca.size", struct size>{};
    inline constexpr auto uops = fixed_named<"mca.uops", struct uops>{};
    inline constexpr auto latency = fixed_named<"mca.latency", struct latency>{};
    inline constexpr auto rthroughput = fixed_named<"mca.rthroughput", struct rthroughput>{};
    inline constexpr auto may_load = fixed_named<"mca.may_load", struct may_load>{};
    inline constexpr auto may_store = fixed_named<"mca.may_store", struct may_store>{};
    inline constexpr auto has_side_effects = fixed_named<"mca.has_side_effects", struct has_side_effects>{};

    namespace branch {
      struct is_conditional {
        using value_type = struct info {
          std::uint64_t ip{};
          bool value{};
        };
        [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
          requires requires { instruction.ip; instruction.opcode; } {
          const auto& mc = llvm.instruction_info->get(instruction.opcode);
          return {instruction.ip, mc.isConditionalBranch()};
        }
      };

      struct is_unconditional {
        using value_type = struct info {
          std::uint64_t ip{};
          bool value{};
        };
        [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
          requires requires { instruction.ip; instruction.opcode; } {
          const auto& mc = llvm.instruction_info->get(instruction.opcode);
          return {instruction.ip, mc.isUnconditionalBranch()};
        }
      };

      struct is_indirect {
        using value_type = struct info {
          std::uint64_t ip{};
          bool value{};
        };
        [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
          requires requires { instruction.ip; instruction.opcode; } {
          const auto& mc = llvm.instruction_info->get(instruction.opcode);
          return {instruction.ip, mc.isIndirectBranch()};
        }
      };

      struct is_call {
        using value_type = struct info {
          std::uint64_t ip{};
          bool value{};
        };
        [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
          requires requires { instruction.ip; instruction.opcode; } {
          const auto& mc = llvm.instruction_info->get(instruction.opcode);
          return {instruction.ip, mc.isCall()};
        }
      };

      struct is_ret {
        using value_type = struct info {
          std::uint64_t ip{};
          bool value{};
        };
        [[nodiscard]] constexpr auto operator()(const auto& instruction, auto& llvm) const -> value_type
          requires requires { instruction.ip; instruction.opcode; } {
          const auto& mc = llvm.instruction_info->get(instruction.opcode);
          return {instruction.ip, mc.isReturn()};
        }
      };

      inline constexpr auto is_conditional = fixed_named<"mc.branch.is_conditional", struct branch::is_conditional>{};
      inline constexpr auto is_unconditional = fixed_named<"mc.branch.is_unconditional", struct branch::is_unconditional>{};
      inline constexpr auto is_indirect = fixed_named<"mc.branch.is_indirect", struct branch::is_indirect>{};
      inline constexpr auto is_call = fixed_named<"mc.branch.is_call", struct branch::is_call>{};
      inline constexpr auto is_ret = fixed_named<"mc.branch.is_ret", struct branch::is_ret>{};
    } // namespace branch

    /**
     * produces a detailed report of each instructions state transitions through an instruction pipeline
     * - https://github.com/llvm/llvm-project/tree/main/llvm/tools/llvm-mca
     * - https://llvm.org/docs/CommandGuide/llvm-mca.html
     *
     * this class is derived from llvm project
     * - https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-mca/Views/TimelineView.h
     * - https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-mca/Views/TimelineView.cpp
     *
     * modifcations
     * - split business logic and view logic
     * - used dispatch_width instead of hardcoded 5 in timeline view
     * - applied api changes required for integration with the library
     * - applied C++20 changes and formatting
     */
    struct timeline {
      using value_type = struct info {
        std::uint64_t ip{};
        std::optional<std::size_t> cycle_dispatched{};
        std::size_t cycle_ready{};
        std::size_t cycle_issued{};
        std::size_t cycle_executed{};
        std::size_t cycle_retired{};
        std::size_t dispatch_width{};
        std::size_t cycles{};
      };

      std::size_t iterations = 1u; /// number of iterations to simulate

      [[nodiscard]] constexpr auto operator()(const std::ranges::range auto& instructions, auto& llvm) const
        requires requires (std::size_t i) { instructions[i].ip; instructions[i].size; } {
        std::vector<std::unique_ptr<::llvm::mca::Instruction>> lowered_sequence{};
        const ::llvm::SmallVector<::llvm::mca::Instrument*> instruments{};
        for (const auto& instruction : instructions) {
          ::llvm::MCInst inst{};
          std::size_t size{};
          verify(llvm.disassembler->getInstruction(
            inst,
            size,
            ::llvm::ArrayRef<std::uint8_t>{
              reinterpret_cast<const std::uint8_t*>(instruction.ip),
              reinterpret_cast<const std::uint8_t*>(instruction.ip) + instruction.size
            },
            instruction.ip,
            ::llvm::nulls()
          ) == ::llvm::MCDisassembler::DecodeStatus::Success);
          lowered_sequence.emplace_back(
            std::move(llvm.instruction_builder->createInstruction(inst, instruments).get())
          );
        }

        if (lowered_sequence.empty()) {
          return std::vector<info>{};
        }

        ::llvm::mca::CircularSourceMgr mgr(lowered_sequence, iterations);
        ::llvm::mca::CustomBehaviour custom_behavior{*llvm.subtarget_info, mgr, *llvm.instruction_info};
        ::llvm::mca::PipelineOptions options(
          llvm.arch.micro_op_queue,
          llvm.arch.decoder_throughput,
          llvm.arch.dispatch_width,
          llvm.arch.register_file_size,
          llvm.arch.load_queue_size,
          llvm.arch.store_queue_size,
          llvm.arch.assume_no_alias
        );
        ::llvm::mca::Context mca{*llvm.register_info, *llvm.subtarget_info};
        auto pipeline = mca.createDefaultPipeline(options, mgr, custom_behavior);

        const auto dispatch_width = perf::info::cpu::dispatch_width(llvm);
        std::vector v(lowered_sequence.size() * iterations, info{.dispatch_width = dispatch_width});

        std::size_t cycles{};
        handler handler{v, cycles};

        pipeline->addEventListener(std::addressof(handler));
        verify(bool(pipeline->run()));

        for (auto i = 0u; i < v.size(); ++i) {
          v[i].ip = instructions[i].ip;
          v[i].cycles = cycles;
        }

        return v;
      }

     private:
      struct handler : ::llvm::mca::View {
        constexpr handler(auto& timeline, auto& cycles)
          : timeline_{timeline}, cycles_{cycles}
        { }

        constexpr void onEvent(const ::llvm::mca::HWInstructionEvent& event) override {
          const auto index = event.IR.getSourceIndex();
          if (index >= timeline_.size()) {
            return;
          }

          switch (event.Type) {
            case ::llvm::mca::HWInstructionEvent::Retired: {
              auto &entry = timeline_[index];
              entry.cycle_retired = cycles_;
              verify(entry.cycle_dispatched.has_value());
              verify(*entry.cycle_dispatched <= entry.cycle_ready);
              break;
            }

            case ::llvm::mca::HWInstructionEvent::Ready: {
              timeline_[index].cycle_ready = cycles_;
              break;
            }

            case ::llvm::mca::HWInstructionEvent::Issued: {
              timeline_[index].cycle_issued = cycles_;
              break;
            }

            case ::llvm::mca::HWInstructionEvent::Executed: {
              timeline_[index].cycle_executed = cycles_;
              break;
            }

            case ::llvm::mca::HWInstructionEvent::Dispatched: {
              if (not timeline_[index].cycle_dispatched) {
                timeline_[index].cycle_dispatched = cycles_;
              }
              break;
            }
          }
        }

        constexpr void onCycleEnd() override { ++cycles_; }

        ::llvm::StringRef getNameAsString() const override { return {}; }
        void printView(::llvm::raw_ostream&) const override { }

       private:
        std::vector<info>& timeline_;
        std::size_t& cycles_;
      };
    };

    /**
     * reports the average number of resource cycles consumed every iteration by instructions for every
     * processor resource unit available on the target
     * - https://github.com/llvm/llvm-project/tree/main/llvm/tools/llvm-mca
     * - https://llvm.org/docs/CommandGuide/llvm-mca.html
     *
     * this class is derived from llvm project
     * - https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-mca/Views/ResourcePressureView.h
     * - https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-mca/Views/ResourcePressureView.cpp
     *
     * modifcations made by Kris Jusiak in 2025
     * - split business logic and view logic
     * - applied api changes required for integration with the library
     * - applied C++20 changes and formatting
     */
    struct resource_pressure {
      using value_type = struct info {
        std::uint64_t ip{};
        struct unit {
          std::string name{};
          double pressure{};
        };
        std::vector<unit> units{};
      };

      std::size_t iterations = 100u; /// number of iterations to simulate

      [[nodiscard]] constexpr auto operator()(const std::ranges::range auto& instructions, auto& llvm) const
        requires requires (std::size_t i) { instructions[i].ip; instructions[i].size; } {
        std::vector<std::unique_ptr<::llvm::mca::Instruction>> lowered_sequence{};
        const ::llvm::SmallVector<::llvm::mca::Instrument*> instruments{};

        for (const auto& instruction : instructions) {
          ::llvm::MCInst inst{};
          std::size_t size{};
          verify(llvm.disassembler->getInstruction(
            inst,
            size,
            ::llvm::ArrayRef<std::uint8_t>{
              reinterpret_cast<const std::uint8_t*>(instruction.ip),
              reinterpret_cast<const std::uint8_t*>(instruction.ip) + instruction.size
            },
            instruction.ip,
            ::llvm::nulls()
          ) == ::llvm::MCDisassembler::DecodeStatus::Success);
          lowered_sequence.emplace_back(
            std::move(llvm.instruction_builder->createInstruction(inst, instruments).get())
          );
        }

        ::llvm::mca::CircularSourceMgr mgr(lowered_sequence, iterations);
        ::llvm::mca::CustomBehaviour custom_behavior{*llvm.subtarget_info, mgr, *llvm.instruction_info};
        ::llvm::mca::PipelineOptions options(
          llvm.arch.micro_op_queue,
          llvm.arch.decoder_throughput,
          llvm.arch.dispatch_width,
          llvm.arch.register_file_size,
          llvm.arch.load_queue_size,
          llvm.arch.store_queue_size,
          llvm.arch.assume_no_alias,
          false /// disable bottleneck analysis
        );
        ::llvm::mca::Context mca{*llvm.register_info, *llvm.subtarget_info};
        auto pipeline = mca.createDefaultPipeline(options, mgr, custom_behavior);

        std::vector<::llvm::mca::ReleaseAtCycles> res_usage{};
        std::size_t id{};
        handler handler{llvm.subtarget_info->getSchedModel(), res_usage, id, instructions.size()};

        pipeline->addEventListener(std::addressof(handler));
        verify(bool(pipeline->run()));

        std::vector<::llvm::MCProcResourceDesc> units{};
        const auto &sm = llvm.subtarget_info->getSchedModel();
        for (auto i = 1u; i < sm.getNumProcResourceKinds(); ++i) {
          const auto& resource = *sm.getProcResource(i);
          if (resource.SubUnitsIdxBegin or not resource.NumUnits) {
            continue;
          }
          units.push_back(resource);
        }

        const auto executions = id / instructions.size() + 1u;

        std::vector<info> v{};
        for (auto i = 0u; i < instructions.size(); ++i) {
          auto&& entry = v.emplace_back(
            instructions[i].ip,
            std::vector<typename info::unit>(units.size())
          );
          for (auto n = 0u; n < units.size(); ++n) {
            const auto usage = res_usage[n + (i * units.size())];
            const auto pressure = usage / executions;
            entry.units[n] = {
              .name = units[n].Name,
              .pressure = pressure < .005 ? 0. : std::floor((pressure * 100.) + .5) / 100.
            };
          }
        }

        return v;
      }

     private:
      struct handler : ::llvm::mca::View {
        constexpr handler(const auto& sm, auto& res_usage, auto& id, const auto instructions)
          : sm_{sm}, res_usage_{res_usage}, id_{id}, instructions_{instructions} {
          std::size_t size{};
          const auto n_res = sm_.getNumProcResourceKinds();
          for (auto i = 0u; i < n_res; ++i) {
            const auto &res = *sm_.getProcResource(i);
            if (res.SubUnitsIdxBegin or not res.NumUnits) {
              continue;
            }
            res_index.insert(std::pair{i, size});
            size += res.NumUnits;
          }

          units_size_ = size;
          res_usage_.resize(units_size_ * (instructions_ + 1u));
          std::fill(res_usage_.begin(), res_usage_.end(), .0);
        }

        constexpr void onEvent(const ::llvm::mca::HWInstructionEvent& event) override {
          if (event.Type == ::llvm::mca::HWInstructionEvent::Dispatched) {
            id_ = event.IR.getSourceIndex();
            return;
          }

          if (event.Type != ::llvm::mca::HWInstructionEvent::Issued) {
            return;
          }

          const auto source_index = event.IR.getSourceIndex() % instructions_;
          for (const auto& [res, usage] : static_cast<const ::llvm::mca::HWInstructionIssuedEvent&>(event).UsedResources) {
            verify(res_index.contains(res.first));
            const auto index = res_index[res.first] + ::llvm::countr_zero(res.second);
            res_usage_[index + units_size_ * source_index] += usage;
            res_usage_[index + units_size_ * instructions_] += usage;
          }
        }

        ::llvm::StringRef getNameAsString() const override { return {}; }
        void printView(::llvm::raw_ostream&) const override { }

       private:
        const ::llvm::MCSchedModel &sm_;
        std::vector<::llvm::mca::ReleaseAtCycles>& res_usage_;
        std::size_t& id_;
        std::size_t instructions_{};
        ::llvm::DenseMap<unsigned, unsigned> res_index{};
        std::size_t units_size_{};
      };
    };

    /**
     * correlates increases in backend pressure to dynamic dispatch stalls
     * - https://github.com/llvm/llvm-project/tree/main/llvm/tools/llvm-mca
     * - https://llvm.org/docs/CommandGuide/llvm-mca.html
     *
     * this class is derived from llvm project
     * - https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h
     * - https://github.com/llvm/llvm-project/blob/main/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp
     *
     * modifcations
     * - split business logic and view logic
     * - applied api changes required for integration with the library
     * - applied C++20 changes and formatting
     */
    struct bottleneck {
      using value_type = struct info {
        std::uint64_t ip{};
        enum class dependency {
          none, /// none dependency
          reg,  /// register dependency
          mem,  /// memory dependency
          res,  /// resource dependency
        } dependency{};
        std::optional<std::string> name{};
        std::optional<double> freq{};
        std::optional<double> cost{};
      };

      std::size_t iterations = 1u; /// number of iterations to simulate

      [[nodiscard]] constexpr auto operator()(const std::ranges::range auto& instructions, auto& llvm) const
        requires requires (std::size_t i) { instructions[i].ip; instructions[i].size; } {
        std::vector<std::unique_ptr<::llvm::mca::Instruction>> lowered_sequence{};
        const ::llvm::SmallVector<::llvm::mca::Instrument*> instruments{};

        for (const auto& instruction : instructions) {
          ::llvm::MCInst inst{};
          std::size_t size{};
          verify(llvm.disassembler->getInstruction(
            inst,
            size,
            ::llvm::ArrayRef<std::uint8_t>{
              reinterpret_cast<const std::uint8_t*>(instruction.ip),
              reinterpret_cast<const std::uint8_t*>(instruction.ip) + instruction.size
            },
            instruction.ip,
            ::llvm::nulls()
          ) == ::llvm::MCDisassembler::DecodeStatus::Success);
          lowered_sequence.emplace_back(
            std::move(llvm.instruction_builder->createInstruction(inst, instruments).get())
          );
        }

        ::llvm::mca::CircularSourceMgr mgr(lowered_sequence, iterations);
        ::llvm::mca::CustomBehaviour custom_behavior{*llvm.subtarget_info, mgr, *llvm.instruction_info};
        ::llvm::mca::PipelineOptions options(
          llvm.arch.micro_op_queue,
          llvm.arch.decoder_throughput,
          llvm.arch.dispatch_width,
          llvm.arch.register_file_size,
          llvm.arch.load_queue_size,
          llvm.arch.store_queue_size,
          llvm.arch.assume_no_alias,
          true /// enable bottleneck analysis to emit HWPressureEvents
        );
        ::llvm::mca::Context mca{*llvm.register_info, *llvm.subtarget_info};
        auto pipeline = mca.createDefaultPipeline(options, mgr, custom_behavior);

        pressure_tracker tracker{llvm.subtarget_info->getSchedModel()};
        dependency_graph graph(instructions.size() * 3u);
        back_pressure_info bpi{iterations};
        handler handler{tracker, graph, bpi, instructions.size()};

        pipeline->addEventListener(std::addressof(handler));
        verify(bool(pipeline->run()));

        std::vector<info> v(instructions.size());
        const auto& critical_seq = graph.critial_seq();

        for (auto i = 0u; i < v.size(); ++i) {
          const auto seq = std::find_if(
            critical_seq.begin(),
            critical_seq.end(),
            [&](const auto& t) { return (t->FromIID % instructions.size()) == i; }
          );

          if (seq == critical_seq.end()) {
            continue;
          }

          const auto& dep = (*seq)->Dep;
          if (dep.type == info::dependency::reg) {
            std::string reg_name{};
            ::llvm::raw_string_ostream str{reg_name};
            llvm.instruction_printer->printRegName(str, dep.ResourceOrRegID);
            v[i] = {
              .ip = instructions[i].ip,
              .dependency = info::dependency::reg,
              .name = reg_name,
            };
          } else if (dep.type == info::dependency::mem) {
            v[i] = {
              .ip = instructions[i].ip,
              .dependency = info::dependency::mem
            };
          } else if (dep.type == info::dependency::res) {
            v[i] = {
              .ip = instructions[i].ip,
              .dependency = info::dependency::res,
              .name = tracker.resolve_name(dep.ResourceOrRegID),
              .freq = ((*seq)->Frequency * 100.) / iterations,
              .cost = dep.Cost,
            };
          } else {
            verify(false, "mca::bottleneck: unsupported dependency!");
          }
        }
        return v;
      }

     private:
      struct back_pressure_info {
        std::size_t iterations{};
        std::size_t PressureIncreaseCycles{};
        std::size_t ResourcePressureCycles{};
        std::size_t DataDependencyCycles{};
        std::size_t RegisterDependencyCycles{};
        std::size_t MemoryDependencyCycles{};
        bool SeenStallCycles{};
      };

      struct instruction_pressure_info {
        std::size_t RegisterPressureCycles{};
        std::size_t MemoryPressureCycles{};
        std::size_t ResourcePressureCycles{};
      };

      struct instruction_executed {
        std::size_t id{};
      };

      struct instruction_dispatched {
        std::size_t id{};
      };

      class pressure_tracker {
       public:
        constexpr explicit pressure_tracker(const auto& sm)
          : sm_{sm}
          , ResourcePressureDistribution(sm.getNumProcResourceKinds(), 0)
          , ProcResID2Mask(sm.getNumProcResourceKinds(), 0)
          , ResIdx2ProcResID(sm.getNumProcResourceKinds(), 0)
          , ProcResID2ResourceUsersIndex(sm.getNumProcResourceKinds(), 0) {
          ::llvm::mca::computeProcResourceMasks(sm_, ProcResID2Mask);

          auto index = 0u;
          for (auto i = 1u; i < sm_.getNumProcResourceKinds(); ++i) {
            ProcResID2ResourceUsersIndex[i] = index;
            index += sm_.getProcResource(i)->NumUnits;
            ResIdx2ProcResID[::llvm::mca::getResourceStateIndex(ProcResID2Mask[i])] = i;
          }

          users_.resize(index);
          std::fill(users_.begin(), users_.end(), std::make_pair<unsigned, unsigned>(~0U, 0U));
        }

        constexpr void on(const instruction_dispatched& event) {
          ipi_.insert(std::make_pair(event.id, instruction_pressure_info()));
        }

        constexpr void on(const instruction_executed& event) {
          ipi_.erase(event.id);
        }

        constexpr void on(const ::llvm::mca::HWInstructionIssuedEvent& event) {
          const auto id = event.IR.getSourceIndex();
          for (const auto &[use, index] : event.UsedResources) {
            const auto Index = ProcResID2ResourceUsersIndex[use.first] + ::llvm::countr_zero(use.second);
            users_[Index] = std::make_pair(id, index.getNumerator());
          }
        }

        constexpr void on(const ::llvm::mca::HWPressureEvent& event) {
          verify(event.Reason != ::llvm::mca::HWPressureEvent::INVALID, "mca::bottleneck: unexpected invalid event!");

          switch (event.Reason) {
            default: break;

            case ::llvm::mca::HWPressureEvent::RESOURCES: {
              const uint64_t ResourceMask = event.ResourceMask;
              update(event.ResourceMask);

              for (const auto &IR : event.AffectedInstructions) {
                const auto &IS = *IR.getInstruction();
                const auto BusyResources = IS.getCriticalResourceMask() & ResourceMask;
                if (!BusyResources) {
                  continue;
                }
                ipi_[IR.getSourceIndex()].ResourcePressureCycles++;
              }
              break;
            }

            case ::llvm::mca::HWPressureEvent::REGISTER_DEPS: {
              for (const auto &IR : event.AffectedInstructions) {
                ipi_[IR.getSourceIndex()].RegisterPressureCycles++;
              }
              break;
            }

            case ::llvm::mca::HWPressureEvent::MEMORY_DEPS: {
              for (const auto &IR : event.AffectedInstructions) {
                ipi_[IR.getSourceIndex()].MemoryPressureCycles++;
              }
            }
          }
        }

        constexpr void update(auto cumulative_mask) {
          while (cumulative_mask) {
            auto current = cumulative_mask & (-cumulative_mask);
            auto ResIdx = ::llvm::mca::getResourceStateIndex(current);
            auto ProcResID = ResIdx2ProcResID[ResIdx];
            auto mask = ProcResID2Mask[ProcResID];

            if (mask == current) {
              ResourcePressureDistribution[ProcResID]++;
              cumulative_mask ^= current;
              continue;
            }

            mask ^= current;
            while (mask) {
              const auto unit = mask & (-mask);
              ResIdx = ::llvm::mca::getResourceStateIndex(unit);
              ProcResID = ResIdx2ProcResID[ResIdx];
              ResourcePressureDistribution[ProcResID]++;
              mask ^= unit;
            }

            cumulative_mask ^= current;
          }
        }

        [[nodiscard]] constexpr auto resolve_name(const auto mask) const {
          const auto Index = ::llvm::mca::getResourceStateIndex(mask);
          const auto ProcResID = ResIdx2ProcResID[Index];
          const auto &PRDesc = *sm_.getProcResource(ProcResID);
          return PRDesc.Name;
        }

        [[nodiscard]] constexpr auto reg_pressure_cycles(const auto id) const {
          verify(ipi_.contains(id), "mca::bottleneck: instruction is not tracked!");
          const auto &Info = ipi_.find(id)->second;
          return Info.RegisterPressureCycles;
        }

        [[nodiscard]] constexpr auto mem_pressure_cycles(const auto id) const {
          verify(ipi_.contains(id), "mca::bottleneck: instruction is not tracked!");
          const auto &Info = ipi_.find(id)->second;
          return Info.MemoryPressureCycles;
        }

        [[nodiscard]] constexpr auto res_pressure_cycles(const auto id) const {
          verify(ipi_.contains(id), "mca::bottleneck: instruction is not tracked!");
          const auto &Info = ipi_.find(id)->second;
          return Info.ResourcePressureCycles;
        }

        [[nodiscard]] constexpr auto res_pressure_distribution() const -> ::llvm::ArrayRef<unsigned> {
          return ResourcePressureDistribution;
        }

        constexpr void users(const auto mask, auto& users) const {
          auto Index = ::llvm::mca::getResourceStateIndex(mask);
          auto ProcResID = ResIdx2ProcResID[Index];
          const auto &PRDesc = *sm_.getProcResource(ProcResID);
          for (auto I = 0u; I < PRDesc.NumUnits; ++I) {
            const auto U = users_[ProcResID2ResourceUsersIndex[ProcResID] + I];
            if (U.second and ipi_.contains(U.first)) {
              users.emplace_back(U);
            }
          }
        }

      private:
        const ::llvm::MCSchedModel &sm_;
        ::llvm::SmallVector<unsigned, 4u> ResourcePressureDistribution{};
        ::llvm::SmallVector<std::uint64_t, 4u> ProcResID2Mask{};
        ::llvm::SmallVector<unsigned, 4u> ResIdx2ProcResID{};
        ::llvm::SmallVector<unsigned, 4u> ProcResID2ResourceUsersIndex{};
        ::llvm::SmallVector<std::pair<unsigned, unsigned>, 4u> users_{};
        ::llvm::DenseMap<unsigned, instruction_pressure_info> ipi_{};
      };

      struct dependency_graph {
        struct dependency {
          enum info::dependency type{};
          std::uint64_t ResourceOrRegID{};
          std::uint64_t Cost{};
        };

        struct edge {
          dependency Dep{};
          unsigned FromIID{};
          unsigned ToIID{};
          unsigned Frequency{};
        };

        struct node {
          unsigned NumPredecessors{};
          unsigned NumVisitedPredecessors{};
          unsigned Depth{};
          std::uint64_t Cost{};
          edge CriticalPredecessor{};
          ::llvm::SmallVector<edge, 0u> OutgoingEdges{};
        };

       public:
        constexpr dependency_graph(const dependency_graph&) = delete;
        /*constexpr*/ dependency_graph(dependency_graph&&) = default;
        constexpr explicit dependency_graph(const std::size_t size)
          : nodes_(size)
        { }

        constexpr void init(auto& root) const {
          for (auto i = 0u; i < nodes_.size(); ++i) {
            const auto &node = nodes_[i];
            if (not node.NumPredecessors and not node.OutgoingEdges.empty()) {
              root.emplace_back(i);
            }
          }
        }

        constexpr void add_reg_dep(const auto From, const auto To, const auto RegID, const auto Cost) {
          add(From, To, {info::dependency::reg, RegID, Cost});
        }

        constexpr void add_mem_dep(const auto From, const auto To, const auto Cost) {
          add(From, To, {info::dependency::mem, {}, Cost});
        }

        constexpr void add_res_dep(const auto From, const auto To, const auto Mask, const auto Cost) {
          add(From, To, {info::dependency::res, Mask, Cost});
        }

        constexpr void propagate(auto& root) {
          ::llvm::SmallVector<unsigned, 8u> visit{};
          do {
            for (auto id : root) {
              const auto& node = nodes_[id];
              for (const auto &DepEdge : node.OutgoingEdges) {
                const auto ToIID = DepEdge.ToIID;
                auto& To = nodes_[ToIID];
                const auto Cost = node.Cost + DepEdge.Dep.Cost;
                if (Cost > To.Cost) {
                  To.CriticalPredecessor = DepEdge;
                  To.Cost = Cost;
                  To.Depth = node.Depth + 1;
                }
                To.NumVisitedPredecessors++;
                if (To.NumVisitedPredecessors == To.NumPredecessors) {
                  visit.emplace_back(ToIID);
                }
              }
            }

            std::swap(root, visit);
            visit.clear();
          } while (not root.empty());
        }

        constexpr void prune(const auto iterations) {
          for (auto& node : nodes_) {
            auto NumPruned = 0u;
            const auto Size = node.OutgoingEdges.size();
            for (auto I = 0ul, E = Size; I < E; ++I) {
              edge &Edge = node.OutgoingEdges[I];
              if (Edge.Frequency == iterations) {
                continue;
              }
              const auto Factor = double(Edge.Frequency) / iterations;
              if (.10 < Factor) {
                continue;
              }
              nodes_[Edge.ToIID].NumPredecessors--;
              std::swap(Edge, node.OutgoingEdges[E - 1]);
              --E;
              ++NumPruned;
            }

            if (NumPruned) {
              node.OutgoingEdges.resize(Size - NumPruned);
            }
          }
        }

        constexpr void finalize(const auto iterations) {
          ::llvm::SmallVector<unsigned, 16u> root{};
          prune(iterations);
          init(root);
          propagate(root);
        }

        [[nodiscard]] constexpr auto critial_seq() const -> ::llvm::SmallVector<const edge *, 16u> {
          ::llvm::SmallVector<const edge *, 16u> seq{};
          const auto It = std::max_element(nodes_.begin(), nodes_.end(), [](const auto& lhs, const auto& rhs) {
            return lhs.Cost < rhs.Cost;
          });
          auto id = std::distance(nodes_.begin(), It);
          seq.resize(nodes_[id].Depth);
          for (const auto *& de : ::llvm::reverse(seq)) {
            const auto& node = nodes_[id];
            de = &node.CriticalPredecessor;
            id = node.CriticalPredecessor.FromIID;
          }
          return seq;
        }

       private:
        constexpr void add(const auto From, const auto To, dependency&& Dep) {
          auto& NodeFrom = nodes_[From];
          auto& NodeTo = nodes_[To];
          auto& Vec = NodeFrom.OutgoingEdges;
          const auto It = find_if(Vec, [To, Dep](auto& de) {
            return de.ToIID == To and de.Dep.ResourceOrRegID == Dep.ResourceOrRegID;
          });

          if (It != Vec.end()) {
            It->Dep.Cost += Dep.Cost;
            It->Frequency++;
            return;
          }

          Vec.emplace_back(edge(Dep, From, To, 1));
          NodeTo.NumPredecessors++;
        }

        ::llvm::SmallVector<node, 16u> nodes_{};
      };

      struct handler : ::llvm::mca::View {
        constexpr handler(auto& tracker, auto& graph, auto& bpi, const auto instructions)
          : tracker_{tracker}
          , graph_{graph}
          , bpi_{bpi}
          , instructions_{instructions}
        { }

        constexpr void onEvent(const ::llvm::mca::HWStallEvent &) override {
          bpi_.SeenStallCycles = true;
        }

        constexpr void onEvent(const ::llvm::mca::HWInstructionEvent &Event) override {
          const auto id = Event.IR.getSourceIndex();

          if (Event.Type == ::llvm::mca::HWInstructionEvent::Dispatched) {
            tracker_.on(instruction_dispatched{id});
            return;
          }

          if (Event.Type == ::llvm::mca::HWInstructionEvent::Executed) {
            tracker_.on(instruction_executed{id});
            return;
          }

          if (Event.Type != ::llvm::mca::HWInstructionEvent::Issued) {
            return;
          }

          const auto &IS = *Event.IR.getInstruction();
          const auto To = id % instructions_;
          auto Cycles = 2u * tracker_.res_pressure_cycles(id);
          auto ResourceMask = IS.getCriticalResourceMask();
          ::llvm::SmallVector<std::pair<unsigned, unsigned>, 4u> users{};

          while (ResourceMask) {
            const auto Current = ResourceMask & (-ResourceMask);
            tracker_.users(Current, users);
            for (const auto& user : users) {
              add_res_dep(user.first % instructions_, To, Current, user.second + Cycles);
            }
            users.clear();
            ResourceMask ^= Current;
          }

          const auto &RegDep = IS.getCriticalRegDep();
          if (RegDep.Cycles) {
            Cycles = RegDep.Cycles + 2u * tracker_.reg_pressure_cycles(id);
            const auto From = RegDep.IID % instructions_;
            add_reg_dep(From, To, RegDep.RegID, Cycles);
          }

          const auto &MemDep = IS.getCriticalMemDep();
          if (MemDep.Cycles) {
            Cycles = MemDep.Cycles + 2u * tracker_.mem_pressure_cycles(id);
            const auto  From = MemDep.IID % instructions_;
            add_mem_dep(From, To, Cycles);
          }

          tracker_.on(static_cast<const ::llvm::mca::HWInstructionIssuedEvent&>(Event));

          if (id == ((bpi_.iterations * instructions_) - 1u)) {
            graph_.finalize(bpi_.iterations);
          }
        }

        constexpr void onEvent(const ::llvm::mca::HWPressureEvent &Event) override {
          verify(Event.Reason != ::llvm::mca::HWPressureEvent::INVALID, "mca::bottleneck: unexpected invalid event!");
          tracker_.on(Event);

          switch (Event.Reason) {
            default: break;
            case ::llvm::mca::HWPressureEvent::RESOURCES:
              pressure_.res = true;
              break;
            case ::llvm::mca::HWPressureEvent::REGISTER_DEPS:
              pressure_.reg = true;
              break;
            case ::llvm::mca::HWPressureEvent::MEMORY_DEPS:
              pressure_.mem = true;
              break;
            }
        }

        constexpr void onCycleEnd() override {
          const auto pressure_data = pressure_.reg or pressure_.mem;
          if (not pressure_.res and not pressure_data) {
            return;
          }

          ++bpi_.PressureIncreaseCycles;
          if (pressure_.reg) {
            ++bpi_.RegisterDependencyCycles;
          }

          if (pressure_.mem) {
            ++bpi_.MemoryDependencyCycles;
          }
          if (pressure_data) {
            ++bpi_.DataDependencyCycles;
          }

          if (pressure_.res) {
            ++bpi_.ResourcePressureCycles;
          }

          pressure_ = {};
        }

        ::llvm::StringRef getNameAsString() const override { return {}; }
        void printView(::llvm::raw_ostream&) const override { }

       private:
        constexpr void add_reg_dep(const auto From, const auto To, const auto RegID, const auto Cost) {
          if (const auto IsLoopCarried = From >= To; IsLoopCarried) {
            graph_.add_reg_dep(From, To + instructions_, RegID, Cost);
            graph_.add_reg_dep(From + instructions_, To + (instructions_ * 2u), RegID, Cost);
            return;
          }
          graph_.add_reg_dep(From + instructions_, To + instructions_, RegID, Cost);
        }

        constexpr void add_mem_dep(const auto From, const auto To, const auto Cost) {
          if (const auto IsLoopCarried = From >= To; IsLoopCarried) {
            graph_.add_mem_dep(From, To + instructions_, Cost);
            graph_.add_mem_dep(From + instructions_, To + (instructions_ * 2u), Cost);
            return;
          }
          graph_.add_mem_dep(From + instructions_, To + instructions_, Cost);
        }

        constexpr void add_res_dep(const auto From, const auto To, const auto Mask, const auto Cost) {
          if (const auto IsLoopCarried = From >= To; IsLoopCarried) {
            graph_.add_res_dep(From, To + instructions_, Mask, Cost);
            graph_.add_res_dep(From + instructions_, To + (instructions_ * 2u), Mask, Cost);
            return;
          }
          graph_.add_res_dep(From + instructions_, To + instructions_, Mask, Cost);
        }

        pressure_tracker& tracker_;
        dependency_graph& graph_;
        back_pressure_info& bpi_;
        std::size_t instructions_{};
        struct { bool res{}; bool reg{}; bool mem{}; } pressure_{};
      };
    };

    inline constexpr auto timeline = fixed_named<"mca.timeline", struct timeline>{};
    inline constexpr auto resource_pressure = fixed_named<"mca.resource_pressure", struct resource_pressure>{};
    inline constexpr auto bottleneck = fixed_named<"mca.bottleneck", struct bottleneck>{};

    inline namespace debug {
      #if PERF_LINUX == 1
      /**
       * instruction to source code
       * - requires debug symbols `-g`
       */
      struct source {
        using value_type = struct info {
          std::uint64_t ip{};
          std::string value{};
        };

        [[nodiscard]] constexpr auto operator()(const auto& instruction, auto&&...) const -> value_type
          requires requires { instruction.ip; } {
          if (const auto& info = perf::info::bin::addr_to_line(binary_name, instruction.ip - base_address); info) {
            const auto& line = *info;
            std::size_t i{};
            while (line[i] == ' ' or line[i] == '\t') i++;
            if (last_ != line) {
              last_ = line;
              return {instruction.ip, line.substr(i)};
            }
          }
          return {instruction.ip};
        }

       private:
        mutable std::string last_{}; /// cached
        inline static const auto binary_name = perf::info::proc::self::name();
        inline static const auto base_address = perf::info::proc::self::base_address();
      };

      inline const auto source = fixed_named<"mca.debug.source", struct source>{};
      #endif // PERF_LINUX
    } // namespace debug
  } // namespace mca
  #endif // PERF_LLVM
} // namespace backend

inline namespace prof {
  template<class T>
  concept profiler_like = requires(T t) {
    t.start();
    t.stop();
  };

  template<class... TProfilers>
    requires ((profiler_like<TProfilers> and
    requires (TProfilers profilers) { profilers[]; }) and ...)
  struct profiler {
    constexpr explicit profiler(TProfilers&... profilers)
      : profilers_{profilers...}
    { }

    constexpr auto start() {
      std::apply([&](auto&... ts) { (ts.start(), ...); }, profilers_);
    }

    constexpr auto stop() {
      std::apply([](auto&... ts) {
        [[maybe_unused]] int _{}; (void)(_ = ... = (ts.stop(), _)); /// reverse order
      }, profilers_);
    }

    template<class... Ts>
      requires (requires { Ts::name(); } and ...)
    [[nodiscard]] constexpr decltype(auto) operator[](Ts...) const {
      auto&& t = (*this)[];
      return std::tuple{std::get<index<Ts>(t)>(t)...};
    }

    [[nodiscard]] constexpr decltype(auto) operator[]() const {
      return std::apply([](const auto&... ts) {
        return std::tuple_cat(ts[]...);
      }, profilers_);
    }

   private:
    template<class T>
    static constexpr auto index = []<class... Ts>(const std::tuple<Ts...>&) {
      const std::array<bool, sizeof...(Ts)> matches{
        (std::string_view(Ts::name()) == std::string_view(T::name()))...
      };
      const auto found = std::find(matches.begin(), matches.end(), true);
      verify(found != matches.end());
      return std::distance(matches.begin(), found);
    };

    std::tuple<TProfilers&...> profilers_{};
  };

  /**
   * counting # perf counters
   * - https://perf.wiki.kernel.org
   */
  namespace stat {
    template<class TRatio, class T = double>
    struct duration {
      using value_type = std::chrono::duration<T, TRatio>;

      constexpr duration() = default;
      constexpr duration(const auto& value)
        requires requires { value_type(value); }
        : value(value)
      { }

      [[nodiscard]] constexpr auto count() const {
        return value.count();
      }

      [[nodiscard]] constexpr operator auto() const {
        return count();
      }

      value_type value{};
   };

    template<class T, class TRatio = std::nano>
    concept time_like = profiler_like<T> and requires(T t) {
      { *t } -> std::same_as<duration<TRatio>>;
    };

    template<class T>
      requires requires { T::period::den; } and (T::period::den == std::nano::den)
    struct chrono {
      using value_type = duration<std::nano>;

      constexpr auto start() { start_ = T::now(); }
      constexpr auto stop()  { stop_ = T::now(); }

      [[nodiscard]] constexpr auto operator*() const {
        return value_type{stop_ - start_};
      }

     private:
      T::time_point start_{};
      T::time_point stop_{};
    };

    #if PERF_LINUX == 1
    /**
     * clock_gettime overhead is not stable # may lock, may call syscall
     * - /sys/devices/system/clocksource/clocksource0/current_clocksource
     * @tparam ClockId
     *  CLOCK_MONOTONIC
     *  CLOCK_MONOTONIC_RAW
     *  CLOCK_REALTIME
     *  CLOCK_REALTIME_COARSE
     *  CLOCK_PROCESS_CPUTIME_ID
     *  CLOCK_THREAD_CPUTIME_ID
     */
    template<clockid_t ClockId>
    struct clock {
      using value_type = duration<std::nano>;

      constexpr auto start() { clock_gettime(ClockId, &start_); }
      constexpr auto stop()  { clock_gettime(ClockId, &stop_); }

      [[nodiscard]] constexpr auto operator*() const {
        return value_type{
          (stop_.tv_sec - start_.tv_sec) * 1e9 + (stop_.tv_nsec - start_.tv_nsec)
        };
      }

     private:
      timespec start_{};
      timespec stop_{};
    };
    #endif // PERF_LINUX

    #if __has_builtin(__builtin_ia32_rdtsc)
    /**
     * https://en.wikipedia.org/wiki/Time_Stamp_Counter
     * https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=rdtsc
     */
    struct rdtsc {
      using GHz = strong_alias<double>;
      using value_type = duration<std::nano>;

      constexpr void start() {
        start_ = __builtin_ia32_rdtsc(); /// no serialization
      }

      constexpr void stop() {
        unsigned int aux{};
        stop_ = __builtin_ia32_rdtscp(&aux); /// partial serialization
      }

      [[nodiscard]] constexpr auto operator*() const {
        return value_type{(stop_ - start_) / freq()};
      }

     private:
      std::uint64_t start_{};
      std::uint64_t stop_{};
      [[nodiscard]] static auto freq() -> GHz;
    };

    auto rdtsc::freq() -> GHz {
      static auto freq = []<std::size_t N = 3u, std::size_t ms = 10u> {
        auto freq = 0.;
        rdtsc t{};
        for (auto i = 0u; i < N; ++i) {
          const auto start = std::chrono::steady_clock::now();
          std::chrono::steady_clock::time_point stop{};
          const auto min = start + std::chrono::milliseconds(ms);

          t.start();
          for (;;) {
            stop = std::chrono::steady_clock::now();
            t.stop();
            if (stop >= min) {
              break;
            }
          }

          freq = std::max(freq, (t.stop_ - t.start_) /
            duration<std::nano>(stop - start)
          );
        }
        return freq;
      }();
      return {freq};
    }
    #endif // __builtin_ia32_rdtsc

    template<class... TTimers>
      requires (time_like<TTimers> and ...)
    struct timer {
      constexpr explicit timer(const TTimers&... timers)
        : timers_{timers...}
      { }

      constexpr void start() {
        std::apply([&](auto&... ts) { (ts.start(), ...); }, timers_);
      }

      constexpr void stop() {
        std::apply([](auto&... ts) {
          [[maybe_unused]] int _{}; (void)(_ = ... = (ts.stop(), _)); /// reverse order
        }, timers_);
      }

      template<class... Ts>
      [[nodiscard]] constexpr decltype(auto) operator[](Ts...) const {
        return std::tuple{make_fixed_named<Ts::name()>(*std::get<Ts>(timers_))...};
      }

      [[nodiscard]] constexpr decltype(auto) operator[]() const {
        return this->operator[](TTimers{}...);
      }

     private:
      std::tuple<TTimers...> timers_{};
    };

    template<> class timer<> {
     public:
      constexpr explicit timer(auto&&...) { }
      constexpr void start() { }
      constexpr void stop() { }
      [[nodiscard]] constexpr auto operator[](auto...) const {
        return std::tuple{};
      }
    };

    #if __has_builtin(__builtin_ia32_rdtsc)
    /// time-stamp-counter # https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=rdtsc
    inline constexpr time_like auto tsc = fixed_named<"stat.tsc[ns]", struct rdtsc>{};
    #endif // __builtin_ia32_rdtsc

    /// monotonic time # guranateed to be always increasing
    inline constexpr time_like auto steady_time = fixed_named<"stat.steady_time[ns]", chrono<std::chrono::steady_clock>>{};

    #if PERF_LINUX == 1
    /// user time + sys time
    inline constexpr time_like auto cpu_time = fixed_named<"stat.cpu_time[ns]", clock<CLOCK_PROCESS_CPUTIME_ID>>{};

    /// cpu time for the current thread
    inline constexpr time_like auto thread_time = fixed_named<"stat.thread_time[ns]", clock<CLOCK_THREAD_CPUTIME_ID>>{};

    /// wall clock time
    /// - backed by tsc: yes if /sys/devices/system/clocksource/clocksource0/current_clocksource is tsc
    /// - vdso: yes
    /// - ntp: no
    inline constexpr time_like auto real_time = fixed_named<"stat.real_time[ns]", clock<CLOCK_REALTIME>>{};
    #endif // PERF_LINUX

    inline constexpr auto seconds = []<class T>(const T& time) {
      constexpr auto name = concat(fixed_string{"seconds("}, T::name(), fixed_string{")"});
      return perf::make_fixed_named<name>(
        [&](auto& data) {
          using seconds = std::ratio<1>;
          fixed_named<name, std::vector<stat::duration<seconds>>> t{};
          for (const auto& time : std::get<0u>(data[time])) {
            t.push_back(time.count() / 1e9);
          }
          return t;
        }
      );
    };

    template<class T>
    concept event_like = requires (T t) {
      typename T::value_type;
      t.name;
      t.type;
      t.config[0u]; t.config[1u]; t.config[2u];
      t.priority;
    };

    struct config {
      enum mode {
        user        = 0b00001,
        kernel      = 0b00010,
        hypervisor  = 0b00100,
        idle        = 0b01000,
        guest       = 0b10000,
      } mode = mode::user;

      std::optional<std::int32_t> pid{};    /// pid of the process {not_set: current process, N: process<N>}
      std::optional<std::int32_t> cpu{};    /// cpu of the process {not_set: any_cpu, N: cpu<N>}
    };

    #if PERF_LINUX == 1
    /**
     * `perf stat -e`
     */
    template<event_like... TEvents>
    class counter {
      static constexpr auto read_format =
        PERF_FORMAT_ID                      /// event.id
      | PERF_FORMAT_GROUP                   /// group counters
      | PERF_FORMAT_TOTAL_TIME_ENABLED      /// multiplexing correction [optional]
      | PERF_FORMAT_TOTAL_TIME_RUNNING      /// multiplexing correction [optional]
      ;

      struct data {
        std::uint64_t size{};               /// events.size
        std::uint64_t total_time_enabled{}; /// multiplexing correction [optional]
        std::uint64_t total_time_running{}; /// multiplexing correction [optional]
        struct {
          std::uint64_t value{};
          std::uint64_t id{};
        } values[sizeof...(TEvents)]{};     /// `verify(size == sizeof...(TEvents))`
      };

     public:
      constexpr counter(counter&&) = delete;
      constexpr counter(const counter&) = delete;
      constexpr explicit counter(const TEvents&... events)
        : counter{config{}, events...}
      { }
      template<class TConfig = config>
        requires requires (TConfig config) { config.mode; config.pid; config.cpu; }
      constexpr explicit counter(const TConfig& config, const TEvents&... events) {
        std::size_t i{};
        const auto pid = config.pid ? *config.pid : 0;
        const auto cpu = config.cpu ? *config.cpu : -1;
        const auto setup = [&](const auto& event) {
          perf_event_attr attr{};
          attr.type = event.type;
          attr.size = sizeof(perf_event_attr);
          attr.config = event.config[0u];
          attr.read_format = read_format;
          attr.disabled = fd_ == -1;
          attr.exclude_user = not (config.mode & decltype(config.mode)::user);
          attr.exclude_kernel = not (config.mode & decltype(config.mode)::kernel);
          attr.exclude_hv = not (config.mode & decltype(config.mode)::hypervisor);
          attr.exclude_idle = not (config.mode & decltype(config.mode)::idle);
          attr.exclude_guest = not (config.mode & decltype(config.mode)::guest);
          attr.config1 = event.config[1u];
          attr.config2 = event.config[2u];

          const auto fd = syscall(__NR_perf_event_open, &attr, pid, cpu, fd_, 0);
          verify(fd != -1, std::strerror(errno));
          ioctl(fd, PERF_EVENT_IOC_ID, &ids_[i]);
          if (fd_ == -1) {
            fd_ = fd;
          }
          ++i;
        };

        ([&] { if (events.priority == decltype(events.priority)::high) { setup(events); } }(), ...);
        ([&] { if (events.priority == decltype(events.priority)::medium) { setup(events); } }(), ...);
        ([&] { if (events.priority == decltype(events.priority)::low) { setup(events); } }(), ...);
      }

      constexpr ~counter() noexcept {
        if (fd_ == -1) {
          return;
        }
        verify(not close(fd_));
      }

      constexpr void start() {
        ioctl(fd_, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP);
        ioctl(fd_, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
      }

      constexpr void stop() {
        verify(read(fd_, &data_, sizeof(data_)) == sizeof(data_));
        ioctl(fd_, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
      }

      template<class... Ts>
      [[nodiscard]] constexpr auto operator[](Ts...) const {
        verify(data_.size == sizeof...(TEvents));
        verify(data_.total_time_enabled  > 0u and data_.total_time_running > 0u);
        const auto correction = double(data_.total_time_enabled) / double(data_.total_time_running);
        constexpr auto value = [](const auto& v, const auto id) requires requires { std::begin(v); std::end(v); } {
          const auto found = std::find_if(std::begin(v), std::end(v), [&](const auto& data) { return data.id == id; });
          verify(found != std::end(v));
          return found->value;
        };
        return [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
          return std::tuple{
            make_fixed_named<Ts::name()>(
              typename Ts::value_type{value(data_.values, ids_[Ns]) * correction}
            )...
          };
        }(std::make_index_sequence<sizeof...(Ts)>{});
      }

      [[nodiscard]] constexpr auto operator[]() const {
        return this->operator[](TEvents{}...);
      }

     private:
      std::int32_t fd_{-1};
      data data_{};
      std::array<std::uint64_t, sizeof...(TEvents)> ids_{};
    };

    template<> class counter<> {
     public:
      constexpr explicit counter(auto&&...) { }
      constexpr void start() { }
      constexpr void stop() { }
      [[nodiscard]] constexpr auto operator[](auto...) const {
        return std::tuple{};
      }
    };

    /**
     * https://perfmon-events.intel.com # intel's list of events per architecture
     */
    inline namespace event {
      namespace aux {
        struct event {
          using value_type = strong_alias<double>;
          std::uint32_t type{};
          std::array<std::uint64_t, 3u> config{};                       /// perf_event_attr.{config1, config2, config3}
          enum priority { low, medium, high } priority = priority::low; /// high = group leader
        };
      } // namespace aux

      /**
       * perf list                        - shows available events
       * perf stat -vv -e {event} sleep 0 - finds config values for given event
       */
      inline constexpr event_like auto cpu_clock = constant<make_fixed_named<"stat.cpu_clock">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CPU_CLOCK}})>{};
      inline constexpr event_like auto task_clock = constant<make_fixed_named<"stat.task_clock">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_TASK_CLOCK}})>{};
      inline constexpr event_like auto page_faults = constant<make_fixed_named<"stat.page_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS}})>{};
      inline constexpr event_like auto faults = constant<make_fixed_named<"stat.faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS}})>{};
      inline constexpr event_like auto major_faults = constant<make_fixed_named<"stat.major_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS_MAJ}})>{};
      inline constexpr event_like auto minor_faults = constant<make_fixed_named<"stat.minor_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS_MIN}})>{};
      inline constexpr event_like auto alignment_faults = constant<make_fixed_named<"stat.alignment_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_ALIGNMENT_FAULTS}})>{};
      inline constexpr event_like auto emulation_faults = constant<make_fixed_named<"stat.emulation_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_EMULATION_FAULTS}})>{};
      inline constexpr event_like auto context_switches = constant<make_fixed_named<"stat.context_switches">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CONTEXT_SWITCHES}})>{};
      inline constexpr event_like auto cgroup_switches = constant<make_fixed_named<"stat.cgroup_switches">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CGROUP_SWITCHES}})>{};
      inline constexpr event_like auto cpu_migrations = constant<make_fixed_named<"stat.cpu_migrations">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CPU_MIGRATIONS}})>{};
      inline constexpr event_like auto migrations = constant<make_fixed_named<"stat.migrations">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CPU_MIGRATIONS}})>{};
      inline constexpr event_like auto cycles = constant<make_fixed_named<"stat.cycles">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CPU_CYCLES}})>{};
      inline constexpr event_like auto instructions = constant<make_fixed_named<"stat.instructions">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_INSTRUCTIONS}})>{};
      inline constexpr event_like auto branch_misses = constant<make_fixed_named<"stat.branch_misses">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BRANCH_MISSES}})>{};
      inline constexpr event_like auto bus_cycles = constant<make_fixed_named<"stat.bus_cycles">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BUS_CYCLES}})>{};
      inline constexpr event_like auto cache_misses = constant<make_fixed_named<"stat.cache_misses">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CACHE_MISSES}})>{};
      inline constexpr event_like auto cache_references = constant<make_fixed_named<"stat.cache_references">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CACHE_REFERENCES}})>{};
      inline constexpr event_like auto branches = constant<make_fixed_named<"stat.branches">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BRANCH_INSTRUCTIONS}})>{};
      inline constexpr event_like auto branch_instructions = constant<make_fixed_named<"stat.branch_instructions">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BRANCH_INSTRUCTIONS}})>{};
      inline constexpr event_like auto stalled_cycles_backend = constant<make_fixed_named<"stat.stalled_cycles_backend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_BACKEND}})>{};
      inline constexpr event_like auto idle_cycles_backend = constant<make_fixed_named<"stat.idle_cycles_backend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_BACKEND}})>{};
      inline constexpr event_like auto stalled_cycles_frontend = constant<make_fixed_named<"stat.stalled_cycles_frontend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_FRONTEND}})>{};
      inline constexpr event_like auto idle_cycles_frontend = constant<make_fixed_named<"stat.idle_cycles_frontend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_FRONTEND}})>{};
      inline constexpr event_like auto llc_misses = constant<make_fixed_named<"stat.LLC_misses">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CACHE_MISSES}})>{};
      inline constexpr event_like auto l1_misses = constant<make_fixed_named<"stat.L1_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto l1_dcache_loads = constant<make_fixed_named<"stat.L1_dcache_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto l1_dcache_load_misses = constant<make_fixed_named<"stat.L1_dcache_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto l1_icache_loads = constant<make_fixed_named<"stat.L1_icache_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1I | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto l1_icache_load_misses = constant<make_fixed_named<"stat.L1_icache_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1I | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto dtlb_loads = constant<make_fixed_named<"stat.dTLB_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_DTLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto dtlb_load_misses = constant<make_fixed_named<"stat.dTLB_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_DTLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto itlb_loads = constant<make_fixed_named<"stat.iTLB_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_ITLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto itlb_load_misses = constant<make_fixed_named<"stat.iTLB_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_ITLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};

      inline namespace metric {
        using perf::metric::operator+;
        using perf::metric::operator-;
        using perf::metric::operator*;
        using perf::metric::operator/;

        /// instruction per cycle (ipc)
        inline constexpr auto ipc = instructions / cycles;

        /// cycles per instruction (cpi, inverse of ipc)
        inline constexpr auto cpi = cycles / instructions;

        /// branch miss rate (branch misses per branch instruction)
        inline constexpr auto branch_miss_rate = branch_misses / branches;

        /// cache miss rate (cache misses per cache reference)
        inline constexpr auto cache_miss_rate = cache_misses / cache_references;

        /// llc miss rate
        inline constexpr auto llc_miss_rate = llc_misses / cache_references;

        /// l1 data cache miss rate
        inline constexpr auto l1_dcache_miss_rate = l1_dcache_load_misses / l1_dcache_loads;

        /// l1 instruction cache miss rate
        inline constexpr auto l1_icache_miss_rate = l1_icache_load_misses / l1_icache_loads;

        /// dtlb miss rate
        inline constexpr auto dtlb_miss_rate = dtlb_load_misses / dtlb_loads;

        /// itlb miss rate
        inline constexpr auto itlb_miss_rate = itlb_load_misses / itlb_loads;

        /// stalled cycles rate (frontend)
        inline constexpr auto frontend_stall_rate = stalled_cycles_frontend / cycles;

        /// stalled cycles rate (backend)
        inline constexpr auto backend_stall_rate = stalled_cycles_backend / cycles;

        /// memory access rate
        inline constexpr auto memory_stall_ratio = stalled_cycles_backend / cycles;

        /// overall stall rate
        inline constexpr auto total_stall_rate = (stalled_cycles_backend + stalled_cycles_frontend) / cycles;

         /// cpu migrations per cycles
        inline constexpr auto cpu_migration_rate = cpu_migrations / cycles;

        /// context switches per cycles
        inline constexpr auto context_switch_rate = context_switches / cycles;

        /// page fault rate
        inline constexpr auto page_fault_rate = faults / cycles;

        /// page fault rate (major faults per total faults)
        inline constexpr auto major_fault_rate = major_faults / cycles;

        /// page fault rate (minor faults per total faults)
        inline constexpr auto minor_fault_rate = minor_faults / cycles;
      } // namespace metric

      /**
       * top-down microarchitecture analysis method
       *  - https://www.intel.com/content/www/us/en/docs/vtune-profiler/cookbook/2023-0/top-down-microarchitecture-analysis-method.html
       *  - https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/topdown.txt
       *  - https://github.com/andikleen/pmu-tools/wiki/toplev-manual
       *  - https://github.com/intel/perfmon/blob/main/TMA_Metrics-full.xlsx # top-down metrics and events published by intel
       *  - ls /sys/bus/event_source/devices/cpu/events                      # to get supported top_down events (it might be cpu_core instead of cpu)
       */
      namespace top_down {
        namespace aux {
          struct event {
            using value_type = strong_alias<double>;
            std::uint32_t type{};
            struct {
              std::array<std::uint64_t, 3u>(*fn)(){};
              [[nodiscard]] constexpr operator auto() const { return fn(); }
              [[nodiscard]] constexpr auto operator [](std::size_t i) const { return fn()[i]; }
            } config{}; /// perf_event_attr.{config1, config2, config3}
            enum priority { low, medium, high } priority = priority::low; /// high = group leader
          };

          template<fixed_string Name> inline constexpr auto config = [] -> std::array<std::uint64_t, 3u> {
            auto&& cfg = info::sys::hw<"event=%zx,umask=%zx">(std::format("/sys/bus/event_source/devices/cpu/events/{}", std::string_view(Name))).or_else(
              [] { return info::sys::hw<"event=%zx,umask=%zx">(std::format("/sys/bus/event_source/devices/cpu_core/events/{}", std::string_view(Name))); }
            );
            verify(cfg and 2u == cfg->size(), std::format("'{}' not found!", std::string_view(Name)));
            return {((*cfg)[1] << CHAR_BIT) | (*cfg)[0]};
          };

          inline constexpr event_like auto slots = constant<make_fixed_named<"stat.slots">(aux::event{PERF_TYPE_RAW, {config<"slots">}, aux::event::priority::high})>{};
          inline constexpr event_like auto retiring = constant<make_fixed_named<"stat.top_down.retiring">(aux::event{PERF_TYPE_RAW, {config<"topdown-retiring">}})>{};
          inline constexpr event_like auto bad_speculation = constant<make_fixed_named<"stat.top_down.bad_speculation">(aux::event{PERF_TYPE_RAW, {config<"topdown-bad-spec">}})>{};
          inline constexpr event_like auto frontend_bound = constant<make_fixed_named<"stat.top_down.fronted_bound">(aux::event{PERF_TYPE_RAW, {config<"topdown-fe-bound">}})>{};
          inline constexpr event_like auto backend_bound = constant<make_fixed_named<"stat.top_down.backend_bound">(aux::event{PERF_TYPE_RAW, {config<"topdown-be-bound">}})>{};
          inline constexpr event_like auto heavy_operations = constant<make_fixed_named<"stat.top_down.heavy_operations">(aux::event{PERF_TYPE_RAW, {config<"topdown-heavy-ops">}})>{};
          inline constexpr event_like auto branch_mispredict = constant<make_fixed_named<"stat.top_down.branch_mispredict">(aux::event{PERF_TYPE_RAW, {config<"topdown-br-mispredict">}})>{};
          inline constexpr event_like auto fetch_latency = constant<make_fixed_named<"stat.top_down.fetch_latency">(aux::event{PERF_TYPE_RAW, {config<"topdown-fetch-lat">}})>{};
          inline constexpr event_like auto memory_bound = constant<make_fixed_named<"stat.top_down.memory_bound">(aux::event{PERF_TYPE_RAW, {config<"topdown-mem-bound">}})>{};
        } // namespace aux

        inline namespace metric {
          using perf::metric::operator+;
          using perf::metric::operator-;
          using perf::metric::operator*;
          using perf::metric::operator/;

          inline constexpr auto retiring = aux::retiring / aux::slots;
          inline constexpr auto heavy_operations = aux::heavy_operations / aux::slots;
          inline constexpr auto light_operations = retiring - heavy_operations;

          inline constexpr auto bad_speculation = aux::bad_speculation / aux::slots;
          inline constexpr auto branch_mispredict = aux::branch_mispredict / aux::slots;
          inline constexpr auto machine_clears = bad_speculation - branch_mispredict;

          inline constexpr auto frontend_bound = aux::frontend_bound / aux::slots;
          inline constexpr auto fetch_latency = aux::fetch_latency / aux::slots;
          inline constexpr auto fetch_bandwidth = frontend_bound - fetch_latency;

          inline constexpr auto backend_bound = aux::backend_bound / aux::slots;
          inline constexpr auto memory_bound = aux::memory_bound / aux::slots;
          inline constexpr auto core_bound = backend_bound - memory_bound;
        } // namespace metric
      } // namespace top_down
    } // namespace event
    #endif // PERF_LINUX
  } // namespace stat

  /**
   * sampling # perf counters
   * - https://perf.wiki.kernel.org
   */
  namespace record {
    template<class T>
    concept event_like = requires (T t) {
      requires requires (const typename T::value_type& data) { data.ip; };
      t.name;
      t.type;
      t.config[0]; t.config[1]; t.config[2];
    };

    struct config {
      enum mode {
        user            = 0b00001,
        kernel          = 0b00010,
        hypervisor      = 0b00100,
        idle            = 0b01000,
        guest           = 0b10000,
      } mode = mode::user;

      enum skid { /// precise_ip
        arbitrary       = 0,  /// - can have arbitrary skid
        constant        = 1,  /// - must have constant skid
        requested_zero  = 2,  /// - requested to have 0 skid
        zero            = 3,  /// - must have 0 skid
      } skid = skid::zero;

      struct period { std::int32_t value{}; };
      struct frequency { std::int32_t value{}; };
      struct interval {
        constexpr interval(const frequency& f) : value{f.value} { }
        constexpr interval(const period& p) : value{-p.value} { }
        [[nodiscard]] constexpr operator auto() const {
          return value;
        }
       private:
        std::int32_t value{};
      } interval = period{1000};

      std::optional<std::int32_t> pid{}; /// pid of the process {not_set: current process, N: process<N>}
      std::optional<std::int32_t> cpu{}; /// cpu of the process {not_set: any_cpu, N: cpu<N>}

      std::size_t buffer_size = 8192u * info::sys::page_size() + 1u;  /// the first page is not used
    };

    template<class...> class sampler;

    #if PERF_LINUX == 1
    /**
     * `perf record -e`
     */
    template<event_like... TEvents>
      //todo
      requires (not requires (TEvents events) { events.operation; } and ...)
    class sampler<TEvents...> {
      static constexpr auto sample_type =
        PERF_SAMPLE_IP                      /// instruction pointer
      | PERF_SAMPLE_READ                    /// events
      ;

      static constexpr auto read_format =
        PERF_FORMAT_ID                      /// event.id
      | PERF_FORMAT_GROUP                   /// group counters
      | PERF_FORMAT_TOTAL_TIME_ENABLED      /// multiplexing correction [optional]
      | PERF_FORMAT_TOTAL_TIME_RUNNING      /// multiplexing correction [optional]
      ;

      struct data {
        std::uint64_t ip{};                 /// instruction pointer
        std::uint64_t size{};               /// events.size
        std::uint64_t total_time_enabled{}; /// multiplexing correction [optional]
        std::uint64_t total_time_running{}; /// multiplexing correction [optional]
        struct {
          std::uint64_t value{};
          std::uint64_t id{};
        } values[sizeof...(TEvents)]{};     /// `verify(size == sizeof...(TEvents))`
      };

     public:
      constexpr sampler(sampler&&) = delete;
      constexpr sampler(const sampler&) = delete;
      constexpr explicit sampler(const TEvents&... events)
        : sampler{config{}, events...}
      { }
      template<class TConfig = config>
        requires requires (TConfig config) {
          config.skid;
          config.mode;
          config.interval;
          config.pid;
          config.cpu;
          config.buffer_size;
        }
      constexpr explicit sampler(const TConfig& config, const TEvents&... events)
        : buffer_size_{config.buffer_size} {
        const auto pid = config.pid ? *config.pid : 0;
        const auto cpu = config.cpu ? *config.cpu : -1;
        std::size_t i{};
        ([&] {
          perf_event_attr attr{};
          attr.type = events.type;
          attr.size = sizeof(perf_event_attr);
          attr.config = events.config[0u];
          attr.sample_type = sample_type;
          attr.read_format = read_format;
          attr.disabled = fd_ == -1;
          attr.exclude_user = not (config.mode & decltype(config.mode)::user);
          attr.exclude_kernel = not (config.mode & decltype(config.mode)::kernel);
          attr.exclude_hv = not (config.mode & decltype(config.mode)::hypervisor);
          attr.exclude_idle = not (config.mode & decltype(config.mode)::idle);
          attr.exclude_guest = not (config.mode & decltype(config.mode)::guest);
          attr.wakeup_events = 1;
          attr.config1 = events.config[1];
          attr.config2 = events.config[2];

          if (config.interval > 0) {
            attr.sample_freq = config.interval;
          } else {
            attr.sample_period = std::abs(config.interval);
          }

          auto fd = -1;
          for (auto pip = std::int32_t(config.skid); pip >= 0; --pip) { /// aim for minimal skid
            attr.precise_ip = pip;
            fd = syscall(__NR_perf_event_open, &attr, pid, cpu, fd_, 0);
            if (fd != -1) break;
          }
          verify(fd != -1, std::strerror(errno));
          if (fd_ == -1) {
            fd_ = fd; /// leader
          }

          ioctl(fd, PERF_EVENT_IOC_ID, &ids_[i++]);
        }(), ...);

        buffer_ = mmap(nullptr, buffer_size_, PROT_READ | PROT_WRITE, MAP_SHARED, fd_, 0);
        verify(buffer_ != MAP_FAILED, std::strerror(errno));
      }

      constexpr ~sampler() noexcept {
        if (fd_ == -1) {
          return;
        }
        verify(not close(fd_));
        verify(not munmap(buffer_, buffer_size_));
      }

      constexpr void start() {
        ioctl(fd_, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP);
        ioctl(fd_, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
      }

      constexpr void stop() {
        ioctl(fd_, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
      }

      template<class... Ts>
      [[nodiscard]] constexpr auto operator[](Ts...) const {
        constexpr auto value = [](const auto& v, const auto id) requires requires { std::begin(v); std::end(v); } {
          const auto found = std::find_if(std::begin(v), std::end(v), [&](const auto& data) { return data.id == id; });
          verify(found != std::end(v));
          return found->value;
        };

        std::tuple t{fixed_named<Ts::name(), std::vector<typename Ts::value_type>>{}...};
        const auto mmap_page = reinterpret_cast<perf_event_mmap_page*>(buffer_);
        const auto begin = reinterpret_cast<const std::byte*>(buffer_) + perf::info::sys::page_size();
        const auto end = begin + mmap_page->data_head;
        for (auto it = begin; it < end; it += reinterpret_cast<const perf_event_header*>(it)->size) {
          if (reinterpret_cast<const perf_event_header*>(it)->type != PERF_RECORD_SAMPLE) {
            continue;
          }

          const auto& data = *reinterpret_cast<const struct data*>(it + sizeof(perf_event_header));
          verify(data.size == ids_.size());
          verify(data.ip and data.total_time_enabled and data.total_time_running);
          const auto correction = double(data.total_time_enabled) / double(data.total_time_running);

          [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
            (std::get<Ns>(t).push_back(typename Ts::value_type{data.ip, value(data.values, ids_[Ns]) * correction}), ...);
          }(std::make_index_sequence<sizeof...(Ts)>{});

          verify(sizeof(data) + sizeof(std::uint64_t) == reinterpret_cast<const perf_event_header*>(it)->size);
        }
        return t;
      }

      [[nodiscard]] constexpr auto operator[]() const {
        return this->operator[](TEvents{}...);
      }

     private:
      std::size_t buffer_size_{};
      std::array<std::uint64_t, sizeof...(TEvents)> ids_{};
      std::int32_t fd_{-1};
      void* buffer_{};
    };

    /**
     * perf mem record
     */
    template<event_like... TEvents>
      requires (requires (TEvents events) { events.operation; } and ...)
    class sampler<TEvents...> {
      static constexpr auto sample_type =
        PERF_SAMPLE_IP                    /// instruction pointer
      | PERF_SAMPLE_ADDR                  /// address
      | PERF_SAMPLE_DATA_SRC              /// data source
      ;

      static constexpr auto read_format =
        PERF_FORMAT_ID                    /// event.id
      | PERF_FORMAT_GROUP                 /// group counters
      ;

      struct data {
        std::uint64_t ip{};               /// instruction pointer
        std::uint64_t dst{};              /// address
        std::uint64_t src{};              /// data source
      };

     public:
      constexpr sampler(sampler&&) = delete;
      constexpr sampler(const sampler&) = delete;
      constexpr explicit sampler(const TEvents&... events)
        : sampler{config{}, events...}
      { }
      template<class TConfig = config>
        requires requires (TConfig config) {
          config.skid;
          config.mode;
          config.interval;
          config.pid;
          config.cpu;
          config.buffer_size;
        }
      constexpr explicit sampler(const TConfig& config, const TEvents&... events)
        : buffer_size_{config.buffer_size} {
        const auto pid = config.pid ? *config.pid : 0;
        const auto cpu = config.cpu ? *config.cpu : -1;
        auto fd_aux = -1;
        const auto setup = [&](const auto& event) {
          perf_event_attr attr{};
          attr.type = event.type,
          attr.size = sizeof(perf_event_attr);
          attr.config = event.config[0u];
          attr.sample_type = sample_type;
          attr.read_format = read_format;
          attr.disabled = fd_ == -1;
          attr.exclude_user = not (config.mode & decltype(config.mode)::user);
          attr.exclude_kernel = not (config.mode & decltype(config.mode)::kernel);
          attr.exclude_hv = not (config.mode & decltype(config.mode)::hypervisor);
          attr.exclude_idle = not (config.mode & decltype(config.mode)::idle);
          attr.exclude_guest = not (config.mode & decltype(config.mode)::guest);
          attr.config1 = event.config[1u];
          attr.config2 = event.config[2u];

          if (config.interval > 0) {
            attr.sample_freq = config.interval;
          } else {
            attr.sample_period = std::abs(config.interval);
          }

          auto fd = -1;
          for (auto pip = std::int32_t(config.skid); pip >= 0; --pip) { /// aim for minimal skid
            attr.precise_ip = pip;
            fd = syscall(__NR_perf_event_open, &attr, pid, cpu, fd_, 0);
            if (fd != -1) break;
          }
          verify(fd != -1, std::strerror(errno));
          if (fd_ != -1 and fd_aux == -1) {
            fd_aux = fd;
          }
          if (fd_ == -1) {
            fd_ = fd; /// leader
          }
        };

        /**
         * https://lore.kernel.org/lkml/1612296553-21962-3-git-send-email-kan.liang@linux.intel.com
         * - required for `alderlake`, `sapphirerapids
         */
        if (auto&& aux = perf::info::sys::hw<"event=%zx,umask=%zx">("/sys/bus/event_source/devices/cpu/events/mem-loads-aux").or_else(
          [] { return perf::info::sys::hw<"event=%zx,umask=%zx">("/sys/bus/event_source/devices/cpu_core/events/mem-loads-aux"); }); aux) {
          struct event { std::uint32_t type{}; std::array<std::uint64_t, 3u> config{}; };
          setup(event{PERF_TYPE_RAW, {((*aux)[1u] << CHAR_BIT) | (*aux)[0u], aux->size() == 3u ? (*aux)[2u] : std::uint64_t{}}});
        }

        (setup(events), ...);

        buffer_ = mmap(nullptr, buffer_size_, PROT_READ | PROT_WRITE, MAP_SHARED, fd_aux == -1 ? fd_ : fd_aux, 0);
        verify(buffer_ != MAP_FAILED, std::strerror(errno));
      }

      constexpr ~sampler() noexcept {
        if (fd_ == -1) {
          return;
        }
        verify(not close(fd_));
        verify(not munmap(buffer_, buffer_size_));
      }

      constexpr void start() {
        ioctl(fd_, PERF_EVENT_IOC_RESET, PERF_IOC_FLAG_GROUP);
        ioctl(fd_, PERF_EVENT_IOC_ENABLE, PERF_IOC_FLAG_GROUP);
      }

      constexpr void stop() {
        ioctl(fd_, PERF_EVENT_IOC_DISABLE, PERF_IOC_FLAG_GROUP);
      }

      template<class... Ts>
      [[nodiscard]] constexpr auto operator[](Ts...) const {
        std::tuple t{fixed_named<Ts::name(), std::vector<typename Ts::value_type>>{}...};
        const auto mmap_page = reinterpret_cast<perf_event_mmap_page*>(buffer_);
        const auto begin = reinterpret_cast<const std::byte*>(buffer_) + perf::info::sys::page_size();
        const auto end = begin + mmap_page->data_head;
        for (auto it = begin; it < end; it += reinterpret_cast<const perf_event_header*>(it)->size) {
          if (reinterpret_cast<const perf_event_header*>(it)->type != PERF_RECORD_SAMPLE) {
            continue;
          }

          const auto& data = *reinterpret_cast<const struct data*>(it + sizeof(perf_event_header));
          const perf_mem_data_src src{data.src};

          [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
            (std::get<Ns>(t).push_back(typename Ts::value_type{data, src}), ...);
          }(std::make_index_sequence<sizeof...(Ts)>{});
        }

        return t;
      }

      [[nodiscard]] constexpr auto operator[]() const {
        return this->operator[](TEvents{}...);
      }

      std::size_t buffer_size_{};
      void* buffer_{};
      std::int32_t fd_{-1};
    };

    template<> class sampler<> {
     public:
      constexpr explicit sampler(auto&&...) { }
      constexpr void start() { }
      constexpr void stop() { }
      [[nodiscard]] constexpr auto operator[](auto...) const {
        return std::tuple{};
      }
    };

    template<event_like... TEvents>
    sampler(const TEvents&...) -> sampler<TEvents...>;

    template<class TConfig = config, event_like... TEvents>
      requires requires (TConfig config) {
        config.skid;
        config.mode;
        config.interval;
        config.pid;
        config.cpu;
        config.buffer_size;
      }
    sampler(const TConfig&, const TEvents&...) -> sampler<TEvents...>;

    /**
     * https://perfmon-events.intel.com # intel's list of events per architecture
     */
    inline namespace event {
      namespace aux {
        struct mem {
          std::uint64_t ip{};
          std::uint64_t dst{};
          std::uint64_t src{};

          struct cache {
            enum {
              hit       = 0b000001,
              miss      = 0b000010,
              uncached  = 0b000100,
            } access{};
            enum {
              L1        = 0b000001,
              L2        = 0b000010,
              L3        = 0b000100,
              LFB       = 0b001000, /// line fill buffer
              RAM       = 0b010000,
              IO        = 0b100000,
            } level{};
          } cache{};

          struct tlb {
            enum {
              hit       = 0b000001,
              miss      = 0b000010,
            } access{};
            enum {
              L1        = 0b000001,
              L2        = 0b000010,
              WK        = 0b000100,
              OS        = 0b001000,
            } level{};
          } tlb{};

          /**
           * https://en.wikipedia.org/wiki/MESI_protocol
           * https://en.wikipedia.org/wiki/MOESI_protocol
           */
          struct snoop {
            enum {
              none      = 0b000001, /// resolved in local cache
              hit       = 0b000010, /// data found in peer core's cache
              miss      = 0b000100, /// snoop was issued but no core had the data
              modify    = 0b001000, /// data found modified in another cache
              fwd       = 0b010000, /// data was forwarded
              peer      = 0b100000, /// remote cache access
            } access{};
          } snoop{};

          constexpr mem() = default;
          constexpr explicit mem(const auto& data, const auto& src)
            : ip{data.ip}
            , dst{data.dst}
            , src{data.src}
            , cache{
              .access = decltype(cache::access)(
                   to(src.mem_lvl, PERF_MEM_LVL_UNC, cache::uncached)
                 | to(src.mem_lvl, PERF_MEM_LVL_HIT, cache::hit)
                 | to(src.mem_lvl, PERF_MEM_LVL_MISS, cache::miss)
               ),
              .level = decltype(cache::level)(
                   to(src.mem_lvl, PERF_MEM_LVL_L1, cache::L1)
                 | to(src.mem_lvl, PERF_MEM_LVL_L2, cache::L2)
                 | to(src.mem_lvl, PERF_MEM_LVL_L3, cache::L3)
                 | to(src.mem_lvl, PERF_MEM_LVL_LFB, cache::LFB)
                 | to(src.mem_lvl, PERF_MEM_LVL_LOC_RAM, cache::RAM)
                 | to(src.mem_lvl, PERF_MEM_LVL_IO, cache::IO)
               )
              }
            , tlb{
              .access = decltype(tlb::access)(
                   to(src.mem_dtlb, PERF_MEM_TLB_HIT, tlb::hit)
                 | to(src.mem_dtlb, PERF_MEM_TLB_MISS, tlb::miss)
               ),
              .level = decltype(tlb::level)(
                   to(src.mem_dtlb, PERF_MEM_TLB_L1, tlb::L1)
                 | to(src.mem_dtlb, PERF_MEM_TLB_L2, tlb::L2)
                 | to(src.mem_dtlb, PERF_MEM_TLB_WK, tlb::WK)
                 | to(src.mem_dtlb, PERF_MEM_TLB_OS, tlb::OS)
               )
              }
            , snoop{
              .access = decltype(snoop::access)(
                   to(src.mem_snoop, PERF_MEM_SNOOP_NONE, snoop::none)
                 | to(src.mem_snoop, PERF_MEM_SNOOP_HIT, snoop::hit)
                 | to(src.mem_snoop, PERF_MEM_SNOOP_MISS, snoop::miss)
                 | to(src.mem_snoop, PERF_MEM_SNOOP_HITM, snoop::hit | snoop::modify)
                 | to(src.mem_snoopx, PERF_MEM_SNOOPX_FWD, snoop::fwd)
                 #ifdef PERF_MEM_SNOOPX_PEER
                 | to(src.mem_snoopx, PERF_MEM_SNOOPX_PEER, snoop::peer)
                 #endif
               )
              }
          { }

          static constexpr auto to = [](const auto& value, const auto lhs, const auto rhs) {
            return (value & lhs) ? rhs : decltype(rhs){};
          };
        };

        struct event {
          using value_type = struct info {
            std::uint64_t ip{};
            strong_alias<double> value{};
          };
          std::uint32_t type{};
          std::array<std::uint64_t, 3u> config{}; /// perf_event_attr.{config1, config2, config3}
        };

        struct mem_event {
          using value_type = mem;
          std::uint32_t type{};
          struct {
            std::array<std::uint64_t, 3u>(*fn)(){};
            [[nodiscard]] constexpr operator auto() const { return fn(); }
            [[nodiscard]] constexpr auto operator [](std::size_t i) const { return fn()[i]; }
          } config{};
          std::uint32_t operation{};
        };

        template<fixed_string Name, fixed_string Fmt = "event=%zx,umask=%zx">
        inline constexpr auto config = [] -> std::array<std::uint64_t, 3u> {
          auto&& cfg = perf::info::sys::hw<Fmt>(std::format("/sys/bus/event_source/devices/cpu/events/{}", std::string_view(Name))).or_else(
            [] { return perf::info::sys::hw<Fmt>(std::format("/sys/bus/event_source/devices/cpu_core/events/{}", std::string_view(Name))); }
          );
          verify(cfg.has_value(), std::format("'{}' not found!", std::string_view(Name)));
          return {((*cfg)[1u] << CHAR_BIT) | (*cfg)[0u], cfg->size() == 3u ? (*cfg)[2u] : std::uint64_t{}};
        };
      } // namespace aux

      /**
       * perf list # shows available events
       * perf stat -vv -e {event} sleep 0 # finds config values for given event
       */
      inline constexpr event_like auto cpu_clock = constant<make_fixed_named<"record.cpu_clock">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CPU_CLOCK}})>{};
      inline constexpr event_like auto task_clock = constant<make_fixed_named<"record.task_clock">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_TASK_CLOCK}})>{};
      inline constexpr event_like auto page_faults = constant<make_fixed_named<"record.page_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS}})>{};
      inline constexpr event_like auto faults = constant<make_fixed_named<"record.faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS}})>{};
      inline constexpr event_like auto major_faults = constant<make_fixed_named<"record.major_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS_MAJ}})>{};
      inline constexpr event_like auto minor_faults = constant<make_fixed_named<"record.minor_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_PAGE_FAULTS_MIN}})>{};
      inline constexpr event_like auto alignment_faults = constant<make_fixed_named<"record.alignment_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_ALIGNMENT_FAULTS}})>{};
      inline constexpr event_like auto emulation_faults = constant<make_fixed_named<"record.emulation_faults">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_EMULATION_FAULTS}})>{};
      inline constexpr event_like auto context_switches = constant<make_fixed_named<"record.context_switches">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CONTEXT_SWITCHES}})>{};
      inline constexpr event_like auto cgroup_switches = constant<make_fixed_named<"record.cgroup_switches">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CGROUP_SWITCHES}})>{};
      inline constexpr event_like auto cpu_migrations = constant<make_fixed_named<"record.cpu_migrations">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CPU_MIGRATIONS}})>{};
      inline constexpr event_like auto migrations = constant<make_fixed_named<"record.migrations">(aux::event{PERF_TYPE_SOFTWARE, {PERF_COUNT_SW_CPU_MIGRATIONS}})>{};
      inline constexpr event_like auto cycles = constant<make_fixed_named<"record.cycles">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CPU_CYCLES}})>{};
      inline constexpr event_like auto instructions = constant<make_fixed_named<"record.instructions">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_INSTRUCTIONS}})>{};
      inline constexpr event_like auto branch_misses = constant<make_fixed_named<"record.branch_misses">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BRANCH_MISSES}})>{};
      inline constexpr event_like auto bus_cycles = constant<make_fixed_named<"record.bus_cycles">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BUS_CYCLES}})>{};
      inline constexpr event_like auto cache_misses = constant<make_fixed_named<"record.cache_misses">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CACHE_MISSES}})>{};
      inline constexpr event_like auto cache_references = constant<make_fixed_named<"record.cache_references">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CACHE_REFERENCES}})>{};
      inline constexpr event_like auto branches = constant<make_fixed_named<"record.branches">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BRANCH_INSTRUCTIONS}})>{};
      inline constexpr event_like auto branch_instructions = constant<make_fixed_named<"record.branch_instructions">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_BRANCH_INSTRUCTIONS}})>{};
      inline constexpr event_like auto stalled_cycles_backend = constant<make_fixed_named<"record.stalled_cycles_backend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_BACKEND}})>{};
      inline constexpr event_like auto idle_cycles_backend = constant<make_fixed_named<"record.idle_cycles_backend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_BACKEND}})>{};
      inline constexpr event_like auto stalled_cycles_frontend = constant<make_fixed_named<"record.stalled_cycles_frontend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_FRONTEND}})>{};
      inline constexpr event_like auto idle_cycles_frontend = constant<make_fixed_named<"record.idle_cycles_frontend">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_STALLED_CYCLES_FRONTEND}})>{};
      inline constexpr event_like auto llc_misses = constant<make_fixed_named<"record.LLC_misses">(aux::event{PERF_TYPE_HARDWARE, {PERF_COUNT_HW_CACHE_MISSES}})>{};
      inline constexpr event_like auto l1_misses = constant<make_fixed_named<"record.L1_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto l1_dcache_loads = constant<make_fixed_named<"record.L1_dcache_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto l1_dcache_load_misses = constant<make_fixed_named<"record.L1_dcache_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1D | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto l1_icache_loads = constant<make_fixed_named<"record.L1_icache_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1I | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto l1_icache_load_misses = constant<make_fixed_named<"record.L1_icache_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_L1I | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto dtlb_loads = constant<make_fixed_named<"record.dTLB_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_DTLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto dtlb_load_misses = constant<make_fixed_named<"record.dTLB_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_DTLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto itlb_loads = constant<make_fixed_named<"record.iTLB_loads">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_ITLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16u)}})>{};
      inline constexpr event_like auto itlb_load_misses = constant<make_fixed_named<"record.iTLB_load_misses">(aux::event{PERF_TYPE_HW_CACHE, {PERF_COUNT_HW_CACHE_ITLB | (PERF_COUNT_HW_CACHE_OP_READ << 8u) | (PERF_COUNT_HW_CACHE_RESULT_MISS << 16u)}})>{};
      inline constexpr event_like auto mem_loads = constant<make_fixed_named<"record.mem_loads">(aux::mem_event{PERF_TYPE_RAW, {aux::config<"mem-loads", "event=%zx,umask=%zx,ldlat=%zd">}, PERF_MEM_OP_LOAD})>{};
      inline constexpr event_like auto mem_stores = constant<make_fixed_named<"record.mem_stores">(aux::mem_event{PERF_TYPE_RAW, {aux::config<"mem-stores">}, PERF_MEM_OP_STORE})>{};
    } // namespace event
    #endif // PERF_LINUX
  } // namespace record

  /**
   * tracing # processor instructions
   * - https://perfwiki.github.io/main/perf-tools-support-for-intel-processor-trace
   * - https://github.com/intel/libipt
   *
   * `libipt` is distributed under `BSD-3-Clause` license
   * - https://github.com/intel/libipt/blob/master/LICENSE
   */
  namespace trace {
    template<class T>
    concept event_like = requires (T t) {
      requires requires (const typename T::value_type& data) { data.ip; };
      t.name;
      t.value;
    };

    struct config {
      struct vendor { /// used for timing calibration
        std::string name = info::cpu::name();
        std::uint16_t family = info::cpu::version().family;
        std::uint8_t model = info::cpu::version().model;
        std::uint8_t stepping = info::cpu::version().stepping;
      } vendor{};

      enum mode {
        user        = 0b00001,
        kernel      = 0b00010,
        hypervisor  = 0b00100,
        idle        = 0b01000,
        guest       = 0b10000,
      } mode = mode::user;

      struct {
        std::optional<std::uint64_t> begin{};
        std::optional<std::uint64_t> end{};
      } region{};

      std::optional<std::int32_t> pid{};  /// pid of the process {not_set: current process, N: process<N>}
      std::optional<std::int32_t> cpu{};  /// cpu of the process {not_set: any_cpu, N: cpu<N>}

      std::size_t buffer_size = 512u * info::sys::page_size() + 1u; /// the first page is not used
      std::size_t aux_size = 2048u * info::sys::page_size(); /// intel_pt instructions are stored under aux buffer in compressed format
    };

    #if PERF_LINUX == 1 and PERF_INTEL == 1
    /**
     * `perf record -e intel_pt/`
     * https://perfwiki.github.io/main/perf-tools-support-for-intel-processor-trace
     */
    template<event_like... TEvents>
    class tracer {
     public:
      constexpr tracer(tracer&&) = delete;
      constexpr tracer(const tracer&) = delete;
      constexpr explicit tracer(const TEvents&... events)
        : tracer{config{}, events...}
      { }
      template<class TConfig = config>
        requires requires (TConfig config) {
          config.vendor.name; config.vendor.family; config.vendor.model; config.vendor.stepping;
          config.mode;
          config.region.begin; config.region.end;
          config.cpu; config.pid;
          config.buffer_size; config.aux_size;
        }
      constexpr explicit tracer(const TConfig& config, const TEvents&... events)
        : cpu_{
          .vendor = __builtin_cpu_is("intel") ? pcv_intel : pcv_unknown,
          .family = config.vendor.family,
          .model = config.vendor.model,
          .stepping = config.vendor.stepping}
        , region_{config.region.begin, config.region.end}
        , buffer_size_{config.buffer_size}
        , aux_size_{config.aux_size} {
        [&]<class T, class... Ts>(const T& trace, const Ts&... events) {
          const auto pid = config.pid ? *config.pid : 0;
          const auto cpu = config.cpu ? *config.cpu : -1;
          perf_event_attr attr{};
          attr.type = static_cast<std::uint32_t>(trace.value);
          attr.size = sizeof(perf_event_attr);
          attr.config = ((1ull << events.value) | ... | 0u);
          attr.disabled = true;
          attr.exclude_user = not (config.mode & decltype(config.mode)::user);
          attr.exclude_kernel = not (config.mode & decltype(config.mode)::kernel);
          attr.exclude_hv = not (config.mode & decltype(config.mode)::hypervisor);
          attr.exclude_idle = not (config.mode & decltype(config.mode)::idle);
          attr.exclude_guest = not (config.mode & decltype(config.mode)::guest);

          fd_ = syscall(__NR_perf_event_open, &attr, pid, cpu, -1, 0);
          verify(fd_ != -1);

          buffer_ = mmap(nullptr, buffer_size_, PROT_WRITE, MAP_SHARED, fd_, 0);
          verify(buffer_ != MAP_FAILED);

          auto header = reinterpret_cast<perf_event_mmap_page*>(buffer_);
          header->aux_offset = header->data_offset + header->data_size;
          header->aux_size = aux_size_;

          aux_ = mmap(nullptr, header->aux_size, PROT_READ, MAP_SHARED, fd_, header->aux_offset);
          verify(aux_ != MAP_FAILED);
        }(events...);
      }

      constexpr ~tracer() noexcept {
        if (fd_ == -1) {
          return;
        }
        verify(not close(fd_));
        verify(not munmap(aux_, aux_size_));
        verify(not munmap(buffer_, buffer_size_));
      }

      constexpr void start() {
        ioctl(fd_, PERF_EVENT_IOC_RESET, 0);
        ioctl(fd_, PERF_EVENT_IOC_ENABLE, 0);
      }

      constexpr void stop() {
        ioctl(fd_, PERF_EVENT_IOC_DISABLE, 0);
      }

      template<class... Ts>
      [[nodiscard]] constexpr auto operator[](Ts...) const {
        /// https://github.com/intel/libipt/blob/master/doc/man/pt_config.3.md
        pt_config config{};
        config.size = sizeof(pt_config);
        config.begin = reinterpret_cast<std::uint8_t*>(aux_);
        config.end = reinterpret_cast<std::uint8_t*>(aux_) + aux_size_;
        config.cpu = cpu_;

        auto status = pt_cpu_errata(&config.errata, &config.cpu);
        verify(status >= 0, pt_errstr(pt_errcode(status)));

        auto *decoder = pt_insn_alloc_decoder(&config);
        scoped _{
          .on_entry = [&] { verify(bool(decoder)); },
          .on_exit  = [&] { pt_insn_free_decoder(decoder); },
        };

        auto *image = pt_insn_get_image(decoder);
        status = pt_image_set_callback(image, memcpy, nullptr);
        verify(status >= 0, pt_errstr(pt_errcode(status)));

        status = pt_insn_sync_forward(decoder);
        verify(status >= 0, pt_errstr(pt_errcode(status)));

        /// https://github.com/intel/libipt/blob/master/doc/man/pt_insn_next.3.md
        pt_insn instruction{};
        std::tuple data{fixed_named<Ts::name(), std::vector<typename Ts::value_type>>{}...};

        auto trace = not region_.begin.has_value();
        while (status != -pte_eos) {
          while (status & pts_event_pending) {
            pt_event event{};
            status = pt_insn_event(decoder, &event, sizeof(event));
            verify(status >= 0, pt_errstr(pt_errcode(status)));
          }

          status = pt_insn_next(decoder, &instruction, sizeof(instruction));
          if (status == -pte_eos) {
            break;
          }
          verify(status >= 0, pt_errstr(pt_errcode(status)));
          //std::uint64_t tsc{};
          //if (status = pt_insn_time(static_cast<pt_insn_decoder*>(decoder), &tsc, nullptr, nullptr); status) {
            //break;
          //}
          std::apply([&](auto&... ts) {
            ([&] {
              if (region_.begin and instruction.ip == *region_.begin) {
                trace = true;
              }
              if (trace and region_.end and instruction.ip == region_.end) {
                trace = false;
              }
              if (trace) {
                ts.push_back({.ip = instruction.ip, .size = instruction.size});
              }
            }(), ...);
          }, data);
        }

        return data;
      }

      [[nodiscard]] constexpr auto operator[]() const {
        return this->operator[](TEvents{}...);
      }

     private:
      static constexpr auto memcpy =
        [](std::uint8_t* buffer, std::size_t size, const pt_asid*,
           std::uint64_t address, [[maybe_unused]] void* context) -> int {
          std::memcpy(buffer, reinterpret_cast<void*>(address), size);
          return size;
        };

      pt_cpu cpu_{};
      struct {
        std::optional<std::uint64_t> begin{};
        std::optional<std::uint64_t> end{};
      } region_{};
      std::size_t buffer_size_{};
      std::size_t aux_size_{};
      std::int32_t fd_{-1};
      void* buffer_{};
      void* aux_{};
    };

    template<> class tracer<> {
     public:
      constexpr explicit tracer(auto&&...) { }
      constexpr void start() { }
      constexpr void stop() { }
      [[nodiscard]] constexpr auto operator[](auto...) const {
        return std::tuple{};
      }
    };

    inline namespace event {
      namespace aux {
        struct event {
          using value_type = struct instruction {
            std::uint64_t ip{};
            std::uint64_t size{};
          };
          struct {
            std::size_t(*fn)(){};
            [[nodiscard]] constexpr operator auto() const { return fn(); }
          } value{};
        };

        template<fixed_string Name, fixed_string Fmt = "%zd">
        inline constexpr auto config = [] {
          return info::sys::hw<Fmt>(std::format("/sys/bus/event_source/devices/intel_pt/{}", std::string_view(Name))).value()[0u];
        };
      } // namespace aux

      inline constexpr event_like auto instructions = constant<make_fixed_named<"trace.instructions">(aux::event{aux::config<"type">})>{};
      inline constexpr event_like auto cycles = constant<make_fixed_named<"trace.cycles">(aux::event{aux::config<"format/tsc", "config:%zd">})>{};
    } // namespace event
    #endif // PERF_LINUX and PERF_INTEL
  } // namespace trace
} // namespace prof

inline namespace engine {
  /**
   * name of `fn(args...)`
   */
  template<class T>
  struct name {
    constexpr name() = default;
    constexpr explicit name(auto&& runner, auto&& fn, auto&&... ts)
      requires requires { runner.name(); }
      : runner{runner.name()}
      , function{fn_name(fn)}
      , parameters{param_name(ts)...}
    { }

    [[nodiscard]] constexpr auto operator<=>(const name&) const -> bool = default;

    T runner{};
    T function{};
    std::vector<T> parameters{};

   private:
    static constexpr auto fn_name = [](auto&& fn) -> T {
      if constexpr (requires { fn.name(); }) {
        return T(fn.name());
      } else {
        const auto& name = [&] -> T {
          #if PERF_LLVM == 1
          const auto& qualified_name = info::bin::addr_to_fn_name(
            info::proc::self::name(),
            std::uint64_t(&fn) - info::proc::self::base_address()
          );
          verify(qualified_name.has_value());
          return qualified_name->contains("(")
            ? qualified_name->substr(0u, qualified_name->find("("))
            : *qualified_name;
          #elif __has_feature(reflection) /// `reflection for C++26` # https://wg21.link/p2996
          return T(identifier_of(^^fn));
          #else
          return T(typeid(fn).name());
          #endif
        }();

        return name.contains(":")
          ? name.substr(name.find_last_of(":") + 1u)
          : name;
      }
    };

    static constexpr auto param_name = [](auto&& t) -> T {
      if constexpr (requires { T(t.name()); }) {
        return T(t.name());
      } else if constexpr (requires { T(std::format("{}", t)); }) {
        return T(std::format("{}", t));
      } else if constexpr (requires { T(t); }) {
        return T(t);
      } else {
        #if __has_feature(reflection) /// `reflection for C++26` # https://wg21.link/p2996
        return T(identifier_of(^^T));
        #else
        return T((typeid(t).name()));
        #endif // reflection
      }
    };
  };

  /**
   * type-safe/type-erased data storage
   */
  template<class TKey = std::string, class TMapped = std::any>
  struct dataset {
    template<class... Ts>
    constexpr auto& add(const std::tuple<Ts...>& t) {
      std::apply([&](const auto&... ts) { (add(ts), ...); }, t);
      return *this;
    }

    template<class T>
    constexpr auto& add(const T& t) {
      using underlying_type = typename std::remove_cvref_t<T>::underlying_type;
      if constexpr (auto&& data = data_[TKey(t.name())]; requires { t.begin(); t.end(); }) {
        // if(data.has_value()); // todo merge
        data = static_cast<const underlying_type&>(t);
      } else if (data.has_value()) {
        std::any_cast<std::vector<underlying_type>&>(data).push_back(t);
      } else {
        data = std::vector<underlying_type>{t};
      }
      return *this;
    }

    template<class... Ts>
    constexpr auto& sub(const std::tuple<Ts...>& t) {
      std::apply([&](const auto&... ts) { (sub(ts), ...); }, t);
      return *this;
    }

    template<class T>
    constexpr auto& sub(const T& t) {
      if constexpr (requires (const typename T::underlying_type& value) { t.name(); value - t; }) {
        auto& data = std::any_cast<
          std::vector<typename T::underlying_type>&
        >(data_[TKey(t.name())]).back();
        data = std::max(
          typename T::underlying_type{},
          typename T::underlying_type(data - t)
        );
      }
      return *this;
    }

    constexpr auto& operator+=(const auto& t) { return add(t); }
    constexpr auto& operator-=(const auto& t) { return sub(t); }

    template<class... Ts>
      requires (requires { Ts::name(); } and ...)
    [[nodiscard]] constexpr decltype(auto) operator[](const Ts&... ts) const {
      const auto make = [&]<class T>(const T& t) -> decltype(auto) {
        if constexpr (requires { typename T::value_type; }) {
          verify(data_.contains(TKey(T::name())), std::format("'{}' not found!", TKey(T::name())));
          return make_fixed_named<T::name()>(
            std::any_cast<const std::vector<typename T::value_type>&>(data_.at(TKey(t.name())))
          );
        } else if constexpr (requires { t(*this); }) {
          return t(*this);
        }
      };
      return std::tuple{make(ts)...};
    }

   private:
    std::unordered_map<TKey, TMapped> data_{};
  };

  /**
   * type-safe/meta-data storage
   */
  template<class TName, class TData> struct result { TName name{}; TData data{}; };
  template<class TKey = std::string, class TMapped = dataset<TKey, std::any>>
  struct metadata {
    constexpr decltype(auto) emplace(TKey&& name, TMapped&& data) {
      if (auto d = std::find_if(data_.begin(), data_.end(), [&](const auto& data) { return data.name == name; }); d == data_.end()) {
        return data_.emplace_back(std::move(name), std::move(data));
      } else {
        return (*d);
      }
    }

    [[nodiscard]] constexpr auto operator[](const auto&... ts) const
      requires (requires { ts.name(); } and ...) {
      std::vector<result<TKey, decltype(std::declval<TMapped&>()[ts...])>> results{};
      results.reserve(data_.size());
      std::transform(data_.begin(), data_.end(), std::back_inserter(results), [&](const auto& kv) {
        return result{kv.name, kv.data[ts...]};
      });
      return results;
    }

   private:
    std::vector<result<TKey, TMapped>> data_{};
  };

  template<auto Tag = []{},
    class TName = name<std::string>,
    class TMetadata = metadata<TName, dataset<std::string, std::any>>, class... TRunners>
  class runner {
    template<class... Ts>
    [[nodiscard]] static constexpr auto ops() -> bool {
      return ([] {
        if constexpr (requires { typename Ts::element_type; }) { /// compound operator
          []<class... TArgs>(mp::type_list<TArgs...>) {
            return (ops<TArgs>() and  ...);
          }(typename Ts::element_type{});
        } else {
          static_assert(mp::version<Tag, Ts>() >= 0ul);
        }
        return true;
      }() and ...);
    }

   public:
    constexpr runner(runner&&) = delete;
    constexpr runner(const runner&) = delete;
    constexpr explicit runner(TRunners&&... runners)
      : runners_{std::forward<TRunners>(runners)...}
    { }

    template<class Fn, class... Ts>
      requires (sizeof...(Ts) == perf::mp::size<
        typename mp::function_traits<std::remove_cvref_t<Fn>>::args_type>
      ) /// non-constexpr is needed for lazy population of `ops` [optional]
    auto operator()(Fn&& fn, Ts&&... ts) -> const TMetadata& {
      std::apply([&](auto&&... runners) {
        constexpr auto ops = mp::version<Tag>();
        ([&] {
          if constexpr (requires { runners.name(); }) {
            metadata_.emplace(TName{runners, fn, ts...}, [&] {
              if constexpr (requires { runners.template operator()<ops>(fn, ts...); }) {
                return runners.template operator()<ops>(fn, ts...);
              } else {
                return runners(fn, ts...);
              }
            }());
          } else if constexpr (requires { runners.template operator()<ops>(fn, ts...); }) {
            if constexpr (std::ranges::range<decltype(runners.template operator()<ops>(fn, ts...))>) {
              for (auto&& data : runners.template operator()<ops>(fn, ts...)) {
                metadata_.emplace(TName{data, fn, ts...}, std::move(data));
              }
            } else {
              runners.template operator()<ops>(fn, ts...);
            }
          } else {
            if constexpr (std::ranges::range<decltype(runners(fn, ts...))>) {
              for (auto&& data : runners(fn, ts...)) {
                metadata_.emplace(TName{data, fn, ts...}, std::move(data));
              }
            } else {
              runners(fn, ts...);
            }
          }
        }(), ...);
      }, runners_);
      return metadata_;
    }

    template<class... Ts> requires (ops<Ts...>()) /// `ops` register used operators
    [[nodiscard]] constexpr decltype(auto) operator[](const Ts&... ts) const {
      return metadata_[ts...];
    }

   private:
    std::tuple<TRunners...> runners_{};
    TMetadata metadata_{};
  };
} // namespace engine

/**
 * benchmarking
 */
namespace bench {
  namespace utility {
    template<class Fn, auto Debug = true>
    concept debug_like = []<class... TArgs>(mp::type_list<TArgs...>) {
      return requires (Fn fn, TArgs... args) { fn.template operator()<Debug>(args...); };
    }(typename mp::function_traits<Fn>::args_type{});

    inline constexpr auto debug = []<auto Debug = true, class Fn>(Fn fn)
      requires debug_like<Fn, Debug> {
        return [fn]<class... TArgs>(mp::type_list<TArgs...>) {
          return [fn](TArgs... args) { /// qualified types
            return fn.template operator()<Debug>(args...);
          };
        }(typename mp::function_traits<Fn>::args_type{});
      };

    inline constexpr auto overhead = []<class Fn>(Fn) {
      return []<class... TArgs>(mp::type_list<TArgs...>) {
        return [](TArgs...) { };
      }(typename mp::function_traits<Fn>::args_type{});
    };

    template<class T>
    inline constexpr auto arg = [](auto&& t, auto n) -> decltype(auto) {
      if constexpr (requires { t(n); }) {
        return t(n);
      } else {
        return std::vector<std::remove_cvref_t<T>>(n, t); /// passed directly, .ex 1, 'string'
      }
    };
  } // namespace utility

  inline constexpr auto baseline = [](auto&& fn) {
    return make_fixed_named<"baseline">(fn);
  };

  namespace policy {
    struct seq { };
    struct unroll { };
    struct unseq { };
    struct par {
      std::vector<std::thread> threads{};

      constexpr auto operator()() {
        std::barrier sync_point(threads.size());
        for (auto i = 0u; i < threads.size(); ++i) {
          threads.emplace_back([&] {
            sync_point.arrive_and_wait();
            //latency(fn, ts...);
          });
        }

        // cpu.time  = threads.size() * cpu.time
        // real.time = threads.size() * cpu.time
        for (auto& thread : threads) {
          thread.join();
        }
      }
    };
    struct omp {
      // requires omp
    };
    struct cuda {
      // requires cuda-clang
    };
  } // namespace policy

  namespace detail {
    struct iterations {
      std::optional<std::size_t> min{};
      std::optional<std::size_t> max{};
      /// time budget per single run to estimate required operations count
      std::optional<std::chrono::duration<double, std::milli>> time_budget{};
    };

    struct samples {
      std::optional<std::size_t> min{};
      std::optional<std::size_t> max{};
      /// confidence level to estimate required number of samples, ex. `.95` equals 95% confidence
      std::optional<double> confidence_level{};
    };
  } // namespace config

  /**
   * Strict sequential execution via data dependency chain # no out of order, no speculative
   * @code
   * constexpr auto latency = [](auto&& fn, auto&&... ts) {
   *   auto checksum = 0u;
   *   perf::code::align(64u); for (auto i = 0u; i < iterations; ++i) {
   *     checksum ^= fn(checksum ^ ts...); // data dependency
   *     perf::memory::synchronize(); // required if there is a memory write
   *   }
   *   perf::compiler::prevent_elision(checksum);
   * };
   *
   * section: latency
   *  invoke<add>:
   *   add %esi,%edi
   *   xor %edi,0x1e994(%rip) /// data dependency (edi), memory write
   *   ret
   *
   *  invoke<overhead<add>>:
   *   xor %edi,0x1e994(%rip)
   *   ret
   *
   * section: .text
   *  bench:
   *   ...        // loop (aligned: 64u)
   *   call *%r12 // call via function pointer (invoke<add> or invoke<overhead<add>>)
   *   mfence     // wait for the expected memory write
   *   ...        // loop continues
   * @endcode
   */
  template<
    class TIteartions = initialized<
      detail::iterations,
      1'00,
      1'000'000,
      converted<std::optional<std::chrono::duration<double, std::milli>>, 1.>{}
    >,
    class TSamples = initialized<detail::samples, 30, 100, .95>,
    class TSetup = decltype([]{}),
    class TBefore = decltype([]{}),
    class TAfter = decltype([]{}),
    class TTeardown = decltype([]{})>
  struct latency {
    class fn_entry_tag;
    class fn_exit_tag;

    TIteartions iterations{};
    TSamples samples{};
    TSetup setup{};
    TBefore before{};
    TAfter after{};
    TTeardown teardown{};

    template<mp::type_list Ops>
    [[nodiscard]] constexpr auto operator()(auto&& fn, auto&&... ts) const {
      dataset data{};

      auto&& timer = std::apply(
        [](const auto&... ts) { return perf::stat::timer{ts...}; },
        mp::filter<[]<class T> { return perf::stat::time_like<T>; }, std::tuple>(Ops)
      );
      #if PERF_LINUX == 1
      auto&& counter = std::apply(
        [](const auto&... ts) { return perf::stat::counter{ts...}; },
        mp::filter<[]<class T> { return perf::stat::event_like<T>; }, std::tuple>(Ops)
      );
      auto&& sampler = std::apply(
        [](const auto&... ts) { return perf::record::sampler{ts...}; },
        mp::filter<[]<class T> { return perf::record::event_like<T>; }, std::tuple>(Ops)
      );
      #endif // PERF_LINUX

      auto&& t = profiler{sampler, counter, timer};

      constexpr auto has_tsc = []<class... Ts>(mp::type_list<Ts...>) {
        return (std::string_view(Ts::name()).starts_with("stat.tsc") or ...);
      }(Ops);

      const auto iterations = [&] {
        if constexpr (auto&& iterations = this->iterations; has_tsc) {
          if constexpr (requires { *iterations.time_budget; *iterations.min; *iterations.max; }) {
            if (iterations.time_budget and iterations.min) {
              using perf::metric::operator*;
              const auto& time = *bench(*iterations.min, stat::timer{stat::tsc}, fn, ts...)[] / *iterations.min;
              const auto n = (std::chrono::duration_cast<std::chrono::nanoseconds>(*iterations.time_budget) / time).count();
              return std::max(*iterations.min, std::size_t(n));
            } else {
              verify(iterations.max.has_value());
              return *iterations.max;
            }
          } else {
            return iterations;
          }
        } else {
          verify(iterations.max.has_value());
          return *iterations.max;
        }
      }();

      const auto samples = [&] {
        if constexpr (auto&& samples = this->samples; has_tsc) {
          if constexpr (requires { *samples.confidence_level and *samples.min and *samples.max; }) {
            if (samples.confidence_level and samples.min and samples.max) {
              using perf::metric::operator*;

              for (auto i = 0u; i < *samples.min; ++i) {
                data += bench<false>(iterations, t, fn, ts...)[];
                //data -= bench(iterations, t, utility::overhead(fn), ts...);
                data -= bench<true>(iterations, t, fn, ts...)[];
              }

              const auto& time = *data[stat::tsc];
              const auto degrees_of_freedom = *samples.min - 1u;
              const auto t_score = metric::stat::t_score(*samples.confidence_level, degrees_of_freedom);
              const auto margin_of_error = (1. - *samples.confidence_level) * metric::stat::mean(time);
              return std::min(std::max(std::size_t(std::ceil(std::pow((t_score * metric::stat::stddev(time)) / margin_of_error, 2.)) - *samples.min), *samples.min), *samples.max);
            } else {
              verify(samples.max.has_value());
              return *samples.max;
            }
          } else {
            return samples;
          }
        } else {
          verify(samples.max.has_value());
          return *samples.max;
        }
      }();

      data += make_fixed_named<"bench.operations">(std::vector{double(iterations)});
      data += make_fixed_named<"bench.samples">(std::vector{double(samples)});

      for (auto i = decltype(samples){}; i < samples; ++i) {
        data += bench<false>(iterations, t, fn, ts...)[];
        data -= bench<true>(iterations, t, fn, ts...)[];
      }

      if constexpr (requires { utility::debug(fn); }) {
        (void)bench(iterations, profiler{}, utility::debug(fn), ts...);
      }

      using fn_t = std::remove_cvref_t<decltype(fn)>;

      #if PERF_LLVM == 1
      auto&& analyzer = std::apply(
        [&](const auto&... ts) { return perf::analyzer{ts...}; },
        mp::filter<[]<class T> { return perf::mc_like<T>; }, std::tuple>(Ops)
      );
      #endif

      #if PERF_INTEL == 1
      using perf::metric::operator*;
      auto&& tracer = std::apply(
        [](const auto&... ts) { return perf::trace::tracer{{.region = {
          code::labels[mp::type_id<fn_t, fn_entry_tag>],
          code::labels[mp::type_id<fn_t, fn_exit_tag>],
        }}, perf::trace::instructions, ts...}; },
        mp::filter<[]<class T> { return perf::trace::event_like<T>; }, std::tuple>(Ops)
      );
      // todo max ts.size instead of 1000

      if constexpr ((requires { typename std::remove_cvref_t<decltype(ts)>::value_type; } or ...)) {
        #if PERF_LLVM == 1
        data += (analyzer << region{
          .begin = code::labels[mp::type_id<fn_t, fn_entry_tag>],
          .end = code::labels[mp::type_id<fn_t, fn_exit_tag>],
        })[];
        #endif
      } else {
        auto&& trace = bench<false>(1, tracer, fn, ts...);
        data += trace[];
        //todo trace::instructions is mc_like
        data += (analyzer << *trace[perf::trace::instructions])[];
      }
      #elif PERF_LLVM == 1
      data += (analyzer << region{
        .begin = code::labels[mp::type_id<fn_t, fn_entry_tag>],
        .end = code::labels[mp::type_id<fn_t, fn_exit_tag>],
      })[];
      #endif

      return data;
    }

    template<auto ovh = false>
    [[nodiscard]] constexpr decltype(auto) bench(const std::size_t iterations, auto&& t, auto&& fn, auto&&... ts) const {
      using fn_t = std::remove_cvref_t<decltype(fn)>;
      mp::unroll<10u>([&] { t.start(); t.stop(); });
      return [&]<class... TArgs>(mp::type_list<TArgs...>) -> decltype(auto) {
        if constexpr (ovh) {
          return bench<fn_t, TArgs...>(
            iterations,
            &latency::invoke2<fn_t, TArgs...>,
            t,
            fn,
            utility::arg<TArgs>(ts, iterations)...
          );
        } else {
          return bench<fn_t, TArgs...>(
            iterations,
            &latency::invoke<fn_t, TArgs...>,
            t,
            fn,
            utility::arg<TArgs>(ts, iterations)...
          );
        }
      }(typename mp::function_traits<fn_t>::args_type{});
    }

    [[nodiscard]] constexpr auto name() const {
      const auto name = [](const auto& t) -> std::string {
        if constexpr (requires { t.name(); }) {
          return std::format("/{}", t.name());
        } else {
          return {};
        }
      };

      return std::format(
        "latency{}{}{}{}", name(setup), name(before), name(after), name(teardown)
      );
    }

   private:
    template<class Fn, class... TArgs>
    [[nodiscard]] [[gnu::section("latency")]] [[gnu::noinline]] [[gnu::aligned(64u)]]
    constexpr decltype(auto) bench(const std::size_t iterations, void (*invoke)(Fn, TArgs...), auto&& t, auto&& fn, auto&&... ts) const
      requires requires (std::size_t i) { t.start(); t.stop(); invoke(fn, ts[i]...); } {
      setup();
      t.start();
      compiler::prevent_reorder(std::memory_order_seq_cst);
      code::align<std::align_val_t(64u)>(); for (auto i = 0u; i < iterations; ++i) {
        before();
        #if defined(__clang__)
        memory::synchronize<std::memory_order_seq_cst>();
        invoke(fn, ts[i]...);
        #else
        invoke(fn, ts[i]...);
        memory::synchronize<std::memory_order_seq_cst>();
        #endif
        after();
      }
      compiler::prevent_reorder(std::memory_order_seq_cst);
      t.stop();
      teardown();
      return (t);
    }

    template<class Fn, class T, class... Ts>
    [[gnu::section("latency")]] [[gnu::noinline]] [[gnu::aligned(64u)]]
    static constexpr void invoke2(Fn, T t, Ts...) {
      if constexpr (static int checksum; requires { checksum ^= t; }) {
        checksum ^= t;
      }
    }

    template<class Fn, class... Ts>
    [[gnu::section("latency")]] [[gnu::noinline]] [[gnu::aligned(64u)]]
    static constexpr void invoke2(Fn, Ts...) { }

    /**
     * invokes original function with parameters
     * - parameters are passed with the same qualifiers as original function
     * - `[[noinline]]` is required to keep same ip's for branches
     * - applies `entry/exit` function labels for tracing/disassembly
     */
    template<class Fn, class... Ts>
    [[gnu::section("latency")]] [[gnu::noinline]] [[gnu::aligned(64u)]]
    static constexpr void invoke(Fn fn, Ts... ts) {
      constexpr auto fn_entry = mp::type_id<Fn, fn_entry_tag>;
      constexpr auto fn_exit = mp::type_id<Fn, fn_exit_tag>;
      static int checksum; /// not-initialized
      static int ret; /// not-initialized
      if constexpr (std::is_void_v<decltype(fn(ts...))>) {
        code::label<fn_entry>();
        fn(ts...);
        code::label<fn_exit>();
      } else if constexpr (requires { checksum ^= fn(ts...); }) {
        code::label<fn_entry>();
        auto&& ret = fn(ts...);
        compiler::prevent_elision(ret);
        code::label<fn_exit>();
        checksum ^= ret;
      } else {
        code::label<fn_entry>();
        compiler::prevent_elision(fn(ts...));
        code::label<fn_exit>();
        checksum ^= ret;
      }
    }
  };

  template<
    class TIterations = initialized<
      detail::iterations,
      1'000,
      1'000'000,
      converted<std::optional<std::chrono::duration<double, std::milli>>, 1.>{}
    >,
    class TSamples = initialized<detail::samples, 30, 100, .95>,
    class TSetup = decltype([]{}),
    class TBefore = decltype([]{}),
    class TAfter = decltype([]{}),
    class TTeardown = decltype([]{}),
    class TPolicy = policy::seq>
  struct throughput {
    class fn_entry_tag;
    class fn_exit_tag;

    TIterations iterations{};
    TSamples samples{};
    TSetup setup{};
    TBefore before{};
    TAfter after{};
    TTeardown teardown{};
    TPolicy policy{};

    template<mp::type_list Ops>
    [[nodiscard]] constexpr auto operator()(auto&& fn, auto&&... ts) const {
      dataset data{};

      auto&& timer = std::apply(
        [](const auto&... ts) { return perf::stat::timer{ts...}; },
        mp::filter<[]<class T> { return perf::stat::time_like<T>; }, std::tuple>(Ops)
      );
      #if PERF_LINUX == 1
      auto&& counter = std::apply(
        [](const auto&... ts) { return perf::stat::counter{ts...}; },
        mp::filter<[]<class T> { return perf::stat::event_like<T>; }, std::tuple>(Ops)
      );
      auto&& sampler = std::apply(
        [](const auto&... ts) { return perf::record::sampler{ts...}; },
        mp::filter<[]<class T> { return perf::record::event_like<T>; }, std::tuple>(Ops)
      );
      #endif // PERF_LINUX

      auto&& t = profiler{sampler, counter, timer};

      constexpr auto has_tsc = []<class... Ts>(mp::type_list<Ts...>) {
        return (std::string_view(Ts::name()).starts_with("stat.tsc") or ...);
      }(Ops);

      const auto iterations = [&] {
        auto&& iterations = this->iterations;
        if constexpr (has_tsc) {
          if (iterations.time_budget and iterations.min) {
            using perf::metric::operator*;
            const auto& time = *bench(*iterations.min, stat::timer{stat::tsc}, fn, ts...)[] / *iterations.min;
            const auto n = (std::chrono::duration_cast<std::chrono::nanoseconds>(*iterations.time_budget) / time).count();
            return std::max(*iterations.min, std::size_t(n));
          }
        }
        verify(iterations.max.has_value());
        return *iterations.max;
      }();

      const auto samples = [&] {
        auto&& samples = this->samples;
        if constexpr (has_tsc) {
          if (samples.confidence_level and samples.min and samples.max) {
            using perf::metric::operator*;

            for (auto i = 0u; i < *samples.min; ++i) {
              data += bench(iterations, t, fn, ts...)[];
            }

            const auto& time = *data[stat::tsc];
            const auto degrees_of_freedom = *samples.min - 1u;
            const auto t_score = metric::stat::t_score(*samples.confidence_level, degrees_of_freedom);
            const auto margin_of_error = (1. - *samples.confidence_level) * metric::stat::mean(time);
            return std::min(std::size_t(std::ceil(std::pow((t_score * metric::stat::stddev(time)) / margin_of_error, 2.)) - *samples.min), *samples.max);
          }
        }
        verify(samples.max.has_value());
        return *samples.max;
      }();

      data += make_fixed_named<"bench.operations">(std::vector{double(iterations)});
      data += make_fixed_named<"bench.samples">(std::vector{double(samples)});

      for (auto i = decltype(samples){}; i < samples; ++i) {
        data += bench(iterations, t, fn, ts...)[];
      }

      if constexpr (requires { utility::debug(fn); }) {
        (void)bench(iterations, profiler{}, utility::debug(fn), ts...);
      }

      using fn_t = std::remove_cvref_t<decltype(fn)>;

      #if PERF_LLVM == 1
      auto&& analyzer = std::apply(
        [&](const auto&... ts) { return perf::analyzer{ts...}; },
        mp::filter<[]<class T> { return perf::mc_like<T>; }, std::tuple>(Ops)
      );
      #endif

      #if PERF_INTEL == 1
      using perf::metric::operator*;
      auto&& tracer = std::apply(
        [](const auto&... ts) { return perf::trace::tracer{{.region = {
          code::labels[mp::type_id<fn_t, fn_entry_tag>],
          code::labels[mp::type_id<fn_t, fn_exit_tag>],
        }}, perf::trace::instructions, ts...}; },
        mp::filter<[]<class T> { return perf::trace::event_like<T>; }, std::tuple>(Ops)
      );
      // todo max ts.size instead of 1000
      data += (analyzer << *bench(100, tracer, fn, ts...)[perf::trace::instructions])[];
      #elif PERF_LLVM == 1
      data += (analyzer << region{
        .begin = code::labels[mp::type_id<fn_t, fn_entry_tag>],
        .end = code::labels[mp::type_id<fn_t, fn_exit_tag>],
      })[];
      #endif

      return data;
    }

    [[nodiscard]] constexpr decltype(auto) bench(const std::size_t iterations, auto&& t, auto&& fn, auto&&... ts) const {
      mp::unroll<10u>([&] { t.start(); t.stop(); });
      return [&]<class... TArgs>(mp::type_list<TArgs...>) -> decltype(auto) {
        return invoke(iterations, t, fn, utility::arg<TArgs>(ts, iterations)...);
      }(typename mp::function_traits<std::remove_cvref_t<decltype(fn)>>::args_type{});
    }

    [[nodiscard]] constexpr auto name() const {
      const auto name = [](const auto& t) -> std::string {
        if constexpr (requires { t.name(); }) {
          return std::format("/{}", t.name());
        } else {
          return {};
        }
      };

      return std::format(
        "throughput{}{}{}{}{}", name(setup), name(before), name(after), name(teardown), name(policy)
      );
    }

   private:
    template<class Fn>
    [[gnu::section("throughput")]] [[gnu::noinline]] [[gnu::aligned(64u)]]
    [[nodiscard]] constexpr decltype(auto) invoke(const std::size_t iterations, auto&& t, Fn fn, auto&&... ts) const
      requires requires (std::size_t i) { t.start(); t.stop(); } {
      constexpr auto fn_entry = mp::type_id<Fn, fn_entry_tag>;
      constexpr auto fn_exit = mp::type_id<Fn, fn_exit_tag>;
      setup();
      t.start();
      compiler::prevent_reorder(std::memory_order_seq_cst);
      code::align<std::align_val_t(64u)>(); for (auto i = 0u; i < iterations; ++i) {
        before();
        std::tuple args{ts[i]...};
        code::label<fn_entry>();
        [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
          if constexpr (not std::is_void_v<decltype(fn(std::get<Ns>(args)...))>) {
            compiler::prevent_elision(fn(std::get<Ns>(args)...));
          } else {
            fn(std::get<Ns>(args)...);
          }
        }(std::make_index_sequence<sizeof...(ts)>{});
        code::label<fn_exit>();
        after();
      }
      compiler::prevent_reorder(std::memory_order_seq_cst);
      t.stop();
      teardown();

      return (t);
    }
  };

  inline namespace stat {
    // use strong_alias, that sould be array{1}
    struct operations { using value_type = double; value_type value{}; };
    inline constexpr auto operations = fixed_named<"bench.operations", struct operations>{};

    // use strong_alias
    struct samples { using value_type = double; value_type value{}; };
    inline constexpr auto samples = fixed_named<"bench.samples", struct samples>{};
  } // namespace stat
} // namespace bench
} // namespace perf

#if not defined(PERF_IO) or PERF_IO == 1
#include <iostream>
#include <ostream>

namespace perf::inline v_0_0_0::inline io {
template<class... Ts>
inline constexpr decltype(auto) log(auto& os, std::format_string<Ts...> fmt, Ts&&... ts)
  requires requires { os << std::format(fmt, std::forward<Ts>(ts)...); } {
  return os << std::format(fmt, std::forward<Ts>(ts)...);
}

template<class... Ts>
inline constexpr decltype(auto) log(std::format_string<Ts...> fmt, Ts&&... ts)
  requires requires { std::clog << std::format(fmt, std::forward<Ts>(ts)...); } {
  return std::clog << std::format(fmt, std::forward<Ts>(ts)...);
}

inline constexpr decltype(auto) log(const auto& t)
  requires requires { std::clog << std::format("{}\n", t); } {
  return std::clog << std::format("{}\n", t);
}

/**
 * saves results to the output stream in json format # chrome:tracing, perfetto.dev compatible
 */
inline constexpr auto json(auto& os, const auto& results) {
  for (const auto& [name, data] : results) {
    log(os, "{}", name);
  }
}

namespace misc {
  template<class TOs>
  struct layout {
    constexpr explicit layout(TOs& os, const std::size_t rows)
      : os_{os}, rows_{rows}
    { }

    constexpr ~layout() noexcept {
      constexpr auto is_sep = [](const auto& buffer) {
        return buffer.empty();
      };

      std::vector<std::vector<std::string>> buffers(streams_.size());
      std::vector<std::size_t> cols(streams_.size());

      std::size_t i{};
      for (const auto& stream : streams_) {
        std::istringstream istream{stream.str()};
        std::size_t max_len{};
        std::string line{};
        while (std::getline(istream, line)) {
          max_len = std::max(max_len, line.size());
          buffers[i].push_back(line);
        }
        cols[i] = max_len;
        ++i;
      }

      const auto size = std::max_element(buffers.begin(), buffers.end(),
        [](const auto& lhs, const auto& rhs) { return lhs.size() < rhs.size(); }
      )->size();

      for (auto& buffer : buffers) {
        if (buffer.size() >= size) {
          continue;
        }
        if (auto sep = std::find_if(buffer.rbegin(), buffer.rend(), is_sep); sep != buffer.rend()) {
          buffer.insert(sep.base() - 1u, size - buffer.size(), std::string{});
        }
      }

      for (auto i = 0u; i < size; ++i) {
        for (auto n = 0u; n < buffers.size(); ++n) {
          log(os_, "{}{:{}s}",
            buffers[n][i], "", cols[n] - buffers[n][i].size() + sizeof(" ")
          );
        }
        log(os_, "\n");
      }
      log(os_, "\n");
    }

    [[nodiscard]] constexpr auto& operator[](std::size_t i) {
      return streams_[i];
    }

   private:
    TOs& os_;
    std::size_t rows_{};
    std::vector<std::ostringstream> streams_ = std::vector<std::ostringstream>(rows_);
  };

  struct legend { std::string_view legend{}; };
  enum class split { hsplit, vsplit };
} // namespace misc

template<auto Split = misc::split::hsplit, auto... Vs>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == perf::misc::split::hsplit)
inline constexpr void report(auto& os, const std::ranges::range auto& results, const auto&... stats) {
  if (results.empty()) {
    return;
  }

  constexpr auto title = "benchmark";
  constexpr auto sep = "  ";
  constexpr auto ratio = [](const auto& v, const auto& r) -> std::optional<double> {
    if (not r.max.has_value() or not v) {
      return std::nullopt;
    }
    return *r.max / *v;
  };

  using data_t = decltype(results[0u].data);
  constexpr auto size = std::tuple_size_v<data_t> * std::max(1ul, sizeof...(stats));

  auto&& [values, indexes, baselines] = [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
    std::vector<std::tuple<std::optional<typename std::tuple_element_t<Ns % std::tuple_size_v<data_t>, data_t>::value_type>...>> values{};
    std::vector<std::tuple<std::optional<typename std::tuple_element_t<Ns % std::tuple_size_v<data_t>, data_t>::value_type>...>> baselines{};
    std::vector<std::pair<std::size_t, std::size_t>> indexes{};

    for (const auto& [name, data] : results) {
      const auto size = values.size();
      std::apply([&](const auto&... ts) {
        if constexpr (sizeof...(stats)) {
          auto&& value = std::tuple_cat([&](const auto& ts) { return std::tuple(stats(ts)...); }(ts)...);
          values.push_back(value);
          if (name.function == std::string(bench::baseline([]{}).name())) {
            baselines.push_back(value);
          }
        } else {
          constexpr auto get = []<class T>(const T& t, const auto i) {
            return t.size() > i ? std::optional(t[i]) : std::optional<typename T::value_type>{};
          };
          const auto max = std::max({ts.size()...});
          for (auto i = 0u; i < max; ++i) {
            values.push_back({get(ts, i)...});
            if (name.function == std::string(bench::baseline([]{}).name())) {
              baselines.push_back({get(ts, i)...});
            }
          }
        }
      }, data);
      indexes.push_back({size, values.size() - size});
    }
    return std::tuple{values, indexes, baselines};
  }(std::make_index_sequence<size>{});

  auto&& ratios = [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
    struct ratio { std::optional<double> min{}; std::optional<double> max{}; };
    std::array<ratio, sizeof...(Ns)> ratios{};
    for (const auto& v : baselines.empty() ? values : baselines) {
      ([&] {
        if constexpr (requires { double(*std::get<Ns>(v)); }) {
          if (not std::get<Ns>(v)) {
            return;
          }
          auto&& value = double(*std::get<Ns>(v));
          ratios[Ns] = {
            .min = ratios[Ns].min ? std::min(*ratios[Ns].min, value) : value,
            .max = ratios[Ns].max ? std::max(*ratios[Ns].max, value) : value,
          };
        }
      }(), ...);
    }
    return ratios;
  }(std::make_index_sequence<size>{});

  auto&& names = [&] {
    std::vector<std::string> names{title};
    std::transform(results.begin(), results.end(), std::back_inserter(names),
      [&](const auto& result) { return std::format("{}", result.name); }
    );
    return names;
  }();

  auto&& lengths = [&] {
    struct length {
      std::size_t main{};
      std::size_t sep{};
      std::size_t extra{};
      [[nodiscard]] constexpr operator std::size_t() const {
        return main + sep + extra;
      }
    };

    std::array<length, size + 1u> lengths{{
      std::max_element(names.begin(), names.end(),
        [](const auto& lhs, const auto& rhs) { return lhs.size() < rhs.size(); }
      )->size()
    }};

    const auto fill = [&]<std::size_t N> {
      for (const auto& v : values) {
        auto& length = lengths[N + 1u];
        length = {
          .main = std::max(length.main,
            std::get<N>(v) ? std::format("{}", *std::get<N>(v)).size() : 0u
          ),
          .sep = 1u,
          .extra = std::max(length.extra, [&] {
            auto&& value = ratio(std::get<N>(v), ratios[N]);
            return value ? std::format("({:.2f}x)", *value) : "";
          }().size()),
        };
      }
    };

    [&]<std::size_t... Ns>(std::index_sequence<Ns...>) {
      (fill.template operator()<Ns>(), ...);
    }(std::make_index_sequence<size>{});

    return lengths;
  }();

  const auto header = [&] {
    log(os, "{:<{}}", title, std::size_t(lengths[0u]));
    for (auto i = 0u; i < size; ++i) {
      log(os, "{:>{}}[{}]", "", std::size_t(lengths[i + 1u]) - 1u, i + 1u);
    }
    log(os, "\n");
    for (auto i = 0u; i < lengths.size(); ++i) {
      log(os, "{:->{}}{}", "", std::size_t(lengths[i]), sep);
    }
    log(os, "\n");
  };

  const auto body = [&] {
    std::size_t i{};
    for (const auto& [name, _] : results) {
      const auto& [index, size] = indexes[i];
      for (const auto& span : std::span{&values[index], size}) {
        log(os, "{:<{}}{}", std::format("{}", name), std::size_t(lengths[0u]), sep);
        std::apply([&](const auto&... vs) {
          std::size_t n{};
          ([&] {
            if (not vs) { return; }
            auto&& value = ratio(vs, ratios[n]);
            auto&& lhs = value ? std::format("({:.2f}x)", *value) : "";
            auto&& rhs = std::format("{}", *vs);
            ++n;
            log(os, "{:>{}}{}{:>{}}{}", lhs, lengths[n].extra, " ", rhs, lengths[n].main, sep);
          }(), ...);
        }, span);
        log(os, "\n");
      }
      ++i;
    }
  };

  const auto footer = [&] {
    log(os, "\n");
    log(os, "(0) speedup(slowest:1.00x)\n");
    std::size_t i{};
    std::apply([&](const auto&... ts) {
      if constexpr (sizeof...(stats)) {
        ([&](const auto& stat) {
          (log(os, "[{}] {} {}\n",
            ++i,
            std::format("{}({})", std::string(stat.name()), std::string(ts.name())),
            misc::legend{std::string(ts.name())}
          ), ...);
        }(stats), ...);
      } else {
        (log(os, "[{}] {} {}\n",
          ++i,
          std::string(ts.name()),
          misc::legend{std::string(ts.name())}
        ), ...);
      }
    }, results.begin()->data);
    log(os, "\n");
  };

  header();
  body();
  footer();
}

template<auto Split = misc::split::hsplit, auto... Vs>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::hsplit)
inline constexpr void report(const std::ranges::range auto& results, const auto&... stats) {
  report<Split, Vs...>(std::clog, results, stats...);
}

template<auto Split = misc::split::hsplit, auto... Vs, std::ranges::range TResults>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::vsplit)
inline constexpr void report(auto& os, const TResults& results, const auto&... stats) {
  misc::layout layout{os, results.size()};
  std::size_t i{};
  for (const auto& result : results) {
    report<misc::split::hsplit, Vs...>(layout[i++], TResults(1u, result), stats...);
  }
}

template<auto Split = misc::split::hsplit, auto... Vs>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::vsplit)
inline constexpr void report(const std::ranges::range auto& results, const auto&... stats) {
  report<Split, Vs...>(std::clog, results, stats...);
}

template<auto Split = misc::split::hsplit, auto... Vs>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::hsplit)
inline constexpr void annotate(auto& os, const std::ranges::range auto& results) {
  if (results.empty()) {
    return;
  }

  constexpr auto index = "index";
  constexpr auto sep = "   ";
  constexpr auto is_num = [](const auto& str) {
    return std::all_of(str.begin(), str.end(), [](const auto c) {
      return std::isdigit(c) or c == '%' or c == '.' or c == '-';
    });
  };

  auto&& labels = std::apply([](const auto&... ts) {
    return std::vector{std::string_view{index}, std::string_view{ts.name()}...};
  }, results.begin()->data);

  auto&& ips = [&] {
    std::unordered_map<std::size_t, std::vector<std::uint64_t>> ips{};
    std::size_t i{};
    for (const auto& [name, data] : results) {
      std::apply([&](const auto&... ts) {
        ([&] {
          for (const auto& t : ts) {
            if (std::find(ips[i].begin(), ips[i].end(), t.ip) == ips[i].end()) {
              ips[i].push_back(t.ip);
            }
          }
        }(), ...);
      }, data);
      ++i;
    }
    return ips;
  }();

  auto&& buffers = [&] {
    using ip_str_type = std::map<std::uint64_t, std::string>;
    using label_ip_type = std::map<std::string_view, ip_str_type>;
    std::vector<label_ip_type> buffers(results.size());
    std::size_t i{};
    for (const auto& [name, data] : results) {
      std::size_t n{};
      for (const auto& ip : ips[i]) {
        buffers[i][index][ip] = std::format("{}.", ++n);
      }
      std::apply([&](const auto&... ts) {
        ([&] {
          auto&& buffer = buffers[i][std::string_view(ts.name())];
          for (const auto& t : ts) {
            buffer[t.ip] = std::format("{}", t);
          }
        }(), ...);
      }, data);
      ++i;
    }
    return buffers;
  }();

  auto&& lengths = [&] {
    std::vector<std::size_t> lengths(labels.size(), std::string_view(sep).size());
    for (auto i = 0u; i < labels.size(); ++i) {
      for (auto&& buffer : buffers) {
        verify(buffer.contains(labels[i]));
        auto&& view = buffer[labels[i]];
        const auto max = std::max_element(view.begin(), view.end(),
          [](const auto& lhs, const auto& rhs) { return lhs.second.size() < rhs.second.size(); }
        );
        if (max == view.end()) {
          continue;
        }
        lengths[i] = std::max(lengths[i], max->second.size());
      }
    }
    return lengths;
  }();

  const auto header = [&](const auto& name) {
    log(os, "{}:", name);
    log(os, "\n ");
    for (auto i = 0u; i < lengths.size(); ++i) {
      log(os, "{:<{}} ", std::format("[{}]", i), lengths[i]);
    }
    log(os, "\n ");
    for (auto i = 0u; i < lengths.size(); ++i) {
      log(os, "{:->{}} ", "", lengths[i]);
    }
    log(os, "\n");
  };

  const auto body = [&](const auto n) {
    verify(not buffers.empty() and not lengths.empty() and buffers[n].size() == lengths.size());
    for (const auto& ip : ips[n]) {
      log(os, " ");
      for (auto l = 0u; l < labels.size(); ++l) {
        verify(buffers[n].contains(labels[l]));
        auto&& str = buffers[n][labels[l]][ip];
        if (is_num(str)) {
          log(os, "{:>{}} ", str, lengths[l]);
        } else {
          log(os, "{:<{}} ", str, lengths[l]);
        }
      }
      log(os, "\n");
    }
    log(os, "\n");
  };

  const auto footer = [&] {
    for (auto i = 0u; i < labels.size(); ++i) {
      log(os, "{}[{}] {} {}\n", ' ', i, labels[i], misc::legend{labels[i]});
    }
  };

  for (auto i = 0u; i < results.size(); ++i) {
    header(results[i].name);
    body(i);
  }
  footer();
}

template<auto Split = misc::split::hsplit, auto... Vs>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::hsplit)
inline constexpr void annotate(const auto& results) {
  annotate<Split, Vs...>(std::clog, results);
}

template<auto Split = misc::split::hsplit, auto... Vs, std::ranges::range TResults>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::vsplit)
inline constexpr void annotate(auto& os, const TResults& results) {
  misc::layout layout{os, results.size()};
  std::size_t i{};
  for (const auto& result : results) {
    annotate<misc::split::hsplit, Vs...>(layout[i++], TResults(1u, result));
  }
}

template<auto Split = misc::split::hsplit, auto... Vs>
  requires (std::get<misc::split>(std::tuple{Split, Vs...}) == misc::split::vsplit)
inline constexpr void annotate(const std::ranges::range auto& results) {
  annotate<Split, Vs...>(std::clog, results);
}

/**
 * plotting # gnuplot
 * - http://www.gnuplot.info
 * - https://sourceforge.net/p/gnuplot/gnuplot-main/ci/master/tree/Copyright
 */
namespace plot {
  namespace utility {
    struct subprocess {
      constexpr subprocess(subprocess&& other) : pipe_{std::move(other.pipe_)} { other.pipe_ = {}; }
      constexpr subprocess(const subprocess&) = delete;
      constexpr subprocess(const char* cmd, const char* perm) : pipe_{popen(cmd, perm)} { verify(bool(pipe_)); }
      constexpr ~subprocess() noexcept { if (pipe_) { pclose(pipe_); } }
      constexpr void write(const char* cmd) const { fprintf(pipe_, "%s", cmd); }
      constexpr void flush() const { fflush(pipe_); }

     private:
      FILE* pipe_{};
    };
  } // namespace utility

  enum class kind {
    point, line, bar, box, err,
  };

  /**
   * ENV: `PERF_IO_PLOT_TERM`  - gnuplot terminal (see `set terminal` to supported options in gnuplot)
   * ENV: `PERF_IO_PLOT_STYLE` - light/dark
   */
  struct config {
    std::string cmd = "gnuplot --persist"; /// `persist` is required if popup-based term is used, ex. 'wxt'
    std::size_t width = 1500;
    std::size_t height = 500;
    std::string theme = std::getenv("PERF_IO_PLOT_STYLE") ?  std::getenv("PERF_IO_PLOT_STYLE") : "dark"; /// light/dark [default]
    /**
     * gnuplot: `set terminal`
     * @code
     * sixel                  # console image # default - https://www.arewesixelyet.com
     * wxt                    # popup window
     * dumb size 150,25 ansi  # console with colors
     * dumb size 80,25        # console
     * @endcode
     */
    std::string term = std::getenv("PERF_IO_PLOT_TERM") ?  std::getenv("PERF_IO_PLOT_TERM") : "sixel";
    std::string style = std::format(R"(
      set key outside below vertical left Left reverse nobox spacing 1.5 samplen 4 textcolor rgb '{0}'
      set title textcolor '{0}'
      set xtics textcolor '{0}'
      set ytics textcolor '{0}'
      set xlabel textcolor '{0}'
      set ylabel textcolor '{0}'
      set xrange [*:*]
      set yrange [*:*]
      set style fill transparent solid 0.7
      set style line 1 lt 1 lw 2 pt 7 pi -1 ps 1.0
      set style line 2 lt 1 lw 1 lc rgb "#444444"
      set noborder
      {1}
    )", theme == "dark" ? "white" : "black", term.contains("dumb") ? "" : "set grid ls 2");
  };

  /**
   * http://www.gnuplot.info/documentation.html
   * http://www.gnuplot.info/demo
   * https://gnuplot.io
   */
  template<class TPlot = utility::subprocess, class TConfig = config>
    requires requires (TPlot plot) { plot.write("cmd"); plot.flush(); } and
    requires (TConfig config) { config.cmd; config.term; config.theme; config.width; config.height; config.style; }
  struct gnuplot {
    constexpr explicit gnuplot(const TConfig& config = {})
      : config_{config}, plot_{config_.cmd.c_str(), "w"} {
      send("set term {} noenhanced {} {}\n{}",
        config_.term,
        config_.term.contains("size") ?
          "" :
          std::format(" size {}, {}", config_.width, config_.height),
        config_.term.contains("background") or config.term.contains("dumb") ?  "" :
          std::format(" background '{}'",
            config_.theme == "light" ? "white" : "black",
            config_.width,
            config_.height
          ),
        config_.style
      );
    }

    // todo get from range
    template<class T = double>
    constexpr void plot(const std::ranges::range auto& x, const std::ranges::range auto& y,
      const auto& name, const std::same_as<kind> auto&... plots) {
      verify(x.size() == y.size(), std::format("x.size:{} != y.size:{}", x.size(), y.size()));
      auto&& str = std::format("{}", name);
      auto&& value = id(str);
      std::size_t i{};
      (series_.push_back({i++, str, plots, std::format("#{}", value * value)}), ...);
      send("$db_{} << EOD", value);
      for (auto i = 0u; i < y.size(); ++i) {
        if constexpr (requires { y[i].begin(); y[i].end(); }) {
          std::vector<char> buffer{};
          for (const auto& y : y[i]) {
            std::format_to(std::back_inserter(buffer), "{} ", y);
          }
          send("{} {}", T(x[i]), std::string_view(buffer.begin(), buffer.end()));
        } else {
          send("{} {}", T(x[i]), T(y[i]));
        }
      }
      send("""EOD");
    }

    // todo
    template<class T = double>
    constexpr void plot(const std::ranges::range auto& y, const auto& name, const std::same_as<kind> auto&... plots) {
      plot<T>(data::linspace(0ul, y.size() - 1ul), y, std::format("{}", name), plots...);
    }

    constexpr void show() {
      const auto plot_name = [](const auto& value) {
        switch (value) {
          case plot::kind::point: return "points";     /// https://gnuplot.sourceforge.net/demo/circles.html
          case plot::kind::line:  return "line";       /// https://gnuplot.sourceforge.net/demo/simple.html
          case plot::kind::bar:   return "boxes";      /// https://gnuplot.sourceforge.net/demo/histograms.html
          case plot::kind::box:   return "boxplot";    /// https://gnuplot.sourceforge.net/demo/boxplot.html
          case plot::kind::err:   return "errorbars";  /// https://gnuplot.sourceforge.net/demo/errorbars.html
        }
        return "unknown";
      };
      std::string plot = "plot";
      for (auto&& [id, name, kind, color] : series_) {
        send("{} $db_{} {} with {} ls 1 lc rgb '{}' {},\\",
          std::exchange(plot, ""),
          this->id(name),
          kind == plot::kind::bar ? "u 1:2" : "",
          plot_name(kind),
          color,
          id ? "notitle" : std::format("title '{}'", name)
        );
      }
      send("\n");

      plot_.flush();
      series_ = {};
    }

    constexpr void title(const auto& title) { send("set title '{}'", title); }
    constexpr void x_tics() { send("unset xtics"); }
    constexpr void x_tics(const auto& tics) {
      std::vector<char> buffer{};
      std::string sep{};
      for (const auto& [id, name] : tics) {
        std::format_to(std::back_inserter(buffer), "{}'{}' {}", std::exchange(sep, ","), name, id);
      }
      send("set xtics ({})", std::string_view(buffer.begin(), buffer.end()));
    }
    constexpr void x_label(const auto& label) { send("set xlabel '{}'", label); }
    constexpr void y_label(const auto& label) { send("set ylabel '{}'", label); }
    constexpr void x_range(const auto min, const auto max) { send("set xrange [{}:{}]", min, max); }
    constexpr void y_range(const auto min, const auto max) { send("set yrange [{}:{}]", min, max); }
    constexpr void log_scale() { send("set logscale x"); send("set logscale y"); }
    constexpr void width(const auto width) { send("set boxwidth {}", width); }
    constexpr void legend(const bool status) { send("set key {}", std::array{"off", "on"}[status]); }
    constexpr void layout(const std::size_t rows = {}, const std::size_t cols = {}) {
      if (rows and cols) {
        send("set multiplot layout {},{}", rows, cols);
      } else {
        send("unset multiplot");
      }
    }

    template<class... Ts>
    constexpr auto send(std::format_string<Ts...> fmt, Ts&&... ts) -> gnuplot& {
      plot_.write((std::format(fmt, std::forward<Ts>(ts)...) + '\n').c_str());
      return *this;
    }

   private:
    struct series {
      std::size_t id{};
      std::string name{};
      enum kind kind{};
      std::string color{};
    };

    [[nodiscard]] static constexpr auto id(const auto& str) -> std::uint32_t
      requires requires(std::size_t i) { str.size(); str[i]; } {
      std::uint32_t hash = 0x811C9DC5u;
      for (auto i = 0u; i < str.size(); ++i) {
        hash ^= str[i];
        hash *= 0x01000193u;
      }
      return hash;
    }

    TConfig config_{};
    TPlot plot_;
    std::vector<series> series_{};
  };

  namespace misc {
    inline constexpr auto layout = [](auto&& plt, const auto rows, const auto cols) {
      return scoped{
        .on_entry = [&] { plt.layout(rows, cols); },
        .on_exit  = [&] { plt.layout(); },
      };
    };

    struct bucket_size {
      std::size_t value{};
    };
  } // namespace misc

  /**
   * https://en.wikipedia.org/wiki/Histogram
   */
  template<auto Split = perf::misc::split::hsplit, auto BucketSize = misc::bucket_size{100u}, auto... Vs>
    requires (std::get<perf::misc::split>(std::tuple{Split, BucketSize, Vs...}) == perf::misc::split::hsplit) and
             (std::get<misc::bucket_size>(std::tuple{Split, BucketSize, Vs...}).value > 0u)
  constexpr auto hist(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }

    constexpr auto bucket_size = std::get<misc::bucket_size>(std::tuple{Split, BucketSize, Vs...}).value;
    const auto labels = std::apply([](const auto&... ts) {
      return std::array{std::string_view(ts.name())...};
    }, results.begin()->data);

    for (const auto& label : labels) {
      auto min = std::numeric_limits<double>::max();
      auto max = std::numeric_limits<double>::min();

      for (const auto& [_, data] : results) {
        std::apply([&](const auto&... ts) {
          ([&] {
            min = std::min(min, decltype(min)(perf::metric::stat::min(ts)));
            max = std::max(max, decltype(max)(perf::metric::stat::max(ts)));
          }(), ...);
        }, data);
      }

      plt.title(label);
      plt.x_range(min - min * .1, max + max * .1);
      plt.x_label(perf::misc::legend{label});
      plt.y_label("frequency");
      const auto& x = data::linspace(min, max, bucket_size);
      for (const auto& [name, data] : results) {
        std::apply([&](const auto&... ts) {
          ([&] {
            if (label != std::string_view(ts.name())) return;
            plt.plot(x, data::bin(ts, min, max, bucket_size), name, plot::kind::bar);
          }(), ...);
        }, data);
      }
      plt.show();
    }
  }

  template<auto Split = perf::misc::split::hsplit, auto BucketSize = misc::bucket_size{100u}, auto... Vs>
    requires (std::get<perf::misc::split>(std::tuple{Split, BucketSize, Vs...}) == perf::misc::split::hsplit) and
             (std::get<misc::bucket_size>(std::tuple{Split, BucketSize, Vs...}).value > 0u)
  constexpr auto hist(const std::ranges::range auto& results) {
    constexpr auto bucket_size = std::get<misc::bucket_size>(std::tuple{Split, BucketSize, Vs...}).value;
    const auto size = std::apply([](const auto&... ts) { return sizeof...(ts); }, results.begin()->data);
    gnuplot plt{};
    auto _ = misc::layout(plt, 1u, size);
    hist<Split, BucketSize, Vs...>(plt, results);
  }

  template<auto Split = perf::misc::split::hsplit, auto BucketSize = misc::bucket_size{100u}, auto... Vs, std::ranges::range TResults>
    requires (std::get<perf::misc::split>(std::tuple{Split, BucketSize, Vs...}) == perf::misc::split::vsplit) and
             (std::get<misc::bucket_size>(std::tuple{Split, BucketSize, Vs...}).value > 0u)
  constexpr auto hist(const TResults& results) {
    constexpr auto bucket_size = std::get<misc::bucket_size>(std::tuple{Split, BucketSize, Vs...}).value;
    const auto size = std::apply([](const auto&... ts) { return sizeof...(ts); }, results.begin()->data);
    gnuplot plt{};
    auto _ = misc::layout(plt, 1u, results.size() * size);
    for (const auto& result : results) {
      hist<Split, BucketSize, Vs...>(plt, TResults(1u, result));
    }
  }

  /**
   * https://en.wikipedia.org/wiki/Bar_chart
   */
  constexpr auto bar(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }

    constexpr auto width = .75; // todo cfg
    constexpr auto error = [](const auto& data) {
      if (data.size() == 1u) {
        return std::array<double, 3u>{data[0u], data[0u], data[0u]};
      }
      const auto mean = perf::metric::stat::mean(data);
      std::vector<double> gtm{};
      std::vector<double> ltm{};
      std::copy_if(data.begin(), data.end(), std::back_inserter(gtm), [&](const auto& value) {
        return value > mean;
      });
      std::copy_if(data.begin(), data.end(), std::back_inserter(ltm), [&](const auto& value) {
        return value < mean;
      });
      return std::array<double, 3u>{
        mean,
        mean + perf::metric::stat::stddev(gtm),
        mean - perf::metric::stat::stddev(ltm)
      };
    };

    const auto labels = std::apply([](const auto&... ts) {
      return std::array{std::string_view(ts.name())...};
    }, results.begin()->data);

    plt.x_tics();

    auto _ = misc::layout(plt, 1u, labels.size());
    plt.width(width);
    for (const auto& label : labels) {
      plt.title(label);
      plt.y_label(std::format("{} {}", label, perf::misc::legend{label}));
      auto i = 1ul;
      for (const auto& [name, data] : results) {
        std::apply([&](const auto&... ts) {
          ([&] {
            if (label != std::string_view(ts.name())) return;
            plt.plot(std::array{i++}, std::vector{error(ts)}, name, plot::kind::bar, plot::kind::err);
          }(), ...);
        }, data);
      }
      plt.show();
    }
  }

  constexpr auto bar(const std::ranges::range auto& results) {
    bar(gnuplot{}, results);
  }

  /**
   * https://en.wikipedia.org/wiki/Box_plot
   */
  template<auto Split = perf::misc::split::hsplit, auto... Vs>
    requires (std::get<perf::misc::split>(std::tuple{Split, Vs...}) == perf::misc::split::hsplit)
  constexpr auto box(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }

    const auto labels = std::apply([](const auto&... ts) {
      return std::array{std::string_view(ts.name())...};
    }, results.begin()->data);

    plt.x_tics();

    for (const auto& label : labels) {
      plt.title(label);
      plt.y_label(std::format("{} {}", label, perf::misc::legend{label}));
      auto i = 1ul;
      for (const auto& [name, data] : results) {
        std::apply([&](const auto&... ts) {
          ([&] {
            if (label != std::string_view(ts.name())) return;
            plt.plot(data::linspace(i, i, ts.size()), ts, name, plot::kind::box);
            ++i;
          }(), ...);
        }, data);
      }
      plt.show();
    }
  }

  template<auto Split = perf::misc::split::hsplit, auto... Vs>
    requires (std::get<perf::misc::split>(std::tuple{Split, Vs...}) == perf::misc::split::hsplit)
  constexpr auto box(const std::ranges::range auto& results) {
    gnuplot plt{};
    auto _ = misc::layout(plt, 1u, std::apply([](const auto&... ts) { return sizeof...(ts); }, results.begin()->data));
    box<Split, Vs...>(plt, results);
  }

  template<auto Split = perf::misc::split::hsplit, auto... Vs, std::ranges::range TResults>
    requires (std::get<perf::misc::split>(std::tuple{Split, Vs...}) == perf::misc::split::vsplit)
  constexpr auto box(const TResults& results) {
    const auto size = std::apply([](const auto&... ts) { return sizeof...(ts); }, results.begin()->data);
    gnuplot plt{};
    auto _ = misc::layout(plt, 1u, results.size() * size);
    for (const auto& result : results) {
      box<Split, Vs...>(plt, TResults(1u, result));
    }
  }

  /**
   * https://en.wikipedia.org/wiki/Error_bar
   */
  constexpr auto errorbar(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }

    constexpr auto error = [](const auto& data) {
      const auto mean = perf::metric::stat::mean(data);
      std::vector<double> gtm{};
      std::vector<double> ltm{};
      std::copy_if(data.begin(), data.end(), std::back_inserter(gtm), [&](const auto& value) {
        return value > mean;
      });
      std::copy_if(data.begin(), data.end(), std::back_inserter(ltm), [&](const auto& value) {
        return value < mean;
      });
      return std::array<double, 3u>{mean, mean + perf::metric::stat::stddev(gtm), mean - perf::metric::stat::stddev(ltm)};
    };

    const auto labels = std::apply([](const auto&... ts) {
      return std::array{std::string_view(ts.name())...};
    }, results.begin()->data);

    auto _ = misc::layout(plt, 1u, labels.size());
    for (const auto& label : labels) {
      plt.title(label);
      plt.y_label(perf::misc::legend{label});

      std::vector<std::pair<std::size_t, std::string>> xtics{};
      std::size_t i = 1u;
      for (const auto& [name, _] : results) {
        verify(not name.parameters.empty(), std::format("'{}' has no parameters!", name));
        const auto xtic = std::format("{}", std::accumulate(
          std::next(name.parameters.begin()), name.parameters.end(), name.parameters[0u],
          [](const auto& lhs, const auto& rhs) {
            return std::format("{},{}", lhs, rhs);
          }
        ));
        if (const auto tic = std::find_if(
          xtics.begin(),
          xtics.end(),
          [&](const auto& t) { return t.second == xtic; }); tic != xtics.end()) {
          verify(xtic == tic->second,
            std::format("'{}' has different parameters ('{}' != '{}')", name, xtic, tic->second)
          );
        } else {
          xtics.push_back({i++, xtic});
        }
      }

      std::map<std::string, std::vector<std::array<double, 3u>>> r{};
      for (const auto& [name, data] : results) {
        std::apply([&](const auto&... ts) {
          ([&] {
            if (label != std::string_view(ts.name())) return;
            //todo format name without args
            r[std::format("{}/{}", name.function, name.runner)].push_back(error(ts));
            verify(not name.parameters.empty(), std::format("'{}' has no parameters!", name));
          }(), ...);
        }, data);
      }

      plt.x_tics(xtics);

      auto xmax = 0ul;
      auto ymax = 0.;
      for (const auto& [name, data]: r) {
        verify(data.size() > 1u, std::format("'{}' requires at least 2 results!", name));
        plt.plot(data::linspace(1ul, data.size()), data, name, plot::kind::line, plot::kind::err);
        xmax = std::max(xmax, data.size());
        ymax = std::max(ymax, (*std::max_element(data.begin(), data.end(),
          [](const auto& lhs, const auto& rhs) { return lhs[0] < rhs[0]; }))[0]
        );
      }
      plt.show();
    }
  }

  constexpr auto errorbar(const std::ranges::range auto& results) {
    errorbar(gnuplot{}, results);
  }

  /**
   * https://en.wikipedia.org/wiki/Empirical_distribution_function
   */
  constexpr auto ecdf(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }

    constexpr auto ecdf = [](auto x) {
      std::sort(x.begin(), x.end());
      std::vector<double> y(x.size());
      for (auto i = 0u; i < y.size(); ++i) {
        y[i] = double(i + 1u) / y.size();
      }
      return std::tuple{x, y};
    };

    const auto labels = std::apply([](const auto&... ts) {
      return std::array{std::string_view(ts.name())...};
    }, results.begin()->data);

    auto _ = misc::layout(plt, 1u, labels.size());
    for (const auto& label : labels) {
      plt.title(label);
      plt.x_label(perf::misc::legend{label});
      plt.y_label("cumulative probability");
      for (const auto& [name, data] : results) {
        std::apply([&](const auto&... ts) {
          ([&] {
            if (label != std::string_view(ts.name())) return;
            const auto& [x, y] = ecdf(ts);
            plt.plot(x, y, name, plot::kind::point);
          }(), ...);
        }, data);
      }
      if constexpr (not std::is_lvalue_reference_v<decltype(plt)>) {
        plt.show();
      }
    }
  }

  constexpr auto ecdf(const std::ranges::range auto& results) {
    ecdf(gnuplot{}, results);
  }

  /**
   * https://github.com/brendangregg/FlameGraph
   */
  constexpr auto flamegraph(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }

    struct node final {
      std::string name{};
      double value{};
      double x{};
      double w{};
      std::size_t depth{};
      std::vector<node*> children{};
    };

    constexpr auto color = [](const std::size_t depth) {
      const auto r = (50 +  (depth * 37) % 206);
      const auto g = (120 + (depth * 53) % 130);
      const auto b = (200 - (depth * 19) % 120);
      return std::format("#{0:02x}{1:02x}{2:02x}", r, g, b);
    };

    constexpr auto escape = [](const auto& str) {
      std::string out{};
      for (const auto c : str) {
        out += (c == '\'') ? "\\'" : std::string(1, c);
      }
      return out;
    };

    constexpr auto make_node = [](auto& pool, const auto& name, const std::size_t depth) {
      return &pool.emplace_back(node{.name = name, .depth = depth});
    };

    std::deque<node> pool{};
    auto total = 0.;
    auto root = make_node(pool, "root", 0ul);

    for (auto& [stack, count] : results) {
      total += count;
      root->value += count;
      auto* node = root;
      for (auto& frame : stack) {
        struct node* child{};
        for (auto c : node->children) {
          if (c->name == frame) {
            child = c;
            break;
          }
        }

        if (not child) {
          child = make_node(pool, frame, node->depth + 1u);
          node->children.push_back(child);
        }

        node = child;
        node->value += count;
      }
    }

    constexpr auto sort = [](auto&& sort, auto* node) -> void {
      std::sort(node->children.begin(), node->children.end(),
        [](const auto* lhs, const auto* rhs) {
          auto&& str = lhs->name;
          return str < rhs->name;
        }
      );

      for (auto* c : node->children) {
        sort(sort, c);
      }
    };
    sort(sort, root);

    constexpr auto layout = [](auto&& layout, auto* node, const auto x) -> void {
      node->x = x;
      node->w = node->value;
      auto current = x;
      for (auto* child : node->children) {
        layout(layout, child, current);
        current += child->w;
      }
    };
    layout(layout, root, 0.);

    std::vector<node*> nodes{};
    auto max_depth = 0ul;
    constexpr auto collect = [](auto&& collect, auto& nodes, auto* node, auto& max_depth) -> void {
      for (auto* c : node->children) {
        nodes.push_back(c);
        max_depth = std::max(max_depth, c->depth);
        collect(collect, nodes, c, max_depth);
      }
    };
    collect(collect, nodes, root, max_depth);

    const auto SVG_WIDTH = 1200.0;
    const auto BAR_HEIGHT = 20.0;
    const auto GAP = 1.0;
    const auto scale = (total > 0) ? (SVG_WIDTH / total) : 1.0;

    plt.send(
      "unset key\n"
      "set lmargin 0; set rmargin 0; set tmargin 0; set bmargin 0\n"
      "set border 0\n"
      "set xtics scale 0; set ytics scale 0\n"
      "set format x ''\n"
      "set format y ''\n"
      "set xrange [0: {} ]\n"
      "set yrange [0: {} ]\n",
      SVG_WIDTH,
      (max_depth * BAR_HEIGHT + 10)
    );

    auto id = 1;
    for (auto* n : nodes) {
      const auto x_px = n->x * scale;
      const auto w_px = n->w * scale;
      const auto y_px = ((max_depth - n->depth) * BAR_HEIGHT + 5);
      const auto h_px = BAR_HEIGHT - GAP;

      if (w_px <= .5) {
        continue;
      }

      plt.send("set obj {} rect from {}, {} to {}, {} fc rgb '{}' fillstyle solid border rgb '#000000' lw 0.2",
         id, x_px, y_px, (x_px + w_px), (y_px + h_px), color(n->depth)
      );

      auto label = escape(n->name);
      const auto max_len = std::uint32_t(w_px / 8);
      if (max_len) {
        if (label.size() > max_len) {
          if (max_len > 3u) {
            label = label.substr(0, max_len - 3) + "...";
          } else {
            label = label.substr(0, max_len);
          }
        }
        const auto text_x = x_px + w_px / 2.0;
        const auto text_y = y_px + h_px / 2.0;
        plt.send("set label '{}' at {}, {} center front font ',8' noenhanced",
          label, text_x, text_y
        );
      }

      id++;
    }

    plt.send("plot NaN notitle");
  }

  constexpr auto flamegraph(const std::ranges::range auto& results) {
    flamegraph(gnuplot{}, results);
  }

  constexpr auto flowgraph(auto&& plt, const std::ranges::range auto& results) {
    if (results.empty()) {
      return;
    }
  }

  constexpr auto flowgraph(const std::ranges::range auto& results) {
    flowgraph(gnuplot{}, results);
  }
} // namespace plot
} // namespace perf::io

template<perf::fixed_string Name, class T>
struct std::formatter<perf::fixed_named<Name, T>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}:{}",
      std::string_view(t.name()),
      static_cast<const T&>(t)
    );
  }
};

template<class T>
  requires requires (T t) { t.major; t.minor; t.patch; }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& v, auto& ctx) const {
    return std::format_to(ctx.out(), "{}.{}.{}", v.major, v.minor, v.patch);
  }
};

template<class T>
  requires requires (T t) { t.family; t.model; t.stepping; }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& v, auto& ctx) const {
    return std::format_to(ctx.out(),
      "{}.{}.{}",
      v.family,
      v.model,
      v.stepping
    );
  }
};

template<class T>
  requires requires (T t) { t.size; t.line_size; t.assoc; }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& cache, auto& ctx) const {
    if (cache.assoc) {
      return std::format_to(ctx.out(),
        "{}/{} ({}b)",
        size(cache.size),
        cache.assoc,
        cache.line_size
      );
    } else {
      return std::format_to(ctx.out(),
        "{} ({}b)",
        size(cache.size),
        cache.line_size
      );
    }
  }

  static constexpr auto size = [](const std::size_t value) {
    if (value >= 1024u * 1024u) {
      return std::format("{}Mb", value / (1024u * 1024u));
    } else if (value >= 1024u) {
      return std::format("{}Kb", value / 1024u);
    } else {
      return std::format("{}b", value);
    }
  };
};

template<class T, class... Ts>
struct std::formatter<perf::data::random::choice<T, Ts...>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::format_to(ctx.out(), "{{");
    std::string sep{};
    for (const auto& v : t.values) {
      std::format_to(ctx.out(), "{}{}", std::exchange(sep, ","), v);
    }
    std::format_to(ctx.out(), "}},{{");
    sep = {};
    for (const auto& p : t.probabilities) {
      std::format_to(ctx.out(), "{}{}", std::exchange(sep, ","), p);
    }
    return std::format_to(ctx.out(), "}}");
  }
};

template<class T, class... Ts>
struct std::formatter<perf::data::random::uniform<T, Ts...>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "uniform{{{},{},{}}}", t.min, t.max, t.seed);
  }
};

template<class T>
struct std::formatter<perf::data::random::detail::unpredictable<T>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "unpredictable", t.min, t.max, t.seed);
  }
};


template<class T, class... Ts>
struct std::formatter<perf::data::random::normal<T, Ts...>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "normal{{{},{},{}}}", t.mean, t.stddev, t.seed);
  }
};

template<class T>
struct std::formatter<perf::data::fixed::sequence<T>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::format_to(ctx.out(), "sequence{{");
    std::string sep{};
    for (const auto& v : t.values) {
      std::format_to(ctx.out(), "{}{}", std::exchange(sep, ","), v);
    }
    return std::format_to(ctx.out(), "}}");
  }
};

template<class T>
struct std::formatter<perf::data::fixed::range<T>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "range{{{},{},{}}}", t.start, t.stop, t.step);
  }
};

template<class T, class TGen>
struct std::formatter<perf::data::sampler<T, TGen>> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}{{{},{}}}", [] {
      #if __has_feature(reflection) /// `reflection for C++26` # https://wg21.link/p2996
      return identifier_of(^^T);
      #else
      return typeid(T).name();
      #endif
    }(), t.generator, t.size);
  }
};

template<>
struct std::formatter<perf::io::misc::legend> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}", legend[t.legend]);
  }
  static inline std::unordered_map<
    decltype(std::declval<perf::io::misc::legend>().legend), std::string
  > legend{}; /// [N]: legend
};

template<class T>
  requires std::integral<decltype(std::declval<T>().value)>
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}", t.value);
  }
};

template<class T>
  requires std::floating_point<decltype(std::declval<T>().value)>
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{:.2f}", t.value);
  }
};

template<class T>
  requires requires (T t) { t.value.count(); }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{:.2f}", t.value.count());
  }
};

template<class T>
  requires requires (T t, std::size_t i) { t.runner; t.function; t.parameters[i]; }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}({})/{}", t.function, parameters(t.parameters), t.runner);
  }

 private:
  static constexpr auto parameters = [](const auto& args) -> std::string {
    if (args.empty()) {
      return {};
    }
    return std::accumulate(
      std::next(args.begin()), args.end(), args[0u],
      [](const auto& lhs, const auto& rhs) {
        return std::format("{},{}", lhs, rhs);
      }
    );
  };
};

template<>
struct std::formatter<perf::info::spec> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    auto max_info_len = 0ul, max_desc_len = 0ul;
    for (const auto& [desc, info] : t) {
      max_desc_len = std::max(max_desc_len, desc.size());
      max_info_len = std::max(max_info_len, info.size());
    }

    std::format_to(ctx.out(), "{:<{}}{}{:<{}}{}\n", "name", max_desc_len, ' ', "info", max_info_len, ' ');
    std::format_to(ctx.out(), "{:-<{}}{}{:-<{}}{}\n", "", max_desc_len, ' ', "", max_info_len, ' ');

    for (const auto& [desc, info] : t) {
      std::format_to(ctx.out(), "{:<{}}{}{}{}\n", std::string(desc), max_desc_len, ' ', std::string(info), ' ');
    }

    return ctx.out();
  }
};

#if PERF_LLVM == 1
template<>
struct std::formatter<perf::mca::assembly::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.assembly"] = std::format("# {}",
      t.syntax == decltype(t.syntax)::intel ? "intel" : "at&t"
    );
    auto text = t.text;
    std::replace(text.begin(), text.end(), '\t', ' ');
    text.erase(text.begin(), std::find_if(text.begin(), text.end(),
      [](const auto c) { return c != ' ' and c != '\t'; })
    );
    return std::format_to(ctx.out(), "{}", text);
  }
};

template<>
struct std::formatter<perf::mca::address::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{:04x}", (t.ip - base_address) & 0xFFFF);
  }

 private:
  inline static const auto base_address = perf::info::proc::self::base_address();
};

template<>
struct std::formatter<perf::mca::encoding::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    auto&& out = ctx.out();
    const auto* data = reinterpret_cast<const std::uint8_t*>(t.ip);
    for (auto i = 0u; i < t.size; ++i) {
      std::format_to(out, "{:02x} ", data[i]);
    }
    return out;
  }

 private:
  inline static const auto base_address = perf::info::proc::self::base_address();
};

template<>
struct std::formatter<perf::mca::size::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}", t.size);
  }
};

template<>
struct std::formatter<perf::mca::uops::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}", t.value);
  }
};

template<>
struct std::formatter<perf::mca::latency::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{}", t.value);
  }
};

template<>
struct std::formatter<perf::mca::rthroughput::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    return std::format_to(ctx.out(), "{:.1f}", t.value);
  }
};

template<>
struct std::formatter<perf::mca::may_load::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.may_load"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<>
struct std::formatter<perf::mca::may_store::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.may_store"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<>
struct std::formatter<perf::mca::has_side_effects::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.has_side_effects"] = "{'U':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "U" : "");
  }
};

template<>
struct std::formatter<perf::mca::branch::is_conditional::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.branch.is_conditional"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<>
struct std::formatter<perf::mca::branch::is_unconditional::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.branch.is_unconditional"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<>
struct std::formatter<perf::mca::branch::is_indirect::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.branch.is_indirect"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<>
struct std::formatter<perf::mca::branch::is_call::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.branch.is_call"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<>
struct std::formatter<perf::mca::branch::is_ret::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.branch.is_ret"] = "{'*':yes, '':no}";
    return std::format_to(ctx.out(), "{}", t.value ? "*" : "");
  }
};

template<class T>
  requires requires (T t, std::size_t i) {
    t.units[i].name;
    t.units[i].pressure;
  }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    auto&& legend = std::formatter<perf::io::misc::legend>::legend;
    auto&& out = ctx.out();

    legend["mca.resource_pressure"] = {};
    std::size_t i{};
    for (const auto& [name, pressure] : t.units) {
      legend["mca.resource_pressure"] += std::format("\n\t- {}: {}" , i++, name);
      if (pressure) {
        std::format_to(out, "{:>6.2f}", pressure);
      } else {
        std::format_to(out, "{:>6}", "-");
      }
    }
    return out;
  }
};

template<class T>
  requires requires (T t) {
    *t.cycle_dispatched;
    t.cycle_ready;
    t.cycle_issued;
    t.cycle_executed;
    t.cycle_retired;
    t.dispatch_width;
    t.cycles;
  }
struct std::formatter<T> {
  static constexpr auto dispatched = 'D';
  static constexpr auto executed = 'E';
  static constexpr auto retired = 'R';
  static constexpr auto waiting = '=';
  static constexpr auto executing = 'e';
  static constexpr auto retire_lag = '-';

  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& entry, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.timeline"] = std::format(
      "\n  - 'D': instruction dispatched"
      "\n  - 'e': instruction executing"
      "\n  - 'E': instruction executed"
      "\n  - 'R': instruction retired"
      "\n  - '=': instruction waiting"
      "\n  - '-': instruction executed"
    );

    perf::verify(entry.cycle_dispatched.has_value());

    auto&& out = ctx.out();
    for (auto i = 0u; i < *entry.cycle_dispatched; ++i) {
      std::format_to(out, "{}", i % entry.dispatch_width ? ' ' : '.');
    }
    std::format_to(out, "{}", dispatched);

    if (*entry.cycle_dispatched != entry.cycle_executed) {
      for (auto i = *entry.cycle_dispatched + 1u; i < entry.cycle_issued; ++i) {
        std::format_to(out, "{}", waiting);
      }

      if (entry.cycle_issued == entry.cycle_executed) {
        std::format_to(out, "{}", executed);
      } else {
        if (*entry.cycle_dispatched != entry.cycle_issued) {
          std::format_to(out, "{}", executing);
        }

        for (auto i = entry.cycle_issued + 1u; i < entry.cycle_executed; ++i) {
          std::format_to(out, "{}", executing);
        }

        std::format_to(out, "{}", executed);
      }
    }

    for (auto i = entry.cycle_executed + 1u; i < entry.cycle_retired; ++i) {
      std::format_to(out, "{}", retire_lag);
    }

    if (entry.cycle_executed < entry.cycle_retired) {
      std::format_to(out, "{}", retired);
    }

    for (auto i = entry.cycle_retired + 1u; i <= entry.cycles; ++i) {
      std::format_to(out, "{}", i % entry.dispatch_width ? ' ' : '.');
    }

    return out;
  }
};

template<class T>
  requires requires (T t) {
    t.dependency;
    *t.name;
    *t.freq;
    *t.cost;
  }
struct std::formatter<T> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.bottleneck"] = std::format(
      "\n  - <register>"
      "\n  - [memory]"
      "\n  - {{resource:probability}}"
    );
    switch (t.dependency) {
      default: {
        return std::format_to(ctx.out(), "");
      }
      case decltype(t.dependency)::reg: {
        perf::verify(t.name.has_value());
        return std::format_to(ctx.out(), "<{}>", *t.name);
      }
      case decltype(t.dependency)::mem: {
        return std::format_to(ctx.out(), "[loads/stores]");
      }
      case decltype(t.dependency)::res: {
        perf::verify(t.name.has_value() and t.freq.has_value());
        return std::format_to(ctx.out(), "{{{}:{}%}}", *t.name, *t.freq);
      }
    }
  }
};

template<>
struct std::formatter<perf::mca::debug::source::value_type> {
  [[nodiscard]] constexpr auto parse(auto& ctx) { return ctx.begin(); }
  [[nodiscard]] constexpr auto format(const auto& t, auto& ctx) const {
    std::formatter<perf::io::misc::legend>::legend["mca.source"] = "# requires '-g'";
    return std::format_to(ctx.out(), "{}", t.value);
  }
};
#endif // PERF_LLVM
#endif // PERF_IO

/**
 * `-DNTEST` # default: not defined
 * - disables compile-time tests
 * - disables run-time tests
 */
#ifndef NTEST
namespace perf::inline v0_0_0::inline self {
/**
 * unit-testing
 * - tests marked `consteval` run only at compile-time
 * - tests marked `constexpr` run at compile-time and run-time
 * - tests marked `mutable` run only at run-time
 */
namespace ut {
  template<fixed_string> struct test;
  template<> struct test<"*"> {
    static inline void (*setup)(std::string_view) = [](auto){};
    static inline void (*teardown)(std::string_view) = [](auto){};
  };

  template<fixed_string Name>
  struct test {
    constexpr void operator=(auto fn) const {
      if constexpr (constexpr auto non_mutable =
        requires { []<class R, class B, class... Ts>(R (B::*)(Ts...) const) { }
          (&decltype(fn)::operator()); }; non_mutable) {
        if constexpr (requires { fn(); }) {
          static_assert((fn(), true)); /// runs at compile-time unless fn is marked `mutable`
        }
      }
      if constexpr (requires { fn(); }) {
        test<"*">::setup(std::string_view(Name));
        fn(); /// run at run-time unless fn is marked `consteval`
        test<"*">::teardown(std::string_view(Name));
      }
    }
  };

  template<fixed_string Name>
  inline constexpr auto operator""_test() { return ut::test<Name>{}; }

  template<fixed_string Name> struct suite;
  template<> struct suite<"*"> {
    static inline void (*setup)(std::string_view) = [](auto){};
    static inline void (*teardown)(std::string_view) = [](auto){};
  };

  template<fixed_string Name>
  struct suite {
    constexpr void operator=(auto fn) const {
      if constexpr (requires { fn(); }) {
        suite<"*">::setup(std::string_view(Name));
        fn();
        suite<"*">::teardown(std::string_view(Name));
      }
    }
  };

  template<fixed_string Name>
  inline constexpr auto operator""_suite() { return ut::suite<Name>{}; }

  inline struct {
    constexpr auto operator()( /// assert
      const std::same_as<bool> auto cond,
      std::string_view msg = {},
      std::source_location location = std::source_location::current()) {
      if consteval {
        if (not cond) {
          void failed(); failed();
        }
      } else {
        if (not cond) {
          error(location, msg);
        }
      }
    }

    constexpr auto operator[]( /// fatal
      const std::same_as<bool> auto cond,
      std::string_view msg = {},
      std::source_location location = std::source_location::current()) {
      if consteval {
        if (not cond) {
          void fatal(); fatal();
        }
      } else {
        if (not cond) {
          error(location, msg);
        }
      }
    }

    constexpr auto operator=(auto&& fn) { error = fn; }

   private:
    void (*error)(std::source_location, std::string_view msg) = [](auto...) { std::abort(); };
  } expect{};

  struct config {
    bool verbose = false;
  };
} // namespace ut

namespace fake {
  template<std::array Vs>
  struct random_suite {
    using result_type = decltype(Vs)::value_type;
    constexpr explicit random_suite(auto&&...) { }
    [[nodiscard]] constexpr auto operator()() const {
      verify(i < Vs.size());
      return Vs[i++];
    }
    [[nodiscard]] static constexpr auto min() {
      return *std::min_element(Vs.begin(), Vs.end());
    }
    [[nodiscard]] static constexpr auto max() {
      return *std::max_element(Vs.begin(), Vs.end());
    }
   private:
    mutable std::size_t i{};
  };

  template<class T>
  struct distribution {
    using result_type = T;
    constexpr explicit distribution(auto&&...) { }
    [[nodiscard]] constexpr auto operator()(const auto& suite) const {
      return suite();
    }
  };

  struct value {
    int value{};
    [[nodiscard]] constexpr operator auto() const {
      return value;
    }
  };

  template<fixed_string Name, auto Time>
  struct time {
    constexpr time() {
      start_calls = {};
      stop_calls = {};
    }

    constexpr void start() { ++start_calls; }
    constexpr void stop() { ++stop_calls; }

    [[nodiscard]] constexpr auto operator*() const {
      return perf::stat::duration<std::nano>(Time);
    }

    [[nodiscard]] constexpr auto operator<=>(const time&) const -> bool = default;

    [[nodiscard]] static constexpr auto name() {
      static constexpr auto name = Name;
      return (name);
    }

    static inline std::size_t start_calls{};
    static inline std::size_t stop_calls{};
  };

  struct runner {
    [[nodiscard]] static constexpr auto name() {
      return "fake_runner";
    }
    [[nodiscard]] constexpr auto operator()(auto&&...) const {
      return std::vector{42};
    }
  };

  struct subprocess {
    constexpr explicit subprocess(auto&&...) { cmds = {}; }
    constexpr void write(const auto cmd) { cmds.push_back(cmd); }
    constexpr void flush() { cmds.push_back("flush\n"); }
    static inline std::vector<std::string> cmds{};
  };

  template<class... Ts>
  struct dataset {
    constexpr explicit dataset(const Ts&... ts)
      : ts_{ts...}
    { }

    [[nodiscard]] constexpr auto operator[](const auto&... ts) const {
      return std::tuple{[&](const auto& t) -> decltype(auto) {
        if constexpr (requires { t(*this); }) {
          return t(*this);
        } else {
          return std::get<std::remove_cvref_t<decltype(t)>>(ts_);
        }
      }(ts)...};
    }

    std::tuple<Ts...> ts_{};
  };

  template<class TName, class... Ts>
  using metadata = std::vector<result<TName, std::tuple<Ts...>>>;
} // namespace fake

inline void test([[maybe_unused]] const ut::config& config = {}) {
  using ut::operator""_suite;
  using ut::operator""_test;
  using ut::expect;

  scoped _{
    .on_entry = [&] {
      expect = [](auto location, auto msg) {
        throw std::runtime_error{
          std::format("{}:{}:FAILED:{}\n", location.file_name(), location.line(), msg)
        };
      };
      #if PERF_IO == 1
      if (config.verbose) {
        "*"_suite.setup = [](auto name) { log(std::clog, "{}\n", name); };
        "*"_test.setup = [](auto name) { log(std::clog, "  {}\n", name); };
      }
      #endif // PERF_IO == 1
    },
    .on_exit = [&] {
      #if PERF_IO == 1
      if (config.verbose) {
        log(std::clog, "\n");
      }
      #endif // PERF_IO == 1
    },
  };

  "configuration"_suite = [] {
    "PERF_*"_test = [] consteval {
      expect(PERF_GNU >= 0);
      expect(PERF_LINUX >= 0);
      expect(PERF_UEFI >= 0);
      expect(PERF_LLVM >= 0);
      expect(PERF_INTEL >= 0);
      expect(PERF_UEFI >= 0);
    };
  };

  "utility"_suite = [] {
    "verify"_test = [] mutable {
      verify(true);
      verify(true, "");

      {
        std::string error{};
        try {
          verify(false);
        } catch(const std::runtime_error& e) {
          error = e.what();
        }
        expect(error.empty());
      }

      {
        std::string error{};
        try {
          verify(false, "[msg]");
        } catch(const std::runtime_error& e) {
          error = e.what();
        }
        expect("[msg]" == error);
      }

      {
        std::string error{};
        try {
          verify(false, "[msg1]", "[msg2]");
        } catch(const std::runtime_error& e) {
          error = e.what();
        }
        expect("[msg1][msg2]" == error);
      }
    };

    "constant"_test = [] consteval {
      expect(1 == constant<fake::value{1}>{}.value);
      expect(2 == constant<fake::value{2}>{}.value);
      expect(1 == decltype(constant<fake::value{1}>{}){}.value);
      expect(2 == decltype(constant<fake::value{2}>{}){}.value);
    };

    "strong_alias"_test = [] constexpr {
      {
        expect(sizeof(double) == sizeof(strong_alias<double>));
        expect(sizeof(int) == sizeof(strong_alias<int>));
        expect(sizeof(bool) == sizeof(strong_alias<bool>));
      }

      {
        expect(0 == strong_alias<int>{0}.value);
        expect(3ull == strong_alias<std::uint64_t>{3ull}.value);
      }

      {
        expect(0 == strong_alias<int>{0});
        expect(3ull == strong_alias<std::uint64_t>{3ull});
      }
    };

    "scoped"_test = [] constexpr {
      auto on_entry = false;
      auto on_exit = false;

      {
        scoped _ {
          .on_entry = [&] { on_entry = true; },
          .on_exit  = [&] { on_exit = true; },
        };

        expect(on_entry);
        expect(not on_exit);
      }

      expect(on_entry);
      expect(on_exit);
    };

    "initialized"_test = [] consteval {
      struct value { int value{}; };
      expect(0 == initialized<value>{}.value);
      expect(0 == decltype(initialized<value>{}){}.value);
      expect(1 == initialized<value, 1>{}.value);
      expect(1 == decltype(initialized<value, 1>{}){}.value);
    };

    "converted"_test = [] consteval {
      struct value { int value{}; };
      expect(0 == static_cast<value>(converted<value>{}).value);
      expect(0 == static_cast<value>(decltype(converted<value>{}){}).value);
      expect(1 == static_cast<value>(converted<value, 1>{}).value);
      expect(1 == static_cast<value>(decltype(converted<value, 1>{}){}).value);
    };

    "overload"_test = [] consteval {
      expect(1 == overload{[] { return 1; }}());
      expect(1 == overload{[] { return 1; }, [](auto i) { return i; }}());
      expect(2 == overload{[] { return 1; }, [](auto i) { return i; }}(2));
      expect(2 == overload{[](auto i) { return i; }}(2));
      expect(2 == overload{[](auto i) { return i; }, [] { return 1; }}(2));
    };

    "fixed_string"_test = [] consteval {
      using std::literals::string_view_literals::operator""sv;
      expect[0u == fixed_string{""}.size()];
      expect[sizeof("perf") - 1u == fixed_string{"perf"}.size()];
      expect('p' == fixed_string{"perf"}.str[0]);
      expect('e' == fixed_string{"perf"}.str[1]);
      expect('r' == fixed_string{"perf"}.str[2]);
      expect('f' == fixed_string{"perf"}.str[3]);
      expect(""sv != std::string_view{fixed_string{"perf"}});
      expect("PERF"sv != std::string_view{fixed_string{"perf"}});
      expect("perf"sv == std::string_view{fixed_string{"perf"}});
    };

    "concat"_test = [] consteval {
      using std::literals::string_view_literals::operator""sv;
      expect(""sv == concat());
      expect("perf"sv == concat(fixed_string{"perf"}));
      expect(
        "x86-64"sv ==
        concat(
          fixed_string{"x86"},
          fixed_string{"-"},
          fixed_string{"64"}
        )
      );
    };

    "fixed_named"_test = [] consteval {
      using std::literals::string_view_literals::operator""sv;
      expect(typeid(fake::value) == typeid(decltype(fixed_named<"named", fake::value>{})::underlying_type));
      expect(0 == fixed_named<"named", fake::value>{}.value);
      expect(123 == fixed_named<"named", fake::value>{123}.value);
      expect("named"sv == std::string_view(fixed_named<"named", fake::value>{}.name()));
      expect("fake"sv == std::string_view(fixed_named<"fake", fake::value>{}.name()));
    };

    "make_fixed_named"_test = [] consteval {
      expect(typeid(fixed_named<"fake", fake::value>) == typeid(make_fixed_named<"fake">(fake::value{})));
      expect(123 == make_fixed_named<"fake">(fake::value{123}).value);
    };

    "named"_test = [] consteval {
      using std::literals::string_view_literals::operator""sv;
      {
        expect(""sv == named<std::string_view, fake::value>{}.name());
        expect(fake::value{} == named<std::string_view, fake::value>{}.value);
      }

      {
        expect("name"sv == named{"name"sv, fake::value{}}.name());
        expect(42 == named{"name"sv, fake::value{42}}.value);
      }

      {
        expect("name"sv == named{"name", fake::value{}}.name());
        expect(42 == named{"name", fake::value{42}}.value);
      }
    };
  };

  "mp"_suite = [] {
    "type_list"_test = [] consteval {
      expect(1u == sizeof(mp::type_list<>));
      expect(1u == sizeof(mp::type_list<void>));
      expect(1u == sizeof(mp::type_list<int, void>));
      expect(1u == sizeof(mp::type_list<const void*, const void, void*>));
    };

    "type_id"_test = [] consteval {
      expect(mp::type_id<void> == mp::type_id<void>);
      expect(mp::type_id<int> != mp::type_id<void>);
      expect(mp::type_id<int> == mp::type_id<int>);
      expect(mp::type_id<int> != mp::type_id<const int&>);
      expect(mp::type_id<int, void> == mp::type_id<int, void>);
      expect(mp::type_id<int, void> != mp::type_id<void, int>);
    };

    "meta"_test = [] consteval {
      expect(typeid(mp::meta<void>) == typeid(mp::meta<int>));
      expect(mp::meta<void> != mp::meta<int>);
      expect(mp::meta<void> == mp::meta<void>);
      expect(mp::meta<int> == mp::meta<int>);
    };

    "info"_test = [] consteval {
      expect(2u == std::vector<mp::info>{
        mp::meta<int>,
        mp::meta<void>
      }.size());
      expect(typeid(mp::info) == typeid(mp::meta<void>));
      expect(typeid(mp::info) == typeid(mp::meta<int>));
    };

    "apply"_test = [] consteval {
      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::apply<mp::type_list, std::array<mp::info, 0u>{}>())
      );

      expect(
        typeid(mp::type_list<void>) ==
        typeid(mp::apply<mp::type_list, std::array{mp::meta<void>}>())
      );

      expect(
        typeid(mp::type_list<int, void>) ==
        typeid(mp::apply<mp::type_list,
          std::array{
            mp::meta<int>,
            mp::meta<void>
          }>())
      );

      expect(
        typeid(mp::type_list<const int&, const void*, void*>) ==
        typeid(mp::apply<
          mp::type_list,
          std::array{
            mp::meta<const int&>,
            mp::meta<const void*>,
            mp::meta<void*>
          }>()
        )
      );
    };

    "version"_test = [] consteval {
      constexpr auto tag = []{};

      expect(mp::version<tag, int>() == 0u);
      expect(typeid(mp::type_list<int>) == typeid(mp::version<tag>()));
      expect(typeid(mp::type_list<int>) == typeid(mp::version<tag>())); /// same!

      expect(mp::version<tag, void>() == 1u);
      expect(typeid(mp::type_list<int, void>) == typeid(mp::version<tag>()));
      expect(typeid(mp::type_list<int, void>) == typeid(mp::version<tag>())); /// same!
    };

    "size"_test = [] consteval {
      expect(0u == mp::size<void>);
      expect(0u == mp::size<mp::type_list<>>);
      expect(1u == mp::size<mp::type_list<void>>);
      expect(2u == mp::size<mp::type_list<int, void>>);
      expect(2u == mp::size<std::tuple<int, float>>);
    };

    "filter"_test = [] consteval {
      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::filter<[]<class> { return true; }, mp::type_list>(
          mp::type_list<>{}
        ))
      );

      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::filter<[]<class> { return false; }, mp::type_list>(
          mp::type_list<void>{}
        ))
      );

      expect(
        typeid(mp::type_list<void>) ==
        typeid(mp::filter<[]<class> { return true; }, mp::type_list>(
          mp::type_list<void>{}
        ))
      );

      expect(
        typeid(mp::type_list<int, void>) ==
        typeid(mp::filter<[]<class> { return true; }, mp::type_list>(
          mp::type_list<int, void>{}
        ))
      );

      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::filter<[]<class> { return false; }, mp::type_list>(
          mp::type_list<int, void>{}
        ))
      );

      expect(
        typeid(mp::type_list<void>) ==
        typeid(mp::filter<[]<class T> { return std::is_void_v<T>; }, mp::type_list>(
          mp::type_list<int, void>{}
        ))
      );

      expect(
        typeid(std::tuple<int>) ==
        typeid(mp::filter<[]<class T> { return not std::is_void_v<T>; }, std::tuple>(
          mp::type_list<int, void>{}
        ))
      );
    };

    "unroll"_test = [] consteval {
      {
        auto calls = 0u;
        mp::unroll<0>([&]{ ++calls; });
        expect(calls == 0u);
      }

      {
        auto calls = 0u;
        mp::unroll<1>([&]{ ++calls; });
        expect(calls == 1u);
      }

      {
        auto calls = 0u;
        mp::unroll<2>([&]{ ++calls; });
        expect(calls == 2u);
      }

      {
        auto calls = 0u;
        mp::unroll<3>([&]<auto N>{ calls += N; });
        expect(calls == 0u + 1u + 2u);
      }
    };

    "for_each"_test = [] consteval {
      {
        auto sum = 0u;
        mp::for_each<std::array<int, 0u>{}>([&]<auto I>{ sum += I; });
        expect(sum == 0u);
      }

      {
        auto sum = 0u;
        mp::for_each<std::array{1u}>([&]<auto I>{ sum += I; });
        expect(sum == 1u);
      }

      {
        auto sum = 0;
        mp::for_each<std::array{1, 2, 3}>([&]<auto I>{ sum += I; });
        expect(sum == 1 + 2 + 3);
      }
    };

    "function_traits"_test = [] consteval {
      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::function_traits<decltype([]{})>::args_type)
      );
      expect(
        typeid(void) ==
        typeid(mp::function_traits<decltype([]{})>::result_type)
      );

      expect(
        typeid(mp::type_list<int>) ==
        typeid(mp::function_traits<decltype([](int) mutable {})>::args_type)
      );
      expect(
        typeid(void) ==
        typeid(mp::function_traits<decltype([](int) mutable {})>::result_type)
      );

      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::function_traits<decltype([]() noexcept -> int { return {}; })>::args_type)
      );
      expect(
        typeid(int) ==
        typeid(mp::function_traits<decltype([]() noexcept -> int { return {}; })>::result_type)
      );

      expect(
        typeid(mp::type_list<const int&, const float*>) ==
        typeid(mp::function_traits<decltype([](const int&, const float*) noexcept {})>::args_type)
      );
      expect(
        typeid(void) ==
        typeid(mp::function_traits<decltype([](const int&, const float*) noexcept {})>::result_type)
      );

      expect(
        typeid(mp::type_list<>) ==
        typeid(mp::function_traits<void (*)()>::args_type)
      );
      expect(
        typeid(void) ==
        typeid(mp::function_traits<void (*)()>::result_type)
      );

      expect(
        typeid(mp::type_list<int>) ==
        typeid(mp::function_traits<void (*)(int)>::args_type)
      );
      expect(
        typeid(int) ==
        typeid(mp::function_traits<int (*)(int)>::result_type)
      );

      expect(
        typeid(mp::type_list<int, float, short*>) ==
        typeid(mp::function_traits<void (*)(int, float, short*)>::args_type)
      );
      expect(
        typeid(const float&) ==
        typeid(mp::function_traits<auto (*)(int, float, short*) noexcept -> const float&>::result_type)
      );
    };
  };

  "data"_suite = [] {
    "random"_suite = [] {
      "choice"_test = [] mutable {
        expect(std::vector<int>{} == data::choice<int>{.values = {1}, .probabilities = {1.}}(0u));
        expect(std::vector<int>{1} == data::choice<int>{.values = {1}, .probabilities = {1.}}(1u));
        expect(std::vector<int>{2} == data::choice<int>{.values = {1, 2}, .probabilities = {0., 1.}}(1u));
        expect(std::vector<int>{2, 2} == data::choice<int>{.values = {1, 2}, .probabilities = {0., 1.}}(2u));
        expect(std::vector<int>{1, 1} == data::choice<int>{.values = {1, 2}, .probabilities = {1., 0.}}(2u));
      };

      "uniform"_test = [] mutable {
        expect(std::vector<int>{} == data::uniform<int>{.min = 0, .max = 0, .seed = 0}(0u));
        expect(std::vector<int>{0} == data::uniform<int>{.min = 0, .max = 0, .seed = 0}(1u));
        expect(std::vector<int>{0, 0} == data::uniform<int>{.min = 0, .max = 0, .seed = 0}(2u));
        expect(std::vector<int>{1} == data::uniform<
          int, int, fake::random_suite<{1,2,3}>, fake::distribution<int>
        >{.min = 0, .max = 10, .seed = 0}(1u));
        expect(std::vector<int>{1, 2} == data::uniform<
          int, int, fake::random_suite<{1,2,3}>, fake::distribution<int>
        >{.min = 0, .max = 10, .seed = 0}(2u));
        expect(std::vector<int>{1, 2, 3} == data::uniform<
          int, int, fake::random_suite<{1,2,3}>, fake::distribution<int>
        >{.min = 0, .max = 10, .seed = 0}(3u));
      };

      "normal"_test = [] mutable {
        expect(std::vector<float>{} == data::normal<float>{.mean = 0., .stddev = 0., .seed = 0}(0u));
        expect(std::vector<float>{0.} == data::normal<float>{.mean = 0., .stddev = 0., .seed = 0}(1u));
        expect(std::vector<float>{1.} == data::normal<
          float, fake::random_suite<{1., 2., 3.}>, fake::distribution<float>
        >{.mean = 1., .stddev = 1., .seed = 0}(1u));
        expect(std::vector<float>{1., 2.} == data::normal<
          float, fake::random_suite<{1., 2., 3.}>, fake::distribution<float>
        >{.mean = 1., .stddev = 1., .seed = 0}(2u));
        expect(std::vector<float>{1., 2., 3.} == data::normal<
          float, fake::random_suite<{1., 2., 3.}>, fake::distribution<float>
        >{.mean = 1., .stddev = 1., .seed = 0}(3u));
      };
    };

    "fixed"_suite = [] {
      "sequence"_test = [] mutable {
        expect(std::vector{0} == data::sequence<int>({0})(1u));
        expect(std::vector{0, 0} == data::sequence<int>{.values = {0}}(2u));
        expect(std::vector{0} == data::sequence<int>({0, 1})(1u));
        expect(std::vector{0, 1} == data::sequence<int>({0, 1})(2u));
        expect(std::vector{0, 1, 0} == data::sequence<int>({0, 1})(3u));
        expect(std::vector{0, 1, 0, 1} == data::sequence<int>{.values = {0, 1}}(4u));
        expect(std::vector{2, 1} == data::sequence<int>({2, 1, 3})(2u));
        expect(std::vector{2, 1, 3, 2, 1} == data::sequence<int>({2, 1, 3})(5u));
        expect(std::vector{2ul, 1ul, 3ul, 2ul, 1ul} == data::sequence<std::size_t>{.values = {2, 1, 3}}(5u));
      };

      "range"_test = [] mutable {
        expect(std::vector<int>{} == data::range<int>{.start = 0, .stop = 2, .step = 1}(0u));
        expect(std::vector{0} == data::range<int>{.start = 0, .stop = 2, .step = 1}(1u));
        expect(std::vector{1, 11} == data::range<int>{.start = 1, .stop = 100, .step = 10}(2u));
        expect(std::vector{1, 3, 5} == data::range<int>{.start = 1, .stop = 6, .step = 2}(3u));

        expect(std::vector{0} == data::range<int>{.start = 0, .stop = 3, .step = 1}(1u));
        expect(std::vector{0, 1} == data::range<int>{.start = 0, .stop = 3, .step = 1}(2u));
        expect(std::vector{0, 1, 2} == data::range<int>{.start = 0, .stop = 3, .step = 1}(3u));
        expect(std::vector{0, 1, 2, 0} == data::range<int>{.start = 0, .stop = 3, .step = 1}(4u));
        expect(std::vector{0, 1, 2, 0, 1} == data::range<int>{.start = 0, .stop = 3, .step = 1}(5u));
        expect(std::vector{0, 1, 2, 0, 1, 2} == data::range<int>{.start = 0, .stop = 3, .step = 1}(6u));
      };

      "linspace"_test = [] mutable {
        expect(std::vector{1, 2} == data::linspace(1, 2));
        expect(std::vector{1, 2, 3} == data::linspace(1, 3));
        expect(std::vector{2, 3, 4, 5, 6, 7} == data::linspace(2, 7));

        expect(std::vector{1, 2} == data::linspace(1, 2, 2));
        expect(std::vector{2, 4} == data::linspace(2, 4, 2));
        expect(std::vector{2, 4, 6, 8, 10} == data::linspace(2, 10, 5));
        expect(std::vector{5, 10} == data::linspace(5, 10, 2));
        expect(std::vector{5, 6, 7, 8, 9, 10} == data::linspace(5, 10, 6));
      };

      "bin"_test = [] mutable {
        expect(std::vector{2ul, 1ul} == data::bin(std::vector{1, 2, 3}, 1, 3, 2));
        expect(std::vector{1ul, 1ul} == data::bin(std::vector{1, 2, 3}, 2, 3, 2));
        expect(std::vector{1ul, 1ul, 1ul} == data::bin(std::vector{1, 2, 3}, 1, 3, 3));
        expect(std::vector{3ul, 2ul} == data::bin(std::vector{1, 2, 3, 4, 5}, 2, 4, 2));
        expect(std::vector{1ul, 1ul, 1ul, 1ul, 1ul} == data::bin(std::vector{1, 2, 3, 4, 5}, 1, 5, 5));
      };
    };

    "sample"_test = [] mutable {
      expect(std::vector<std::vector<int>>{} == data::sample<std::vector<int>>(data::sequence<int>{{1}}, 0u)(0u));
      expect(std::vector<std::vector<int>>{std::vector<int>{}} == data::sample<std::vector<int>>(data::sequence<int>{{1}}, 0u)(1u));
      expect(std::vector<std::vector<int>>{std::vector{1}} == data::sample<std::vector<int>>(data::sequence<int>{{1}}, 1u)(1u));
      expect(
        std::vector<std::vector<int>>{std::vector{1,2,3,1,2}, std::vector{1,2,3,1,2}} ==
        data::sample<std::vector<int>>(data::sequence<int>{{1,2,3}}, 5u)(2u)
      );
    };
  };

  "metric"_suite = [] {
    "op"_test = [] consteval {
      constexpr auto n1 = fixed_named<"name1", fake::value>{1};
      constexpr auto n2 = fixed_named<"name2", fake::value>{2};

      fake::dataset data{n1, n2};

      {
        auto&& t = metric::op<"op", decltype(n1), decltype(n2), [](const auto& lhs, const auto& rhs) {
          return lhs.value + rhs.value;
        }>{};
        expect(n1 + n2 == t(data));
      }

      {
        using metric::operator+;
        using metric::operator-;
        using metric::operator*;
        using metric::operator/;

        {
          expect(n1.value + n2.value == (n1 + n2)(data));
          expect(n1.value - n2.value == (n1 - n2)(data));
          expect(n1.value * n2.value == (n1 * n2)(data));
          expect(n1.value / n2.value == (n1 / n2)(data));
        }

        {
          expect(n1.value + n2.value + n1.value == (n1 + n2 + n1)(data));
          expect((n1.value + n2.value) - n2.value == ((n1 + n2) - n2)(data));
          expect(n1.value * (n1.value + n2.value) / n2.value == (n1 * (n1 + n2) / n2)(data));
        }
      }
    };

    "stat"_suite = [] {
      "min"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("min"sv == metric::min.name());
        expect(0 == metric::min(std::array{0}));
        expect(1 == metric::min(std::array{1, 1}));
        expect(1 == metric::min(std::array{1, 2, 3}));
        expect(-3 == metric::min(std::array{-3, 2, 3}));
      };

      "max"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("max"sv == metric::max.name());
        expect(0 == metric::max(std::array{0}));
        expect(1 == metric::max(std::array{1, 1}));
        expect(3 == metric::max(std::array{1, 2, 3}));
        expect(3 == metric::max(std::array{3, 2, -3}));
      };

      "median"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("median"sv == metric::median.name());
        expect(1 == metric::median(std::array{1}));
        expect(2 == metric::median(std::array{1, 3}));
        expect(2 == metric::median(std::array{1, 2, 3}));
        expect(2 == metric::median(std::array{1, 4, 3, 2}));
        expect(3 == metric::median(std::array{2, 3, 1, 4, 5}));
      };

      "mean"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("mean"sv == metric::mean.name());
        expect(1 == metric::mean(std::array{1}));
        expect(2 == metric::mean(std::array{1, 3}));
        expect(2 == metric::mean(std::array{1, 2, 3}));
        expect(0 == metric::mean(std::array{-1, 0, 1}));
      };

      "geomean"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("geomean"sv == metric::geomean.name());
        expect(1 == metric::geomean(std::array{1}));
        expect(2 == metric::geomean(std::array{1, 4}));
        expect(2 == metric::geomean(std::array{1, 2, 4}));
      };

      "percentile"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        {
          const auto p50 = metric::percentile(50);
          expect("p50"sv == p50.name());
          expect(9 == p50(std::array{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}));
          expect(1 == p50(std::array{1,1,1}));
        }

        {
          const auto p90 = metric::percentile(90);
          expect("p90"sv == p90.name());
          expect(17 == p90(std::array{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}));
          expect(3 == p90(std::array{3, 3, 3, 3, 3}));
        }

        {
          const auto p99 = metric::percentile(99);
          expect("p99"sv == p99.name());
          expect(17 == p99(std::array{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}));
          expect(3 == p99(std::array{3, 3, 3, 3, 3}));
        }
      };

      "variance"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("variance"sv == metric::variance.name());
        expect(0 == metric::variance(std::array{1}));
        expect(0 == metric::variance(std::array{1, 1}));
        expect(0 == metric::variance(std::array{5, 5, 5}));
        expect(std::fabs(.66 - metric::variance(std::array{1., 2., 3.})) <= .1);
      };

      "stddev"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("stddev"sv == metric::stddev.name());
        expect(0 == metric::stddev(std::array{1}));
        expect(0 == metric::stddev(std::array{1, 1}));
        expect(0 == metric::stddev(std::array{5, 5, 5}));
        expect(std::fabs(.81 - metric::stddev(std::array{1., 2., 3.})) <= .1);
      };

      "sem"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("sem"sv == metric::sem.name());
        expect(0 == metric::sem(std::array{1}));
        expect(0 == metric::sem(std::array{1, 1}));
        expect(0 == metric::sem(std::array{1, 1, 1}));
      };

      "mae"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("mae"sv == metric::mae.name());
        expect(0 == metric::mae(std::array{1}));
        expect(0 == metric::mae(std::array{1, 1}));
        expect(0 == metric::mae(std::array{2, 2, 2}));
      };

      "mad"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("mad"sv == metric::mad.name());
        expect(0 == metric::mad(std::array{1}));
        expect(1 == metric::mad(std::array{1, 3}));
        expect(1 == metric::mad(std::array{1, 2, 3}));
      };

      "cv"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("cv"sv == metric::cv.name());
        expect(0 == metric::cv(std::array{1}));
        expect(0 == metric::cv(std::array{2, 2, 2}));
        expect(std::fabs(.4 - metric::cv(std::array{1., 2., 3.})) <= .1);
      };

      "z_score"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("z_score"sv == metric::z_score.name());
        const auto z = metric::z_score(std::array{1., 2., 3.});
        expect(z.size() == 3);
        expect(z[1] == 0); /// centered at mean
        expect(z.front() < 0);
        expect(z.back() > 0);
      };

      "t_score"_test = [] mutable {
        using std::literals::string_view_literals::operator""sv;
        expect("t_score"sv == metric::t_score.name());
        const auto t = metric::t_score(std::array{1., 2., 3.});
        expect(t.size() == 3);
        expect(t[1] == 0); /// centered at mean
        expect(t.front() < 0);
        expect(t.back() > 0);
      };
    };
  };

  "info"_suite = [] {
    "spec"_test = [] mutable {
      using std::literals::string_view_literals::operator""sv;
      {
        auto&& s = info::spec{{{"desc", "info"}, {"int", 42}}};
        expect(s.begin() != s.end());
        expect(s["desc"] == "info"sv);
        expect(s["int"] == std::format("{}", 42));
      }

      {
        info::spec spec{};
        expect(spec.begin() == spec.end());
        spec["info"] = "desc";
        expect(spec.begin() != spec.end());
        expect(spec["info"] == "desc"sv);
      }
    };

    "compiler"_suite = [] {
      "name"_test = [] consteval {
        expect(not info::compiler::name().empty());
      };
    };

    "cpu"_suite = [] {
      "name"_test = [] mutable {
        expect(not info::cpu::name().empty());
      };

      #if PERF_GNU == 1 and defined(__x86_64__)
      "version"_test = [] mutable {
        auto&& version = info::cpu::version();
        expect((version.family + version.model + version.stepping) > 0);
      };
      #endif // PERF_GNU and __x86_64__

      #if PERF_LLVM == 1
      "code_name"_test = [] mutable {
        expect(not info::cpu::code_name().empty());
      };

      //TODO
      //"dispatch_width"_test = [] mutable {
        //llvm llvm{};
        //expect(info::cpu::dispatch_width(llvm) > 0u);
      //};

      "features"_test = [] mutable {
        auto&& features = info::cpu::features();
        expect(not features.empty());
        for (const auto& feature : features) {
          expect(not feature.empty());
        }
      };
      #endif // PERF_LLVM
    };

    #if PERF_LINUX == 1
    "memory"_suite = [] {
      "icache"_test = [] mutable {
        for (const auto& [cache, data] : info::memory::icache()) {
          expect(cache == decltype(cache)::L1);
          expect(data.size > 0u);
          expect(data.line_size > 0u);
        }
      };

      "dcache"_test = [] mutable {
        for (const auto& [cache, data] : info::memory::dcache()) {
          expect(
            cache == decltype(cache)::L1 or
            cache == decltype(cache)::L2 or
            cache == decltype(cache)::L3
          );
          expect(data.size > 0u);
          expect(data.line_size > 0u);
          expect(data.assoc > 0u);
        }
      };
    };
    #endif // PERF_LINUX

    "sys"_suite = [] {
      "name"_test = [] mutable {
        expect(not info::sys::name().empty());
      };

      #if PERF_LLVM == 1
      "triple"_test = [] mutable {
        expect(not info::sys::triple().empty());
      };
      #endif // PERF_LLVM
    };

    "proc"_suite = [] {
      "name"_test = [] mutable {
        expect(not info::proc::self::name().empty());
      };

      "base_address"_test = [] mutable {
        const auto value = 0;
        const auto base_address = info::proc::self::base_address();
        expect(std::uint64_t(std::addressof(value)) >= base_address);
      };
    };

    #if PERF_LLVM == 1
    "bin"_suite = [] {
      "addr_to_line"_test = [] mutable {
        expect(not info::bin::addr_to_line(info::proc::self::name(), 0ul).has_value());
      };

      "addr_to_name"_test = [] mutable {
        expect(info::bin::addr_to_name(info::proc::self::name(), 0ul).has_value());
      };

      "addr_to_fn_name"_test = [] mutable {
        expect(info::bin::addr_to_fn_name(info::proc::self::name(), 0ul).has_value());
      };
    };
    #endif // PERF_LLVM
  };

  "core"_suite = [] {
    "code"_suite = [] {
      "align"_test = [] consteval {
        expect(not []<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(0u)>());
        expect(not []<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(5u)>());
        expect(not []<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(15u)>());
        expect(not []<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(127u)>());

        expect([]<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(16u)>());
        expect([]<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(32u)>());
        expect([]<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(64u)>());
        expect([]<auto Alignment> { return requires { code::align<Alignment>(); }; }.template operator()<std::align_val_t(128u)>());
      };

      "align"_test = [] mutable {
        static constexpr auto begin = "align.begin";
        static constexpr auto end = "align.end";
        code::label<&begin>();
        code::align<std::align_val_t(64u)>();
        code::label<&end>();
        expect(code::labels[&begin] != code::labels[&end]);
      };

      "label"_test = [] mutable {
        static constexpr auto begin = "label.begin";
        static constexpr auto end = "label.end";

        code::label<&begin>();
        code::label<&end>();
        #if __OPTIMIZE__
        expect(code::labels[&begin] == code::labels[&end]);
        #else
        expect(code::labels[&begin] != code::labels[&end]);
        #endif
      };

      "labels"_test = [] consteval {
        static constexpr auto label = "";
        expect(requires { code::labels["label"]; });
        expect(requires { code::labels[0ul]; });
        expect(requires { code::labels[&label]; });
      };
    };

    //TODO fomit-frame-pointer
    "compiler"_suite = [] {
      #if __OPTIMIZE__
      "prevent_elision/is_elided"_test = [] mutable {
        int i{}; int* ptr{};

        expect(compiler::is_elided([] { }));
        expect(compiler::is_elided([] { [[maybe_unused]] auto value = 4 + 2; }));
        expect(compiler::is_elided([] { [[maybe_unused]] int i{}; i++; }));

        expect(not compiler::is_elided([&] { i++; }));
        expect(not compiler::is_elided([] { [[maybe_unused]] static int i{}; i++; }));
        expect(not compiler::is_elided([=] {
          int i{};
          compiler::prevent_elision(i++);
        }));
        expect(not compiler::is_elided([] {
          auto value = 4 + 2;
          compiler::prevent_elision(value);
        }));

        expect(42 == compiler::prevent_elision(42));
        expect(ptr == compiler::prevent_elision(ptr));
      };
      #endif // __OPTIMIZE__
    };

    "cpu"_suite = [] {
      "pipeline"_test = [] mutable {
        cpu::pipeline::flush();
      };
    };

    "memory"_suite = [] {
      "align/is_aligned"_test = [] mutable {
        constexpr auto max_alignment = std::align_val_t(alignof(std::max_align_t));
        alignas(64u) std::byte buffer[256u]{};

        const auto test = [&]<enum memory::direction Direction>(const auto cmp) {
          {
            const std::byte* null = nullptr;
            const auto aligned = memory::align<Direction>(null, std::align_val_t(8u));
            expect(aligned == nullptr);
            expect(memory::is_aligned(aligned, std::align_val_t(8u)));
            expect(reinterpret_cast<std::uintptr_t>(aligned) == reinterpret_cast<std::uintptr_t>(null));
          }

          {
            const auto* ptr = buffer + 13u;
            expect(memory::is_aligned(ptr, std::align_val_t(1u)));
            const auto aligned = memory::align<Direction>(ptr, std::align_val_t(1u));
            expect(aligned == ptr);
            expect(reinterpret_cast<std::uintptr_t>(aligned) == reinterpret_cast<std::uintptr_t>(ptr));
          }

          {
            const auto* ptr = buffer + 64u;
            expect(memory::is_aligned(ptr, std::align_val_t(64u)));
            auto aligned = memory::align<Direction>(ptr, std::align_val_t(64u));
            expect(aligned == ptr);
            expect(reinterpret_cast<std::uintptr_t>(aligned) == reinterpret_cast<std::uintptr_t>(ptr));
          }

          {
            const auto* ptr = buffer + 3u;
            expect(not memory::is_aligned(ptr, std::align_val_t(4u)));
            const auto aligned = memory::align<Direction>(ptr, std::align_val_t(4u));
            expect(memory::is_aligned(aligned, std::align_val_t(4u)));
            expect(cmp(reinterpret_cast<std::uintptr_t>(aligned), reinterpret_cast<std::uintptr_t>(ptr)));
          }

          {
            const auto* ptr = buffer + 7u;
            const auto aligned = memory::align<Direction>(ptr, max_alignment);
            expect(memory::is_aligned(aligned, max_alignment));
            expect(cmp(reinterpret_cast<std::uintptr_t>(aligned), reinterpret_cast<std::uintptr_t>(ptr)));
          }
        };

        test.template operator()<memory::direction::up>([](const auto lhs, const auto rhs) { return lhs > rhs; });
        test.template operator()<memory::direction::down>([](const auto lhs, const auto rhs) { return lhs < rhs; });
      };

      #if __has_builtin(__builtin_prefetch)
      "prefetch"_test = [&] mutable {
        int i{};
        auto addr = &i;

        memory::prefetch<memory::operation::read, memory::locality::none>(addr);
        memory::prefetch<memory::operation::read, memory::locality::low>(addr);
        memory::prefetch<memory::operation::read, memory::locality::moderate>(addr);
        memory::prefetch<memory::operation::read, memory::locality::high>(addr);

        memory::prefetch<memory::operation::write, memory::locality::none>(addr);
        memory::prefetch<memory::operation::write, memory::locality::low>(addr);
        memory::prefetch<memory::operation::write, memory::locality::moderate>(addr);
        memory::prefetch<memory::operation::write, memory::locality::high>(addr);
      };
      #endif // __builtin_prefetch

      #if PERF_LINUX == 1
      "lock"_test = [] mutable {
        {
          memory::lock _;
        }
      };

      "pre_fault"_test = [] mutable {
        {
          std::vector<std::byte> memory(1024u);
          memory::pre_fault(memory);
          const auto page_size = info::sys::page_size();
          for (auto i = 0u; i < memory.size(); i += page_size) {
            expect(not bool(memory[i]));
          }
        }

        {
          std::vector<std::byte> memory(128u);
          const auto page_size = 64u;
          memory::pre_fault(memory, page_size);
          for (auto i = 0u; i < memory.size(); i += page_size) {
            expect(not bool(memory[i]));
          }
        }
      };

      "protect"_test = [] mutable {
        constexpr auto invoke = []<class TFn>(std::span<const std::byte> code, auto&&... ts) {
          return std::bit_cast<const TFn* const>(code.data())(std::forward<decltype(ts)>(ts)...);
        };

        {
          const std::array add{
            std::byte(0x89), std::byte(0xf8), /// mov eax, edi
            std::byte(0x01), std::byte(0xf0), /// add eax, esi
            std::byte(0xc3)                   /// ret
          };
          expect(memory::protect(std::span(add), memory::protection::read | memory::protection::write | memory::protection::exec));
          expect(1 + 2 == invoke.template operator()<int(int, int)>(add, 1, 2));
          expect(2 + 3 == invoke.template operator()<int(int, int)>(add, 2, 3));
        }

        {
          const std::array mult{
            std::byte(0x89), std::byte(0xf8),                  /// mov eax, edi
            std::byte(0x0f), std::byte(0xaf), std::byte(0xc6), /// imul eax, esi
            std::byte(0xc3)                                    /// ret
          };
          expect(memory::protect(std::span(mult), memory::protection::read | memory::protection::write | memory::protection::exec));
          expect(1 * 2 == invoke.template operator()<int(int, int)>(mult, 1, 2));
          expect(2 * 3 == invoke.template operator()<int(int, int)>(mult, 2, 3));
        }
      };
      #endif // PERF_LINUX

      "pollute"_test = [] mutable {
        memory::pollute(1u);
        memory::pollute(1024u);
      };

      "cache"_suite = [] {
        "flush"_test = [] mutable {
          int value{};
          memory::cache::flush(std::span(reinterpret_cast<const std::byte*>(&value), sizeof(value)));

          std::array<int, 1024> data{};
          memory::cache::flush(std::span(reinterpret_cast<const std::byte*>(data.data()), data.size()));
        };
      };
    };

    "sys"_suite = [] {
      #if PERF_LINUX == 1
      "thread"_suite = [] {
        "thread"_test = [] mutable {
          expect(pthread_self() == thread::self);
          expect(pthread_self() == sys::thread::self);
        };

        "affinity"_test = [] mutable {
          {
            const auto before = thread::affinity::get(thread::self);
            expect(thread::affinity::set(thread::self, before));
            expect(before == thread::affinity::get(thread::self));
          }

          if (std::thread::hardware_concurrency() >= 2u) {
            const auto affinity = thread::affinity::get(thread::self);
            expect(thread::affinity::set(thread::self, std::array{1ul, 2ul}));
            expect(std::vector{1ul, 2ul} == thread::affinity::get(thread::self));
            expect(thread::affinity::set(thread::self, affinity));
          }
        };

        "priority"_test = [] mutable {
        };
      };
      #endif // PERF_LINUX
    };
  };

  #if PERF_LLVM == 1
  "backend"_suite = [] {
//TODO
#if 0
    "llvm"_test = [] mutable {
      {
        llvm llvm{};
        expect(llvm.arch.triple == ::llvm::Triple::normalize(::llvm::sys::getDefaultTargetTriple()));
        expect(llvm.arch.cpu == ::llvm::sys::getHostCPUName().str());
        expect(bool(llvm.register_info.get()));
        expect(bool(llvm.assembler_info.get()));
        expect(bool(llvm.instruction_info.get()));
        expect(bool(llvm.subtarget_info.get()));
        expect(bool(llvm.instrument_manager.get()));
        expect(bool(llvm.instruction_analysis.get()));
        expect(bool(llvm.instruction_builder.get()));
        expect(bool(llvm.instruction_printer.get()));
        expect(bool(llvm.context.get()));
        expect(bool(llvm.disassembler.get()));
      }

      {
        llvm llvm{arch{}};
        expect(llvm.arch.triple == ::llvm::Triple::normalize(::llvm::sys::getDefaultTargetTriple()));
        expect(llvm.arch.cpu == ::llvm::sys::getHostCPUName().str());
        expect(bool(llvm.register_info.get()));
        expect(bool(llvm.assembler_info.get()));
        expect(bool(llvm.instruction_info.get()));
        expect(bool(llvm.subtarget_info.get()));
        expect(bool(llvm.instrument_manager.get()));
        expect(bool(llvm.instruction_analysis.get()));
        expect(bool(llvm.instruction_builder.get()));
        expect(bool(llvm.instruction_printer.get()));
        expect(bool(llvm.context.get()));
        expect(bool(llvm.disassembler.get()));
      }
    };

    "mca"_suite = [] {
      "disassemble"_test = [] mutable {
        llvm llvm{};

        {
          static constexpr auto begin = "label.begin";
          static constexpr auto end = "label.end";

          int a{}, b{};
          code::label<&begin>();
          compiler::prevent_elision(a + b);
          code::label<&end>();
          const auto& instructions = disassemble({
            code::labels[&begin],
            code::labels[&end]
          }, llvm);

          #if __OPTIMIZE__
          expect(1u == instructions.size());
          #else
          expect(instructions.size() >= 1u);
          #endif // __OPTIMIZE__
        }

        auto add = [](int a, int b) {
          return a + b;
        };

        {
          const auto& instructions = disassemble(
            [&] { return add(1, 2); },
            llvm
          );

          #if __OPTIMIZE__
          expect(1u == instructions.size());
          #else
          expect(instructions.size() >= 1u);
          #endif // __OPTIMIZE__
        }
      };

      "mca"_suite = [] {
        using std::literals::string_view_literals::operator""sv;
        llvm llvm{};

        auto&& mov = [&] {
          const auto& instructions = disassemble(
            [] { return 1; /*0: xor, N: mov*/ },
            llvm
          );
          expect(1u == instructions.size());
          return instructions[0];
        }();

        "assembly"_test = [&] mutable {
          expect("mca.assembly"sv == mca::assembly.name());
          const auto& [ip, str, syntax] = mca::assembly(mov, llvm);
          expect(str.contains("mov"));
          expect(syntax == llvm.arch.syntax);
          expect(std::format("{}", mca::assembly(mov, llvm)).contains("mov"));
        };

        "address"_test = [&] mutable {
          expect("mca.address"sv == mca::address.name());
          const auto& [ip, size] = mca::address(mov, llvm);
          expect(ip == mov.ip);
          expect(size == mov.size);
          expect(not std::format("{}", mca::address(mov, llvm)).empty());
        };

        "encoding"_test = [&] mutable {
          expect("mca.encoding"sv == mca::encoding.name());
          const auto& [ip, size] = mca::encoding(mov, llvm);
          expect(ip == mov.ip);
          expect(size == mov.size);
          expect(not std::format("{}", mca::encoding(mov, llvm)).empty());
        };

        "size"_test = [&] mutable {
          expect("mca.size"sv == mca::size.name());
          const auto& [ip, size] = mca::size(mov, llvm);
          expect(ip > 0ul);
          expect(size == mov.size);
          expect(not std::format("{}", mca::size(mov, llvm)).empty());
        };

        "uops"_test = [&] mutable {
          expect("mca.uops"sv == mca::uops.name());
          const auto& [ip, uops] = mca::uops(mov, llvm);
          expect(ip > 0ul);
          expect(uops >= 1u);
          expect(not std::format("{}", mca::uops(mov, llvm)).empty());
        };

        "latency"_test = [&] mutable {
          expect("mca.latency"sv == mca::latency.name());
          const auto& [ip, latency] = mca::latency(mov, llvm);
          expect(ip > 0ul);
          expect(latency >= 1u);
          expect(not std::format("{}", mca::latency(mov, llvm)).empty());
        };

        "rthroughput"_test = [&] mutable {
          expect("mca.rthroughput"sv == mca::rthroughput.name());
          const auto& [ip, rthroughput] = mca::rthroughput(mov, llvm);
          expect(ip > 0ul);
          expect(rthroughput > 0.);
          expect(not std::format("{}", mca::rthroughput(mov, llvm)).empty());
        };

        "may_load"_test = [&] mutable {
          expect("mca.may_load"sv == mca::may_load.name());
          const auto& [ip, may_load] = mca::may_load(mov, llvm);
          expect(ip > 0ul);
          expect(not may_load); /// reg->reg
          expect("" == std::format("{}", mca::may_load(mov, llvm)));
        };

        "may_store"_test = [&] mutable {
          expect("mca.may_store"sv == mca::may_store.name());
          const auto& [ip, may_store] = mca::may_store(mov, llvm);
          expect(ip > 0ul);
          expect(not may_store); /// reg->reg
          expect("" == std::format("{}", mca::may_load(mov, llvm)));
        };

        "has_side_effects"_test = [&] mutable {
          expect("mca.has_side_effects"sv == mca::has_side_effects.name());
          const auto& [ip, has_side_effects] = mca::has_side_effects(mov, llvm);
          expect(ip > 0ul);
          expect(not has_side_effects);
          expect("" == std::format("{}", mca::has_side_effects(mov, llvm)));
        };

        "branch"_suite = [&] {
          "is_conditional"_test = [&] mutable {
            expect("mca.branch.is_conditional"sv == mca::branch::is_conditional.name());
            const auto& [ip, is_conditional] = mca::branch::is_conditional(mov, llvm);
            expect(ip > 0ul);
            expect(not is_conditional);
            expect("" == std::format("{}", mca::branch::is_conditional(mov, llvm)));
          };

          "is_unconditional"_test = [&] mutable {
            expect("mca.branch.is_unconditional"sv == mca::branch::is_unconditional.name());
            const auto& [ip, is_unconditional] = mca::branch::is_unconditional(mov, llvm);
            expect(ip > 0ul);
            expect(not is_unconditional);
            expect("" == std::format("{}", mca::branch::is_unconditional(mov, llvm)));
          };

          "is_indirect"_test = [&] mutable {
            expect("mca.branch.is_indirect"sv == mca::branch::is_indirect.name());
            const auto& [ip, is_indirect] = mca::branch::is_indirect(mov, llvm);
            expect(ip > 0ul);
            expect(not is_indirect);
            expect("" == std::format("{}", mca::branch::is_indirect(mov, llvm)));
          };

          "is_call"_test = [&] mutable {
            expect("mca.branch.is_call"sv == mca::branch::is_call.name());
            const auto& [ip, is_call] = mca::branch::is_call(mov, llvm);
            expect(ip > 0ul);
            expect(not is_call);
            expect("" == std::format("{}", mca::branch::is_call(mov, llvm)));
          };

          "is_ret"_test = [&] mutable {
            expect("mca.branch.is_ret"sv == mca::branch::is_ret.name());
            const auto& [ip, is_ret] = mca::branch::is_ret(mov, llvm);
            expect(ip > 0ul);
            expect(not is_ret);
            expect("" == std::format("{}", mca::branch::is_ret(mov, llvm)));
          };
        };

        #if PERF_LINUX == 1
        "source"_test = [] mutable {
        };
        #endif // PERF_LINUX

        "timeline"_test = [] mutable {
          using std::literals::string_view_literals::operator""sv;
          llvm llvm{};
          expect("mca.timeline"sv == mca::timeline.name());
          auto&& instructions = disassemble([&] { return 1 + 2; }, llvm);
          auto&& data = mca::timeline(instructions, llvm);
          expect(1u == data.size());
        };

        "resource_pressure"_test = [] mutable {
          using std::literals::string_view_literals::operator""sv;
          llvm llvm{};
          expect("mca.resource_pressure"sv == mca::resource_pressure.name());
          auto&& instructions = disassemble([&] { return 1 + 2; }, llvm);
          auto&& data = mca::resource_pressure(instructions, llvm);
          expect(1u == data.size());
        };

        "bottleneck"_test = [] mutable {
          using std::literals::string_view_literals::operator""sv;
          llvm llvm{};
          expect("mca.bottleneck"sv == mca::bottleneck.name());
          auto&& instructions = disassemble([&] { return 1 + 2; }, llvm);
          auto&& data = mca::bottleneck(instructions, llvm);
          expect(1u == data.size());
        };
      };
    };
#endif
  };
  #endif // PERF_LLVM

  "prof"_suite = [] {
    "profiler"_test = [] mutable {
      {
        auto&& p = profiler{};
        p.start();
        p.stop();
        expect(std::tuple{} == p[]);
      }

      {
        auto&& ft1 = fake::time<"fake_time_1", 1.>{};
        auto&& t = stat::timer{ft1};

        auto&& p = profiler{t};
        expect(0u == ft1.start_calls);
        expect(0u == ft1.stop_calls);

        p.start();
        p.stop();

        expect(1u == ft1.start_calls);
        expect(1u == ft1.stop_calls);
        expect(std::tuple{*ft1} == p[]);
      }

      {
        auto&& ft1 = fake::time<"fake_time_1", 1.>{};
        auto&& ft2 = fake::time<"fake_time_2", 2.>{};
        auto&& t1 = stat::timer{ft1};
        auto&& t2 = stat::timer{ft2};

        auto&& p = profiler{t1, t2};
        expect(0u == ft1.start_calls);
        expect(0u == ft1.stop_calls);
        expect(0u == ft2.start_calls);
        expect(0u == ft2.stop_calls);

        p.start();
        p.stop();

        using metric::operator*;
        expect(1u == ft1.start_calls);
        expect(1u == ft1.stop_calls);
        expect(1u == ft2.start_calls);
        expect(1u == ft2.stop_calls);
        expect(std::tuple{*ft1, *ft2} == p[]);
        expect(std::tuple{*ft1} == p[ft1]);
        expect(std::tuple{*ft2} == p[ft2]);
        expect(*ft1 == *p[ft1]);
        expect(*ft2 == *p[ft2]);
      }
    };

    "time"_suite = [] {
      "duration"_test = [] constexpr {
        expect(typeid(perf::stat::duration<std::nano>::value_type) == typeid(std::chrono::duration<double, std::nano>));

        {
          perf::stat::duration<std::nano> d{};
          expect(not d);
          expect(not d.count());
        }

        {
          perf::stat::duration<std::nano> d{1.2};
          expect(1.2 == d);
          expect(d == d.count());
        }
      };

      "time_like"_test = [] consteval {
        expect(not stat::time_like<void>);

        struct empty{};
        expect(not stat::time_like<empty>);

        struct t_constexpr {
          constexpr void start();
          constexpr void stop();
          constexpr auto operator*() const -> perf::stat::duration<std::nano>;
        };
        expect(stat::time_like<t_constexpr>);

        struct t_no_start {
          void stop();
          auto operator*() const -> perf::stat::duration<std::nano>;
        };
        expect(not stat::time_like<t_no_start>);

        struct t_no_start_no_stop {
          auto operator*() const -> perf::stat::duration<std::nano>;
        };
        expect(not stat::time_like<t_no_start_no_stop>);

        struct t_wrong_ret {
          void start();
          void stop();
          auto operator*() const -> double;
        };
        expect(not stat::time_like<t_wrong_ret>);

        struct t {
          void start();
          void stop();
          auto operator*() const -> perf::stat::duration<std::nano>;
        };
        expect(stat::time_like<t>);
      };

      "stat.time"_suite = [] {
        constexpr auto test = [](auto t) {
          t.start();
          t.stop();
          expect(*t > .0);
          expect((*t).count() > .0);
          expect((*t).count() == *t);
        };

        "steady_time"_test = [test] mutable {
          test(stat::steady_time);
        };

        #if PERF_GNU == 1 and defined(__x86_64__)
        "tsc"_test = [test] mutable {
          test(stat::tsc);
        };
        #endif

        #if PERF_LINUX == 1
        "cpu_time"_test = [test] mutable {
          test(stat::cpu_time);
        };

        "thread_time"_test = [test] mutable {
          test(stat::thread_time);
        };

        "real_time"_test = [test] mutable {
          test(stat::real_time);
        };
        #endif
      };

      "timer"_test = [] mutable {
        using metric::operator*;

        {
          expect([](const auto&... ts) { return requires { stat::timer{ts...}; }; }(fake::time<"", 0.>{}));
          expect([](const auto&... ts) { return requires { stat::timer{ts...}; }; }(stat::steady_time));
          expect([](const auto&... ts) { return requires { stat::timer{ts...}; }; }(fake::time<"", 0.>{}, stat::steady_time));
          expect(not [](const auto&... ts) { return requires { stat::timer{ts...}; }; }(0u));
          expect(not [](const auto&... ts) { return requires { stat::timer{ts...}; }; }(stat::cycles));
          expect(not [](const auto&... ts) { return requires { stat::timer{ts...}; }; }(record::cycles));
          expect(not [](const auto&... ts) { return requires { stat::timer{ts...}; }; }(stat::cycles, record::cycles));
        }

        {
          auto&& t = stat::timer{};
          t.start();
          t.stop();
          expect(typeid(std::tuple{}) == typeid(t[]));
        }

        {
          auto&& ft1 = fake::time<"fake_time_1", 1.>{};

          auto&& t = stat::timer{ft1};
          expect(0u == ft1.start_calls);
          expect(0u == ft1.stop_calls);

          t.start();
          t.stop();

          expect(1u == ft1.start_calls);
          expect(1u == ft1.stop_calls);
          expect(*ft1 == *t[ft1]);
        }

        {
          auto&& ft1 = fake::time<"fake_time_1", 1.>{};
          auto&& ft2 = fake::time<"fake_time_2", 2.>{};

          auto&& t = stat::timer{ft1, ft2};
          expect(0u == ft1.start_calls);
          expect(0u == ft1.stop_calls);
          expect(0u == ft2.start_calls);
          expect(0u == ft2.stop_calls);

          t.start();
          t.stop();

          expect(1u == ft1.start_calls);
          expect(1u == ft1.stop_calls);
          expect(1u == ft2.start_calls);
          expect(1u == ft2.stop_calls);

          expect(*ft1 == *t[ft1]);
          expect(*ft2 == *t[ft2]);
        }
      };
    };

    #if PERF_LINUX == 1
    "stat"_suite = [] {
      "event_like"_test = [] consteval {
        struct empty { };
        expect(not stat::event_like<empty>);

        struct event_no_type {
          auto name() -> std::string_view;
          std::array<std::uint64_t, 3u> config{};
        };
        expect(not stat::event_like<event_no_type>);

        struct event {
          using value_type = std::uint64_t;
          std::string_view name{};
          std::uint32_t type{};
          std::array<std::uint64_t, 3u> config{};
          std::size_t priority{};
        };
        expect(stat::event_like<event>);

        expect(stat::event_like<fixed_named<"event", stat::aux::event>>);
      };

      "counter"_test = [] mutable {
        {
          expect([](const auto&... ts) { return requires { stat::counter{ts...}; }; }(stat::cycles));
          expect(not [](const auto&... ts) { return requires { stat::counter{ts...}; }; }(0u));
          expect(not [](const auto&... ts) { return requires { stat::counter{ts...}; }; }(record::cycles));
          expect(not [](const auto&... ts) { return requires { stat::counter{ts...}; }; }(stat::steady_time));
          expect(not [](const auto&... ts) { return requires { stat::counter{ts...}; }; }(stat::cycles, record::cycles));
          expect(not [](const auto&... ts) { return requires { stat::counter{ts...}; }; }(stat::cycles, record::cycles));
        }

        {
          stat::counter counter{};
          counter.start();
          counter.stop();
          expect(typeid(std::tuple{}) == typeid(counter[]));
        }

        {
          stat::counter counter{stat::config{}};
          counter.start();
          counter.stop();
          expect(typeid(std::tuple{}) == typeid(counter[]));
        }

        {
          stat::counter counter{stat::config{}, stat::cycles};
          counter.start();
          counter.stop();
          //expect(counter[stat::cycles] > 0.);
        }

        {
          stat::counter counter{stat::instructions, stat::cycles};
          counter.start();
          counter.stop();
          //expect(counter[stat::instructions] > 0.);
          //expect(counter[stat::cycles] > 0.);
        }
      };
    };
    #endif // PERF_LINUX

    #if PERF_LINUX == 1
    "record"_suite = [] {
      "event_like"_test = [] consteval {
        struct event {
          using value_type = struct info {
            std::uint64_t ip{};
            std::uint64_t value{};
          };
          std::string_view name{};
          std::uint32_t type{};
          std::array<std::uint64_t, 3u> config{};
        };
        expect(record::event_like<event>);

        struct empty { };
        expect(not record::event_like<empty>);

        struct event_no_type {
          std::string_view name{};
          std::array<std::uint64_t, 3u> config{};
          std::size_t priority{};
        };
        expect(not record::event_like<event_no_type>);

        expect(record::event_like<fixed_named<"event", record::aux::event>>);
      };

      "sampler"_test = [] mutable {
        {
          expect([](const auto&... ts) { return requires { record::sampler{ts...}; }; }(record::cycles));
          expect(not [](const auto&... ts) { return requires { record::sampler{ts...}; }; }(0u));
          expect(not [](const auto&... ts) { return requires { record::sampler{ts...}; }; }(stat::cycles));
          expect(not [](const auto&... ts) { return requires { record::sampler{ts...}; }; }(stat::steady_time));
          expect(not [](const auto&... ts) { return requires { record::sampler{ts...}; }; }(record::cycles, stat::cycles));
        }

        {
          record::sampler sampler{};
          sampler.start();
          sampler.stop();
          expect(typeid(std::tuple{}) == typeid(sampler[]));
        }

        record::config config {
          .interval = record::config::period{1} /// every event
        };

        {
          record::sampler sampler{config, record::cycles};
          sampler.start();
          sampler.stop();
          //expect(not (*sampler)[record::cycles].empty());
        }

        {
          record::sampler sampler{config, record::instructions, record::cycles};
          sampler.start();
          sampler.stop();
          //expect(not (*sampler)[record::instructions].empty());
          //expect(not (*sampler)[record::cycles].empty());
        }
      };
    };
    #endif // PERF_LINUX

    "trace"_suite = [] {
      #if PERF_LINUX == 1 and PERF_INTEL == 1
      "event_like"_test = [] consteval {
        expect(not trace::event_like<void>);

        struct empty {};
        expect(not trace::event_like<empty>);

        expect(trace::event_like<decltype(trace::instructions)>);
        expect(trace::event_like<decltype(trace::cycles)>);
      };

      "tracer"_test = [] mutable {
        {
          {
            trace::tracer tracer{trace::instructions};
            tracer.start();
            tracer.stop();
            //expect(not tracer[trace::instructions].empty());
          }
        }
        // todo multiple traces
      };

//TODO
#if 0
      #if __OPTIMIZE__
      "trace"_test = [] mutable {
        trace::tracer tracer{trace::instructions};

        {
          const auto& t = trace::trace([] { }, tracer);
          expect[0u == t[trace::instructions].size()];
        }

        auto add = [](int a, int b) {
          return a + b;
        };

        {
          const auto& t = trace::trace([&] { /*return */ add(1, 2); }, tracer);
          expect[0u == t[trace::instructions].size()];
        }

        {
          const auto& t = trace::trace([&] { compiler::prevent_elision(add(1, 2)); }, tracer);
          expect[1u == t[trace::instructions].size()];
        }

        {
          const auto& t = trace::trace([&] { return add(1, 2); }, tracer);
          expect[1u == t[trace::instructions].size()];
        }

        {
          const auto& t = trace::trace([&] { /* optimized */ return add(1, 2) + add(3, 4); }, tracer);
          expect[1u == t[trace::instructions].size()];
        }

        //// todo if else branch
        //{
          //bool value{};

          //const auto& t = trace::trace(
            //[&] { if (value) return add(1, 2); },
            //tracer
          //);
          //expect(1u == t.size());
        //}
      };
      #endif // __OPTIMIZE__
#endif
      #endif // PERF_LINUX and PERF_INTEL
    };
  };

  "engine"_suite = [] {
    "name"_test = [] mutable {
      using std::literals::string_view_literals::operator""sv;

      {
        name<std::string> name{fake::runner{}, named("fn1"sv, []{})};
        expect(fake::runner::name() == name.runner);
        expect("fn1"sv == name.function);
        expect(name.parameters.empty());
      }

      {
        name<std::string> name{fake::runner{}, named("fn2"sv, [](int){}), 2};
        expect(fake::runner::name() == name.runner);
        expect("fn2"sv == name.function);
        expect(1u == name.parameters.size());
        expect("2"sv == name.parameters[0u]);
      }

      {
        struct arg{};
        name<std::string> name{fake::runner{}, named("fn3"sv, [](int, arg){}), 3, named("arg"sv, arg{})};
        expect(fake::runner::name() == name.runner);
        expect("fn3"sv == name.function);
        expect(2u == name.parameters.size());
        expect("3"sv == name.parameters[0u]);
        expect("arg"sv == name.parameters[1u]);
      }
    };

    "dataset"_test = [] constexpr {
    };

    "metadata"_test = [] constexpr {
    };

    "runner"_test = [] mutable {
      {
        perf::runner runner{};
      }

      {
        runner runner{fake::runner{}};
      }
    };
  };

  "bench"_suite = [] {
    "utility"_suite = [] {
      "debug_like"_test = [] consteval {
        expect(not bench::utility::debug_like<decltype([]{})>);
        expect(not bench::utility::debug_like<decltype([](int){})>);
        expect(not bench::utility::debug_like<decltype([](int, float){})>);

        expect(bench::utility::debug_like<decltype([]<bool = {}>{})>);
        expect(bench::utility::debug_like<decltype([]<bool = {}>(int){})>);
        expect(bench::utility::debug_like<decltype([]<bool = {}>(int, float){})>);
        expect(bench::utility::debug_like<decltype([]<auto = true>(int, float){})>);
        expect(bench::utility::debug_like<decltype([]<auto = true, auto...>(int, float){})>);
      };

      "debug"_test = [] consteval {
        expect(bench::utility::debug([]<bool Debug = {}> { return Debug; })());
        expect(bench::utility::debug([]<bool Debug = {}>(int) { return Debug; })(int{}));
        expect(bench::utility::debug([]<bool Debug = {}>(int, float) { return Debug; })(int{}, float{}));
      };
    };

    "latency"_test = [] mutable {
    };

    "throughput"_test = [] mutable {
    };
  };

  #if PERF_IO == 1
  "output"_suite = [] {
    "log"_test = [] mutable {
      {
        std::ostringstream os{};
        log(os, "");
        expect(os.str() == "");
      }

      {
        std::ostringstream os{};
        log(os, "perf");
        expect(os.str() == "perf");
      }
    };

    "report"_test = [] mutable {
    };

    "annotate"_test = [] mutable {
    };

    "json"_test = [] mutable {
      const auto data = fixed_named<"fake.data", std::vector<double>>{std::vector{1., 2., 3.}};
      const fake::metadata<std::string, decltype(data)> results{{.name = "fake.benchmark", .data = {data}}};
      std::ostringstream os{};
      json(os, results);
      expect(not os.str().empty());
    };

    "plot"_suite = [] {
      using std::literals::string_literals::operator""s;
      using std::literals::string_view_literals::operator""sv;

      "gnuplot"_suite = [] mutable {
        plot::gnuplot<fake::subprocess> plt{{}};

        {
          plt.send("cmd1");
          expect(fake::subprocess::cmds.size() > 0u);
          expect("cmd1\n"sv == fake::subprocess::cmds.back());
        }

        {
          plt.send("cmd2");
          expect(fake::subprocess::cmds.size() > 1u);
          expect("cmd2\n"sv == fake::subprocess::cmds.back());
        }

        {
          plt.plot(std::array{1, 2, 3}, std::array{1, 2, 3}, "plot"sv, plot::kind::line);
          expect(fake::subprocess::cmds.size() > 2u);
        }

        {
          plt.plot(std::array{1, 2, 3}, std::array{1, 2, 3}, "plots"sv, plot::kind::line, plot::kind::err);
          expect(fake::subprocess::cmds.size() > 2u);
        }

        {
          plt.show();
          expect(fake::subprocess::cmds.size() > 3u);
          expect("flush\n"sv == fake::subprocess::cmds.back());
        }
      };

      constexpr auto make_name = [](auto&& runner, auto&& function, auto&& parameters) {
        name<std::string> name{};
        name.runner = std::move(runner);
        name.function = std::move(function);
        name.parameters = std::move(parameters);
        return name;
      };

      const fixed_named<"fake.data", std::vector<double>> data{std::vector{1., 2., 3.}};
      const fake::metadata<name<std::string>, decltype(data)> results{
        {.name = make_name("fake", "fn1", std::vector{"0"s}), .data = {data}},
        {.name = make_name("fake", "fn1", std::vector{"1"s}), .data = {data}},
      };

      plot::gnuplot<fake::subprocess> plt{{}};

      "hist"_test = [&] mutable {
        plot::hist(plt, results);
        expect(not fake::subprocess::cmds.empty());
      };

      "bar"_test = [&] mutable {
        plot::bar(plt, results);
        expect(not fake::subprocess::cmds.empty());
      };

      "box"_test = [&] mutable {
        plot::box(plt, results);
        expect(not fake::subprocess::cmds.empty());
      };

      "errorbar"_test = [&] mutable {
        plot::errorbar(plt, results);
        expect(not fake::subprocess::cmds.empty());
      };

      "ecdf"_test = [&] mutable {
        plot::ecdf(plt, results);
        expect(not fake::subprocess::cmds.empty());
      };
    };
  };
  #endif // PERF_IO
}
} // namespace perf
#endif // NTEST

// -*- mode: c++; -*-
